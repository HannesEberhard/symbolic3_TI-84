; Zilog eZ80 ANSI C Compiler Release 3.4
; -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"SRC\SYMBOLIC4\SRC\SIMPLIFY.C"
	.assume ADL=1
	SEGMENT DATA
_changed:
	DB	0
;    1	
;    2	/*
;    3	 
;    4	 Copyright (c) 2019 Hannes Eberhard
;    5	 
;    6	 Permission is hereby granted, free of charge, to any person obtaining a copy
;    7	 of this software and associated documentation files (the "Software"), to deal
;    8	 in the Software without restriction, including without limitation the rights
;    9	 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
;   10	 copies of the Software, and to permit persons to whom the Software is
;   11	 furnished to do so, subject to the following conditions:
;   12	 
;   13	 The above copyright notice and this permission notice shall be included in all
;   14	 copies or substantial portions of the Software.
;   15	 
;   16	 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;   17	 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;   18	 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;   19	 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;   20	 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;   21	 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;   22	 SOFTWARE.
;   23	 
;   24	 */
;   25	
;   26	#include "symbolic4.h"
;   27	
;   28	bool changed = false;
	SEGMENT CODE
;   29	
;   30	void simplify_literal(expression* source);
;   31	
;   32	void merge_additions_multiplications(expression* source);
;   33	uint8_t numeric_addition(expression** result, expression* a, expression* b, bool persistent);
;   34	uint8_t symbolic_addition(expression** result, expression* a, expression* b, bool persistent);
;   35	void evaluate_addition(expression* source);
;   36	void simplify_addition(expression* source);
;   37	
;   38	uint8_t numeric_multiplication(expression** result, expression* a, expression* b, bool persistent);
;   39	uint8_t symbolic_multiplication(expression** result, expression* a, expression* b, bool persistent);
;   40	void evaluate_multiplication(expression* source);
;   41	uint8_t expand_multiplication(expression* source);
;   42	void simplify_multiplication(expression* source);
;   43	
;   44	uint8_t expand_exponentation_base(expression* source);
;   45	uint8_t expand_exponentation_exponent(expression* source);
;   46	uint8_t numeric_exponentation(expression* source);
;   47	uint8_t symbolic_exponentation(expression* source);
;   48	return_status evaluate_exponentation(expression* source);
;   49	return_status simplify_exponentation(expression* source);
;   50	
;   51	void simplify_literal(expression* source) {
_simplify_literal:
	LD	HL,-10
	CALL	__frameset
;   52	    uintmax_t gcd;
;   53	    if (source->identifier != EXPI_LITERAL) return;
	LD	IY,(IX+6)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_2
;   54	    gcd = euclidean_gcd(source->value.numeric.numerator, source->value.numeric.denominator);
	LD	IY,(IX+6)
	LEA	BC,IY+14
	LD	(IX+-10),BC
	LD	IY,(IX+-10)
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	H,0
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	BC,(IY+0)
	LD	A,(IY+3)
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_euclidean_gcd
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	BC,HL
	LD	(IX+-4),BC
	LD	(IX+-1),E
;   55	    source->value.numeric.numerator /= gcd;
	LD	IY,(IX+6)
	LEA	DE,IY+14
	LD	(IX+-7),DE
	LD	HL,(IY+14)
	LD	E,(IY+17)
	LD	A,(IX+-1)
	CALL	__ldivu
	LD	IY,(IX+-7)
	LD	(IY+0),HL
	LD	(IY+3),E
;   56	    source->value.numeric.denominator /= gcd;
	LD	HL,(IY+4)
	LD	E,(IY+7)
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__ldivu
	LD	(IY+4),HL
	LD	(IY+7),E
;   57	}
L_2:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _simplify_literal ***************************
;Name                         Addr/Register   Size   Type
;_euclidean_gcd                      IMPORT  -----   function
;gcd                                   IX-4      4   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 19 (bytes)
;       Spill Code: 0 (instruction)


;   58	
;   59	void merge_additions_multiplications(expression* source) {
_merge_additions_multiplications:
	LD	HL,-21
	CALL	__frameset
;   60	    
;   61	    uint8_t i, j;
;   62	    expression_identifier identifier;
;   63	    expression* result;
;   64	    
;   65	    identifier = source->identifier;
	LD	IY,(IX+6)
	LD	BC,(IY+3)
	LD	(IX+-8),BC
;   66	    
;   67	    if (identifier != EXPI_ADDITION && identifier != EXPI_MULTIPLICATION) return;
	LD	HL,BC
	LD	BC,5
	OR	A,A
	SBC	HL,BC
	JR	Z,L_14
	LD	BC,7
	LD	HL,(IX+-8)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_29
L_14:
;   68	    
;   69	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_13
L_11:
;   70	        if (source->children[i] == NULL) continue;
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	(IX+-15),HL
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_12
;   71	        if (source->children[i]->identifier == identifier) break; /* source has at least one child with the same identifier -> break to continue the merge process */
	LD	HL,(IX+-15)
	LD	IY,(HL)
	LD	BC,(IX+-8)
	LD	HL,(IY+3)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_15
;   72	        if (i == source->child_count - 1) return; /* all children of source were searched an no one had the same identifier as the source -> expressions cannot be merged -> return */
	LD	A,(IX+-9)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	DEC	BC
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	JR	Z,L_29
;   73	    }
L_12:
	INC	(IX+-1)
L_13:
	LD	IY,(IX+6)
	LD	A,(IY+10)
	LD	(IX+-9),A
	LD	A,(IX+-1)
	CP	A,(IX+-9)
	JR	C,L_11
L_15:
;   74	    
;   75	    result = new_expression(EXPT_OPERATION, identifier, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-8)
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-12),HL
;   76	    
;   77	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_27
L_25:
;   78	        if (source->children[i] == NULL) continue;
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	(IX+-21),HL
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	ADD	HL,BC
	LD	(IX+-5),HL
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_26
;   79	        if (source->children[i]->identifier == identifier) {
	LD	HL,(IX+-5)
	LD	IY,(HL)
	LD	BC,(IX+-8)
	LD	HL,(IY+3)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_23
;   80	            merge_additions_multiplications(source->children[i]);
	LD	HL,(IX+-5)
	LD	BC,(HL)
	PUSH	BC
	CALL	_merge_additions_multiplications
	POP	BC
;   81	            for (j = 0; j < source->children[i]->child_count; j++) {
	LD	(IX+-2),0
	JR	L_21
L_19:
;   82	                append_child(result, copy_expression(source->children[i]->children[j]));
	LD	A,(IX+-2)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	IY,(IX+-18)
	LD	IY,(IY)
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IY+11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-12)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
	INC	(IX+-2)
;   83	            }
L_21:
	LD	BC,(IX+-21)
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	(IX+-18),HL
	LD	IY,(HL)
	LD	A,(IX+-2)
	CP	A,(IY+10)
	JR	C,L_19
	JR	L_26
;   84	        } else {
L_23:
;   85	            append_child(result, copy_expression(source->children[i]));
	LD	HL,(IX+-5)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-12)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;   86	        }
;   87	    }
L_26:
	INC	(IX+-1)
L_27:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_25
;   88	    
;   89	    replace_expression(source, result);
	LD	BC,(IX+-12)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;   90	    
;   91	    changed = true;
	LD	A,1
	LD	(_changed),A
;   92	    
;   93	    return;
;   94	    
;   95	}
L_29:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _merge_additions_multiplications ***************************
;Name                         Addr/Register   Size   Type
;_changed                            STATIC      1   variable
;_replace_expression                 IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;G_5                                  IX-21      3   variable
;G_4                                  IX-18      3   variable
;G_0                                  IX-15      3   variable
;result                               IX-12      3   variable
;G_1                                   IX-9      1   variable
;identifier                            IX-8      3   variable
;G_2                                   IX-5      3   variable
;j                                     IX-2      1   variable
;i                                     IX-1      1   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 30 (bytes)
;       Spill Code: 0 (instruction)


;   96	
;   97	uint8_t numeric_addition(expression** result, expression* a, expression* b, bool persistent) {
_numeric_addition:
	LD	HL,-29
	CALL	__frameset
;   98	    
;   99	    numeric_value a_value;
;  100	    numeric_value b_value;
;  101	    uintmax_t temp_1;
;  102	    uintmax_t temp_2;
;  103	    uintmax_t temp_3;
;  104	    
;  105	    if (a->identifier != EXPI_LITERAL || b->identifier != EXPI_LITERAL) return RETS_UNCHANGED;
	LD	IY,(IX+9)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_31
	LD	IY,(IX+12)
	LD	HL,(IY+3)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_32
L_31:
	LD	A,4
	JR	L_57
L_32:
;  106	    
;  107	    a_value = a->value.numeric;
	LD	IY,(IX+9)
	LEA	HL,IY+14
	LEA	DE,IX+-25
	LD	BC,8
	LDIR	
;  108	    b_value = b->value.numeric;
	LD	IY,(IX+12)
	LEA	HL,IY+14
	LEA	DE,IX+-17
	LD	BC,8
	LDIR	
;  109	    
;  110	    if ((a->sign == 1 && b->sign == 1) || (a->sign == -1 && b->sign == -1)) {
	LD	IY,(IX+9)
	LD	A,(IY+6)
	LD	(IX+-9),A
	CP	A,1
	JR	NZ,L_35
	LD	IY,(IX+12)
	LD	A,(IY+6)
	CP	A,1
	JR	Z,L_52
L_35:
	LD	A,(IX+-9)
	CP	A,-1
	JR	NZ,L_53
	LD	IY,(IX+12)
	LD	A,(IY+6)
	CP	A,-1
	JR	NZ,L_53
L_52:
;  111	        
;  112	        if (multiplication(&temp_1, a_value.numerator, b_value.denominator) == RETS_ERROR) return RETS_UNCHANGED;
	LD	C,(IX+-10)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-13)
	PUSH	BC
	LD	C,(IX+-22)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-25)
	PUSH	BC
	PEA	IX+-4
	CALL	_multiplication
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	NZ,L_38
	LD	A,4
	JR	L_57
L_38:
;  113	        if (multiplication(&temp_2, a_value.denominator, b_value.numerator) == RETS_ERROR) return RETS_UNCHANGED;
	LD	C,(IX+-14)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-17)
	PUSH	BC
	LD	C,(IX+-18)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-21)
	PUSH	BC
	PEA	IX+-8
	CALL	_multiplication
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	NZ,L_40
	LD	A,4
	JR	L_57
L_40:
;  114	        if (addition(&temp_1, temp_1, temp_2) == RETS_ERROR) return RETS_UNCHANGED;
	LD	C,(IX+-5)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-8)
	PUSH	BC
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	PEA	IX+-4
	CALL	_addition
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	NZ,L_42
	LD	A,4
	JR	L_57
L_42:
;  115	        
;  116	        if (multiplication(&temp_2, a_value.denominator, b_value.denominator) == RETS_ERROR) return RETS_UNCHANGED;
	LD	C,(IX+-10)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-13)
	PUSH	BC
	LD	C,(IX+-18)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-21)
	PUSH	BC
	PEA	IX+-8
	CALL	_multiplication
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	NZ,L_43
	LD	A,4
	JR	L_57
L_43:
;  117	        
;  118	        *result = new_literal(a->sign, temp_1, temp_2);
	LD	C,(IX+-5)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-8)
	PUSH	BC
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	LD	IY,(IX+9)
	LD	C,(IY+6)
	LD	B,0
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+6)
	LD	(IY),HL
;  119	        
;  120	    } else {
	JR	L_54
L_53:
;  121	        
;  122	        if (multiplication(&temp_1, a_value.numerator, b_value.denominator) == RETS_ERROR) return RETS_UNCHANGED;
	LD	C,(IX+-10)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-13)
	PUSH	BC
	LD	C,(IX+-22)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-25)
	PUSH	BC
	PEA	IX+-4
	CALL	_multiplication
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	NZ,L_46
	LD	A,4
	JR	L_57
L_46:
;  123	        if (multiplication(&temp_2, a_value.denominator, b_value.numerator) == RETS_ERROR) return RETS_UNCHANGED;
	LD	C,(IX+-14)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-17)
	PUSH	BC
	LD	C,(IX+-18)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-21)
	PUSH	BC
	PEA	IX+-8
	CALL	_multiplication
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	NZ,L_48
	LD	A,4
	JR	L_57
L_48:
;  124	        if (multiplication(&temp_3, a_value.denominator, b_value.denominator) == RETS_ERROR) return RETS_UNCHANGED;
	LD	C,(IX+-10)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-13)
	PUSH	BC
	LD	C,(IX+-18)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-21)
	PUSH	BC
	PEA	IX+-29
	CALL	_multiplication
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	NZ,L_51
	LD	A,4
	JR	L_57
L_51:
;  125	        
;  126	        if (temp_1 > temp_2) {
	LD	HL,(IX+-8)
	LD	E,(IX+-5)
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__lcmpu
	JR	NC,L_50
;  127	            *result = new_literal(a->sign, temp_1 - temp_2, temp_3);
	LD	C,(IX+-26)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-29)
	PUSH	BC
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	LD	BC,(IX+-8)
	LD	A,(IX+-5)
	CALL	__lsub
	LD	C,E
	LD	B,0
	PUSH	BC
	PUSH	HL
	LD	IY,(IX+9)
	LD	C,(IY+6)
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+6)
	LD	(IY),HL
;  128	        } else {
	JR	L_54
L_50:
;  129	            *result = new_literal(b->sign, temp_2 - temp_1, temp_3);
	LD	C,(IX+-26)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-29)
	PUSH	BC
	LD	HL,(IX+-8)
	LD	E,(IX+-5)
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__lsub
	LD	C,E
	LD	B,0
	PUSH	BC
	PUSH	HL
	LD	IY,(IX+12)
	LD	C,(IY+6)
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+6)
	LD	(IY),HL
;  130	        }
;  131	        
;  132	    }
L_54:
;  133	    
;  134	    simplify_literal(*result);
	LD	HL,(IX+6)
	LD	BC,(HL)
	PUSH	BC
	CALL	_simplify_literal
	POP	BC
;  135	    
;  136	    if (!persistent) {
	LD	A,(IX+15)
	OR	A,A
	JR	NZ,L_56
;  137	        free_expression(a, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  138	        free_expression(b, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  139	    }
L_56:
;  140	    
;  141	    changed = true;
	LD	A,1
	LD	(_changed),A
;  142	    
;  143	    return RETS_CHANGED;
	LD	A,3
;  144	    
;  145	}
L_57:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _numeric_addition ***************************
;Name                         Addr/Register   Size   Type
;_changed                            STATIC      1   variable
;_free_expression                    IMPORT  -----   function
;_simplify_literal                   IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_addition                           IMPORT  -----   function
;_multiplication                     IMPORT  -----   function
;temp_3                               IX-29      4   variable
;a_value                              IX-25      8   variable
;b_value                              IX-17      8   variable
;G_7                                   IX-9      1   variable
;temp_2                                IX-8      4   variable
;temp_1                                IX-4      4   variable
;persistent                           IX+15      1   parameter
;b                                    IX+12      3   parameter
;a                                     IX+9      3   parameter
;result                                IX+6      3   parameter


; Stack Frame Size: 47 (bytes)
;       Spill Code: 0 (instruction)


;  146	
;  147	uint8_t symbolic_addition(expression** result, expression* a, expression* b, bool persistent) {
_symbolic_addition:
	LD	HL,-21
	CALL	__frameset
;  148	    
;  149	    expression* a_temp;
;  150	    expression* b_temp;
;  151	    expression* a_factor;
;  152	    expression* b_factor;
;  153	    expression* temp;
;  154	    
;  155	    if (a->identifier == EXPI_MULTIPLICATION && a->children[0]->identifier == EXPI_LITERAL) {
	LD	IY,(IX+9)
	LD	HL,(IY+3)
	LD	BC,7
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_60
	LD	IY,(IX+9)
	LD	BC,(IY+11)
	LD	(IX+-15),BC
	LD	HL,BC
	LD	IY,(HL)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_60
;  156	        a_factor = copy_expression(a->children[0]);
	LD	HL,(IX+-15)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-9),HL
;  157	        a_temp = copy_expression(a);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-3),HL
;  158	        remove_child_at_index(a_temp, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_remove_child_at_index
	POP	BC
	POP	BC
;  159	        simplify(a_temp, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  160	    } else {
	JR	L_64
L_60:
;  161	        a_temp = copy_expression(a);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-3),HL
;  162	        a_factor = new_literal(1, 1, 1);
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-9),HL
;  163	    }
L_64:
;  164	    
;  165	    if (b->identifier == EXPI_MULTIPLICATION && b->children[0]->identifier == EXPI_LITERAL) {
	LD	IY,(IX+12)
	LD	HL,(IY+3)
	LD	BC,7
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_63
	LD	IY,(IX+12)
	LD	BC,(IY+11)
	LD	(IX+-18),BC
	LD	HL,BC
	LD	IY,(HL)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_63
;  166	        b_factor = copy_expression(b->children[0]);
	LD	HL,(IX+-18)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-12),HL
;  167	        b_temp = copy_expression(b);
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-6),HL
;  168	        remove_child_at_index(b_temp, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_remove_child_at_index
	POP	BC
	POP	BC
;  169	        simplify(b_temp, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  170	    } else {
	JR	L_67
L_63:
;  171	        b_temp = copy_expression(b);
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-6),HL
;  172	        b_factor = new_literal(1, 1, 1);
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-12),HL
;  173	    }
L_67:
;  174	    
;  175	    if (expressions_are_identical(a_temp, b_temp, true)) {
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-6)
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_expressions_are_identical
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_66
;  176	        numeric_addition(&temp, a_factor, b_factor, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-12)
	PUSH	BC
	LD	BC,(IX+-9)
	PUSH	BC
	PEA	IX+-21
	CALL	_numeric_addition
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  177	        *result = new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
;  178	                                 temp,
;  179	                                 a_temp);
	LD	BC,(IX+-3)
	PUSH	BC
	LD	BC,(IX+-21)
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+6)
;  180	        free_expression(b_temp, false);
	LD	BC,0
	PUSH	BC
	LD	(IY),HL
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  181	        changed = true;
	LD	A,1
	LD	(_changed),A
;  182	        return RETS_CHANGED;
	LD	A,3
	JR	L_68
;  183	    } else {
L_66:
;  184	        free_expression(a_temp, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  185	        free_expression(b_temp, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  186	        free_expression(a_factor, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-9)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  187	        free_expression(b_factor, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-12)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  188	        return RETS_UNCHANGED;
	LD	A,4
;  189	    }
;  190	    
;  191	}
L_68:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _symbolic_addition ***************************
;Name                         Addr/Register   Size   Type
;_changed                            STATIC      1   variable
;_free_expression                    IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;_numeric_addition                   IMPORT  -----   function
;_expressions_are_identical          IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_simplify                           IMPORT  -----   function
;_remove_child_at_index              IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;temp                                 IX-21      3   variable
;G_9                                  IX-18      3   variable
;G_8                                  IX-15      3   variable
;b_factor                             IX-12      3   variable
;a_factor                              IX-9      3   variable
;b_temp                                IX-6      3   variable
;a_temp                                IX-3      3   variable
;persistent                           IX+15      1   parameter
;b                                    IX+12      3   parameter
;a                                     IX+9      3   parameter
;result                                IX+6      3   parameter


; Stack Frame Size: 39 (bytes)
;       Spill Code: 0 (instruction)


;  192	
;  193	void evaluate_addition(expression* source) {
_evaluate_addition:
	LD	HL,-29
	CALL	__frameset
;  194	    
;  195	    uint8_t i, j;
;  196	    expression* temp_result;
;  197	    expression* result = new_expression(EXPT_OPERATION, EXPI_ADDITION, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-23),HL
;  198	    
;  199	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-7),0
	JR	L_88
L_86:
;  200	        
;  201	        if (source->children[i] == NULL) continue;
	LD	A,(IX+-7)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	(IX+-14),HL
	LD	(IX+-17),HL
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	ADD	HL,BC
	LD	(IX+-20),HL
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_87
;  202	        
;  203	        if (source->children[i]->identifier == EXPI_LITERAL && literal_to_double(source->children[i]) == 0) {
	LD	HL,(IX+-20)
	LD	IY,(HL)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_85
	LD	HL,(IX+-20)
	LD	BC,(HL)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	BC,0
	XOR	A,A
	CALL	__fcmp
	JR	NZ,L_85
;  204	            free_expression(source->children[i], false);
	PUSH	BC
	LD	BC,(IX+-14)
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  205	            source->children[i] = NULL;
	LD	BC,(IX+-14)
	LD	(IX+-17),BC
	LD	BC,(IX+-14)
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	BC,0
	LD	(HL),BC
;  206	        }
L_85:
;  207	        
;  208	        for (j = i + 1; j < source->child_count; j++) {
	LD	A,(IX+-7)
	INC	A
	LD	(IX+-8),A
	JR	L_84
L_82:
;  209	            
;  210	            if (source->children[i] == NULL) continue;
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-11),BC
	LD	BC,(IX+-17)
	LD	(IX+-6),BC
	LD	HL,(IX+-11)
	ADD	HL,BC
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_83
;  211	            if (source->children[j] == NULL) continue;
	LD	A,(IX+-8)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	(IX+-3),HL
	LD	BC,(IX+-11)
	ADD	HL,BC
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_83
;  212	            
;  213	            if (numeric_addition(&temp_result, source->children[i], source->children[j], true) == RETS_CHANGED) {
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-3)
	LD	HL,(IX+-11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+-6)
	LD	HL,(IX+-11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	PEA	IX+-26
	CALL	_numeric_addition
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,3
	SBC	HL,BC
	JR	NZ,L_81
;  214	                replace_expression(source->children[i], temp_result);
	LD	BC,(IX+-6)
	LD	(IX+-17),BC
	LD	BC,(IX+-26)
	PUSH	BC
	LD	BC,(IX+-6)
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  215	                free_expression(source->children[j], false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-3)
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  216	                source->children[j] = NULL;
	LD	BC,(IX+-3)
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	BC,0
	LD	(HL),BC
;  217	                continue;
	JR	L_83
;  218	            }
L_81:
;  219	            
;  220	            if (symbolic_addition(&temp_result, source->children[i], source->children[j], true) == RETS_CHANGED) {
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-29),BC
	LD	BC,(IX+-6)
	LD	(IX+-17),BC
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-3)
	LD	HL,(IX+-29)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+-6)
	LD	HL,(IX+-29)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	PEA	IX+-26
	CALL	_symbolic_addition
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,3
	SBC	HL,BC
	JR	NZ,L_83
;  221	                replace_expression(source->children[i], temp_result);
	LD	BC,(IX+-6)
	LD	(IX+-17),BC
	LD	BC,(IX+-26)
	PUSH	BC
	LD	BC,(IX+-6)
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  222	                free_expression(source->children[j], false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-3)
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  223	                source->children[j] = NULL;
	LD	BC,(IX+-3)
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	BC,0
	LD	(HL),BC
;  224	                continue;
;  225	            }
;  226	            
;  227	        }
L_83:
	INC	(IX+-8)
L_84:
	LD	A,(IX+-8)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_82
;  228	        
;  229	    }
L_87:
	INC	(IX+-7)
L_88:
	LD	A,(IX+-7)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_86
;  230	    
;  231	    remove_null_children(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_remove_null_children
	POP	BC
;  232	    
;  233	    switch (source->child_count) {
	LD	IY,(IX+6)
	LD	A,(IY+10)
	UEXT	HL
	LD	L,A
	CALL	__case8
L__44:
	DW	2
	DB	0
	DW24	L_90	

	DB	1
	DW24	L_91	

	DW24	L_92	

;  234	        case 0: result = new_literal(1, 0, 1); break;
L_90:
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-23),HL
	JR	L_93
;  235	        case 1: result = copy_expression(source->children[0]); break;
L_91:
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-23),HL
	JR	L_93
;  236	        default: result = copy_expression(source); break;
L_92:
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-23),HL
;  237	    }
L_93:
;  238	    
;  239	    replace_expression(source, result);
	LD	BC,(IX+-23)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  240	    
;  241	    return;
;  242	    
;  243	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _evaluate_addition ***************************
;Name                         Addr/Register   Size   Type
;_copy_expression                    IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_remove_null_children               IMPORT  -----   function
;_symbolic_addition                  IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;_numeric_addition                   IMPORT  -----   function
;_free_expression                    IMPORT  -----   function
;_literal_to_double                  IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;temp_result                          IX-26      3   variable
;result                               IX-23      3   variable
;G_10                                 IX-20      3   variable
;G_14                                 IX-17      3   variable
;G_12                                 IX-14      3   variable
;G_15                                 IX-11      3   variable
;j                                     IX-8      1   variable
;i                                     IX-7      1   variable
;G_18                                  IX-6      3   variable
;G_17                                  IX-3      3   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 38 (bytes)
;       Spill Code: 0 (instruction)


;  244	
;  245	void simplify_addition(expression* source) {
_simplify_addition:
	CALL	__frameset0
;  246	    
;  247	    merge_additions_multiplications(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_merge_additions_multiplications
	POP	BC
;  248	    evaluate_addition(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_evaluate_addition
	POP	BC
;  249	    if (source->child_count > 0) order_children(source);
	LD	IY,(IX+6)
	XOR	A,A
	CP	A,(IY+10)
	JR	NC,L_96
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_order_children
	POP	BC
L_96:
;  250	    
;  251	    return;
;  252	    
;  253	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _simplify_addition ***************************
;Name                         Addr/Register   Size   Type
;_order_children                     IMPORT  -----   function
;_evaluate_addition                  IMPORT  -----   function
;_merge_additions_multiplications      IMPORT  -----   function
;source                                IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  254	
;  255	void simplify_subtraction(expression* source) {
_simplify_subtraction:
	CALL	__frameset0
;  256	    replace_expression(source, new_expression(EXPT_OPERATION, EXPI_ADDITION, 2,
;  257	                                              copy_expression(source->children[0]),
;  258	                                              new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
;  259	                                                             new_literal(-1, 1, 1),
;  260	                                                             copy_expression(source->children[1]))));
	LD	IY,(IX+6)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,16777215
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  261	    changed = true;
	LD	A,1
	LD	(_changed),A
;  262	    return;
;  263	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _simplify_subtraction ***************************
;Name                         Addr/Register   Size   Type
;_changed                            STATIC      1   variable
;_new_literal                        IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;source                                IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  264	
;  265	uint8_t numeric_multiplication(expression** result, expression* a, expression* b, bool persistent) {
_numeric_multiplication:
	LD	HL,-24
	CALL	__frameset
;  266	    
;  267	    numeric_value a_value;
;  268	    numeric_value b_value;
;  269	    uintmax_t temp_1;
;  270	    uintmax_t temp_2;
;  271	    
;  272	    if (a->identifier != EXPI_LITERAL || b->identifier != EXPI_LITERAL) return RETS_UNCHANGED;
	LD	IY,(IX+9)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_100
	LD	IY,(IX+12)
	LD	HL,(IY+3)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_101
L_100:
	LD	A,4
	JR	L_108
L_101:
;  273	    
;  274	    a_value = a->value.numeric;
	LD	IY,(IX+9)
	LEA	HL,IY+14
	LEA	DE,IX+-16
	LD	BC,8
	LDIR	
;  275	    b_value = b->value.numeric;
	LD	IY,(IX+12)
	LEA	HL,IY+14
	LEA	DE,IX+-24
	LD	BC,8
	LDIR	
;  276	    
;  277	    if (multiplication(&temp_1, a_value.numerator, b_value.numerator) == RETS_ERROR) return RETS_UNCHANGED;
	LD	C,(IX+-21)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-24)
	PUSH	BC
	LD	C,(IX+-13)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-16)
	PUSH	BC
	PEA	IX+-4
	CALL	_multiplication
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	NZ,L_104
	LD	A,4
	JR	L_108
L_104:
;  278	    if (multiplication(&temp_2, b_value.denominator, a_value.denominator) == RETS_ERROR) return RETS_UNCHANGED;
	LD	C,(IX+-9)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-12)
	PUSH	BC
	LD	C,(IX+-17)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-20)
	PUSH	BC
	PEA	IX+-8
	CALL	_multiplication
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	NZ,L_105
	LD	A,4
	JR	L_108
L_105:
;  279	    
;  280	    *result = new_literal(a->sign * b->sign, temp_1, temp_2);
	LD	C,(IX+-5)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-8)
	PUSH	BC
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	LD	IY,(IX+9)
	LD	B,(IY+6)
	LD	IY,(IX+12)
	LD	C,(IY+6)
	MLT	BC
	LD	B,0
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+6)
	LD	(IY),HL
;  281	    simplify_literal(*result);
	LD	HL,(IX+6)
	LD	BC,(HL)
	PUSH	BC
	CALL	_simplify_literal
	POP	BC
;  282	    
;  283	    if (!persistent) {
	LD	A,(IX+15)
	OR	A,A
	JR	NZ,L_107
;  284	        free_expression(a, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  285	        free_expression(b, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  286	    }
L_107:
;  287	    
;  288	    changed = true;
	LD	A,1
	LD	(_changed),A
;  289	    
;  290	    return RETS_CHANGED;
	LD	A,3
;  291	    
;  292	}
L_108:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _numeric_multiplication ***************************
;Name                         Addr/Register   Size   Type
;_changed                            STATIC      1   variable
;_free_expression                    IMPORT  -----   function
;_simplify_literal                   IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_multiplication                     IMPORT  -----   function
;b_value                              IX-24      8   variable
;a_value                              IX-16      8   variable
;temp_2                                IX-8      4   variable
;temp_1                                IX-4      4   variable
;persistent                           IX+15      1   parameter
;b                                    IX+12      3   parameter
;a                                     IX+9      3   parameter
;result                                IX+6      3   parameter


; Stack Frame Size: 42 (bytes)
;       Spill Code: 0 (instruction)


;  293	
;  294	uint8_t symbolic_multiplication(expression** result, expression* a, expression* b, bool persistent) {
_symbolic_multiplication:
	LD	HL,-21
	CALL	__frameset
;  295	    
;  296	    expression* a_temp;
;  297	    expression* b_temp;
;  298	    expression* a_exponent;
;  299	    expression* b_exponent;
;  300	    expression* temp;
;  301	    
;  302	    if (a->identifier == EXPI_EXPONENTATION && a->children[1]->identifier == EXPI_LITERAL) {
	LD	IY,(IX+9)
	LD	HL,(IY+3)
	LD	BC,9
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_111
	LD	IY,(IX+9)
	LD	BC,(IY+11)
	LD	(IX+-15),BC
	LD	IY,(IX+-15)
	LEA	HL,IY+3
	LD	IY,(HL)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_111
;  303	        a_temp = copy_expression(a->children[0]);
	LD	HL,(IX+-15)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-3),HL
;  304	        a_exponent = copy_expression(a->children[1]);
	LD	IY,(IX+9)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-9),HL
;  305	    } else {
	JR	L_115
L_111:
;  306	        a_temp = copy_expression(a);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-3),HL
;  307	        a_exponent = new_literal(1, 1, 1);
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-9),HL
;  308	    }
L_115:
;  309	    
;  310	    if (b->identifier == EXPI_EXPONENTATION && b->children[1]->identifier == EXPI_LITERAL) {
	LD	IY,(IX+12)
	LD	HL,(IY+3)
	LD	BC,9
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_114
	LD	IY,(IX+12)
	LD	BC,(IY+11)
	LD	(IX+-18),BC
	LD	IY,(IX+-18)
	LEA	HL,IY+3
	LD	IY,(HL)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_114
;  311	        b_temp = copy_expression(b->children[0]);
	LD	HL,(IX+-18)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-6),HL
;  312	        b_exponent = copy_expression(b->children[1]);
	LD	IY,(IX+12)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-12),HL
;  313	    } else {
	JR	L_118
L_114:
;  314	        b_temp = copy_expression(b);
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-6),HL
;  315	        b_exponent = new_literal(1, 1, 1);
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-12),HL
;  316	    }
L_118:
;  317	    
;  318	    if (expressions_are_identical(a_temp, b_temp, true)) {
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-6)
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_expressions_are_identical
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_117
;  319	        numeric_addition(&temp, a_exponent, b_exponent, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-12)
	PUSH	BC
	LD	BC,(IX+-9)
	PUSH	BC
	PEA	IX+-21
	CALL	_numeric_addition
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  320	        *result = new_expression(EXPT_OPERATION, EXPI_EXPONENTATION, 2,
;  321	                                 a_temp,
;  322	                                 temp);
	LD	BC,(IX+-21)
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,9
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+6)
;  323	        free_expression(b_temp, false);
	LD	BC,0
	PUSH	BC
	LD	(IY),HL
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  324	        changed = true;
	LD	A,1
	LD	(_changed),A
;  325	        return RETS_CHANGED;
	LD	A,3
	JR	L_119
;  326	    } else {
L_117:
;  327	        free_expression(a_temp, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  328	        free_expression(b_temp, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  329	        free_expression(a_exponent, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-9)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  330	        free_expression(b_exponent, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-12)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  331	        return RETS_UNCHANGED;
	LD	A,4
;  332	    }
;  333	    
;  334	}
L_119:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _symbolic_multiplication ***************************
;Name                         Addr/Register   Size   Type
;_changed                            STATIC      1   variable
;_free_expression                    IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;_numeric_addition                   IMPORT  -----   function
;_expressions_are_identical          IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;temp                                 IX-21      3   variable
;G_28                                 IX-18      3   variable
;G_27                                 IX-15      3   variable
;b_exponent                           IX-12      3   variable
;a_exponent                            IX-9      3   variable
;b_temp                                IX-6      3   variable
;a_temp                                IX-3      3   variable
;persistent                           IX+15      1   parameter
;b                                    IX+12      3   parameter
;a                                     IX+9      3   parameter
;result                                IX+6      3   parameter


; Stack Frame Size: 39 (bytes)
;       Spill Code: 0 (instruction)


;  335	
;  336	void evaluate_multiplication(expression* source) {
_evaluate_multiplication:
	LD	HL,-32
	CALL	__frameset
;  337	    
;  338	    uint8_t i, j;
;  339	    expression* temp_result;
;  340	    expression* result;
;  341	    
;  342	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-7),0
	JR	L_142
L_140:
;  343	        
;  344	        if (source->children[i] == NULL) continue;
	LD	A,(IX+-7)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	(IX+-11),HL
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	ADD	HL,BC
	LD	(IX+-20),HL
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_141
;  345	        
;  346	        if (source->children[i]->identifier == EXPI_LITERAL && literal_to_double(source->children[i]) == 0) {
	LD	HL,(IX+-20)
	LD	IY,(HL)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_127
	LD	HL,(IX+-20)
	LD	BC,(HL)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	BC,0
	XOR	A,A
	CALL	__fcmp
	JR	NZ,L_127
;  347	            replace_expression(source, new_literal(1, 0, 1));
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  348	            return;
	JR	L_148
;  349	        }
L_127:
;  350	        
;  351	        if (source->children[i]->identifier == EXPI_LITERAL && literal_to_double(source->children[i]) == 1) {
	LD	BC,(IX+-11)
	LD	(IX+-17),BC
	LD	BC,(IX+-11)
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	(IX+-29),HL
	LD	IY,(HL)
	LD	HL,(IY+3)
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	NZ,L_139
	LD	HL,(IX+-29)
	LD	BC,(HL)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	BC,8388608
	LD	A,63
	CALL	__fcmp
	JR	NZ,L_139
;  352	            free_expression(source->children[i], false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-11)
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  353	            source->children[i] = NULL;
	LD	BC,(IX+-11)
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	BC,0
	LD	(HL),BC
;  354	            continue;
	JR	L_141
;  355	        }
L_139:
;  356	        
;  357	        for (j = i + 1; j < source->child_count; j++) {
	LD	A,(IX+-7)
	INC	A
	LD	(IX+-8),A
	JR	L_138
L_136:
;  358	            
;  359	            if (source->children[i] == NULL) continue;
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-14),BC
	LD	BC,(IX+-17)
	LD	(IX+-6),BC
	LD	HL,(IX+-14)
	ADD	HL,BC
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_137
;  360	            if (source->children[j] == NULL) continue;
	LD	A,(IX+-8)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	(IX+-3),HL
	LD	BC,(IX+-14)
	ADD	HL,BC
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_137
;  361	            
;  362	            if (numeric_multiplication(&temp_result, source->children[i], source->children[j], true) == RETS_CHANGED) {
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-3)
	LD	HL,(IX+-14)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+-6)
	LD	HL,(IX+-14)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	PEA	IX+-23
	CALL	_numeric_multiplication
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,3
	SBC	HL,BC
	JR	NZ,L_135
;  363	                replace_expression(source->children[i], temp_result);
	LD	BC,(IX+-6)
	LD	(IX+-17),BC
	LD	BC,(IX+-23)
	PUSH	BC
	LD	BC,(IX+-6)
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  364	                free_expression(source->children[j], false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-3)
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  365	                source->children[j] = NULL;
	LD	BC,(IX+-3)
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	BC,0
	LD	(HL),BC
;  366	                continue;
	JR	L_137
;  367	            }
L_135:
;  368	            
;  369	            if (symbolic_multiplication(&temp_result, source->children[i], source->children[j], true) == RETS_CHANGED) {
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-32),BC
	LD	BC,(IX+-6)
	LD	(IX+-17),BC
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-3)
	LD	HL,(IX+-32)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+-6)
	LD	HL,(IX+-32)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	PEA	IX+-23
	CALL	_symbolic_multiplication
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,3
	SBC	HL,BC
	JR	NZ,L_137
;  370	                replace_expression(source->children[i], temp_result);
	LD	BC,(IX+-6)
	LD	(IX+-17),BC
	LD	BC,(IX+-23)
	PUSH	BC
	LD	BC,(IX+-6)
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  371	                free_expression(source->children[j], false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-3)
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  372	                source->children[j] = NULL;
	LD	BC,(IX+-3)
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	BC,0
	LD	(HL),BC
;  373	                continue;
;  374	            }
;  375	            
;  376	        }
L_137:
	INC	(IX+-8)
L_138:
	LD	A,(IX+-8)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_136
;  377	        
;  378	    }
L_141:
	INC	(IX+-7)
L_142:
	LD	A,(IX+-7)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_140
;  379	    
;  380	    remove_null_children(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_remove_null_children
	POP	BC
;  381	    
;  382	    switch (source->child_count) {
	LD	IY,(IX+6)
	LD	A,(IY+10)
	UEXT	HL
	LD	L,A
	CALL	__case8
L__72:
	DW	2
	DB	0
	DW24	L_144	

	DB	1
	DW24	L_145	

	DW24	L_146	

;  383	        case 0: result = new_literal(1, 1, 1); break;
L_144:
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-26),HL
	JR	L_147
;  384	        case 1: result = copy_expression(source->children[0]); break;
L_145:
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-26),HL
	JR	L_147
;  385	        default: result = copy_expression(source); break;
L_146:
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-26),HL
;  386	    }
L_147:
;  387	    
;  388	    replace_expression(source, result);
	LD	BC,(IX+-26)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  389	    
;  390	    return;
;  391	    
;  392	}
L_148:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _evaluate_multiplication ***************************
;Name                         Addr/Register   Size   Type
;_copy_expression                    IMPORT  -----   function
;_remove_null_children               IMPORT  -----   function
;_symbolic_multiplication            IMPORT  -----   function
;_numeric_multiplication             IMPORT  -----   function
;_free_expression                    IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;_literal_to_double                  IMPORT  -----   function
;G_32                                 IX-29      3   variable
;result                               IX-26      3   variable
;temp_result                          IX-23      3   variable
;G_29                                 IX-20      3   variable
;G_35                                 IX-17      3   variable
;G_36                                 IX-14      3   variable
;G_31                                 IX-11      3   variable
;j                                     IX-8      1   variable
;i                                     IX-7      1   variable
;G_39                                  IX-6      3   variable
;G_38                                  IX-3      3   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 41 (bytes)
;       Spill Code: 0 (instruction)


;  393	
;  394	void expand_multiplication_addition_factors(expression* source) {
_expand_multiplication_addition_factors:
	LD	HL,-13
	CALL	__frameset
;  395	    
;  396	    uint8_t i, j, k, l;
;  397	    expression* result = new_expression(EXPT_OPERATION, EXPI_ADDITION, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-7),HL
;  398	    
;  399	    for (i = 0; i < source->child_count - 1; i++) {
	LD	(IX+-1),0
	JR	L_164
L_162:
;  400	        for (j = 0; j < source->children[i]->child_count; j++) {
	LD	(IX+-2),0
	JR	L_161
L_159:
;  401	            for (k = i + 1; k < source->child_count; k++) {
	LD	A,(IX+-1)
	INC	A
	LD	(IX+-3),A
	JR	L_158
L_156:
;  402	                for (l = 0; l < source->children[k]->child_count; l++) {
	LD	(IX+-4),0
	JR	L_155
L_153:
;  403	                    append_child(result, new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
;  404	                                                        copy_expression(source->children[i]->children[j]),
;  405	                                                        copy_expression(source->children[k]->children[l])));
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	IY,(IX+-10)
	LD	IY,(IY)
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IY+11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IX+-13)
	ADD	HL,BC
	LD	IY,(HL)
	LD	A,(IX+-2)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IY+11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
	INC	(IX+-4)
;  406	                }
L_155:
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-13),BC
	LD	A,(IX+-3)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IX+-13)
	ADD	HL,BC
	LD	(IX+-10),HL
	LD	IY,(HL)
	LD	A,(IX+-4)
	CP	A,(IY+10)
	JR	C,L_153
	INC	(IX+-3)
;  407	            }
L_158:
	LD	A,(IX+-3)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_156
	INC	(IX+-2)
;  408	        }
L_161:
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	IY,(HL)
	LD	A,(IX+-2)
	CP	A,(IY+10)
	JR	C,L_159
	INC	(IX+-1)
;  409	    }
L_164:
	LD	IY,(IX+6)
	LD	A,(IY+10)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	DEC	BC
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	OR	A,A
	SBC	HL,BC
	JP	M,L_162
;  410	    
;  411	    simplify(result, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  412	    replace_expression(source, result);
	LD	BC,(IX+-7)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  413	    
;  414	    return;
;  415	    
;  416	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _expand_multiplication_addition_factors ***************************
;Name                         Addr/Register   Size   Type
;_replace_expression                 IMPORT  -----   function
;_simplify                           IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;G_49                                 IX-13      3   variable
;G_48                                 IX-10      3   variable
;result                                IX-7      3   variable
;l                                     IX-4      1   variable
;k                                     IX-3      1   variable
;j                                     IX-2      1   variable
;i                                     IX-1      1   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 22 (bytes)
;       Spill Code: 0 (instruction)


;  417	
;  418	uint8_t expand_multiplication(expression* source) {
_expand_multiplication:
	LD	HL,-18
	CALL	__frameset
;  419	    
;  420	    uint8_t i;
;  421	    expression* single_factors;
;  422	    expression* addition_factors;
;  423	    expression* result;
;  424	    
;  425	    if (source->child_count == 0) return RETS_UNCHANGED;
	LD	IY,(IX+6)
	LD	A,(IY+10)
	LD	(IX+-9),A
	OR	A,A
	JR	NZ,L_177
	LD	A,4
	JR	L_196
L_177:
;  426	    
;  427	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_176
L_174:
;  428	        if (source->children[i] == NULL) continue;
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	(IX+-18),HL
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_175
;  429	        if (source->children[i]->identifier == EXPI_ADDITION) break; /* source has at least one child being an additon -> break to continue the expanding process */
	LD	HL,(IX+-18)
	LD	IY,(HL)
	LD	HL,(IY+3)
	LD	BC,5
	OR	A,A
	SBC	HL,BC
	JR	Z,L_178
;  430	        if (i == source->child_count - 1) return RETS_UNCHANGED; /* all children of source were searched an no one had an addion as its child -> multiplication cannot be expanded -> return */
	LD	A,(IX+-8)
	LD	(IX+-9),A
	LD	A,(IX+-8)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	DEC	BC
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	JR	NZ,L_175
	LD	A,4
	JR	L_196
;  431	    }
L_175:
	INC	(IX+-1)
L_176:
	LD	A,(IX+-9)
	LD	(IX+-8),A
	LD	A,(IX+-1)
	CP	A,(IX+-8)
	JR	C,L_174
L_178:
;  432	    
;  433	    single_factors = new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-12),HL
;  434	    addition_factors = new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-4),HL
;  435	    result = new_expression(EXPT_OPERATION, EXPI_ADDITION, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-15),HL
;  436	    
;  437	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_186
L_184:
;  438	        
;  439	        if (source->children[i] == NULL) continue;
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	(IX+-7),HL
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_185
;  440	        
;  441	        if (source->children[i]->identifier == EXPI_ADDITION) {
	LD	HL,(IX+-7)
	LD	IY,(HL)
	LD	HL,(IY+3)
	LD	BC,5
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_182
;  442	            append_child(addition_factors, copy_expression(source->children[i]));
	LD	HL,(IX+-7)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  443	        } else {
	JR	L_185
L_182:
;  444	            append_child(single_factors, copy_expression(source->children[i]));
	LD	HL,(IX+-7)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-12)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  445	        }
;  446	        
;  447	    }
L_185:
	INC	(IX+-1)
L_186:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_184
;  448	    
;  449	    if (addition_factors->child_count > 1) {
	LD	A,1
	LD	IY,(IX+-4)
	CP	A,(IY+10)
	JR	NC,L_188
;  450	        expand_multiplication_addition_factors(addition_factors);
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_expand_multiplication_addition_factors
	POP	BC
;  451	    } else {
	JR	L_194
L_188:
;  452	        replace_expression(addition_factors, copy_expression(addition_factors->children[0]));
	LD	IY,(IX+-4)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  453	    }
L_194:
;  454	    
;  455	    for (i = 0; i < addition_factors->child_count; i++) {
	LD	(IX+-1),0
	JR	L_193
L_191:
;  456	        append_child(result, new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
;  457	                                            copy_expression(single_factors),
;  458	                                            copy_expression(addition_factors->children[i])));
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+-4)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-12)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-15)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
	INC	(IX+-1)
;  459	    }
L_193:
	LD	A,(IX+-1)
	LD	IY,(IX+-4)
	CP	A,(IY+10)
	JR	C,L_191
;  460	    
;  461	    simplify(result, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-15)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  462	    replace_expression(source, result);
	LD	BC,(IX+-15)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  463	    
;  464	    free_expression(single_factors, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-12)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  465	    free_expression(addition_factors, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  466	    
;  467	    changed = true;
	LD	A,1
	LD	(_changed),A
;  468	    
;  469	    return RETS_CHANGED;
	LD	A,3
;  470	    
;  471	}
L_196:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _expand_multiplication ***************************
;Name                         Addr/Register   Size   Type
;_changed                            STATIC      1   variable
;_free_expression                    IMPORT  -----   function
;_simplify                           IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;G_50                                 IX-18      3   variable
;result                               IX-15      3   variable
;single_factors                       IX-12      3   variable
;G_52                                  IX-9      1   variable
;G_51                                  IX-8      1   variable
;G_53                                  IX-7      3   variable
;addition_factors                      IX-4      3   variable
;i                                     IX-1      1   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 27 (bytes)
;       Spill Code: 0 (instruction)


;  472	
;  473	void simplify_multiplication(expression* source) {
_simplify_multiplication:
	CALL	__frameset0
;  474	    
;  475	    merge_additions_multiplications(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_merge_additions_multiplications
	POP	BC
;  476	    if (expand_multiplication(source) == RETS_CHANGED) return;
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_expand_multiplication
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,3
	SBC	HL,BC
	JR	Z,L_199
;  477	    evaluate_multiplication(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_evaluate_multiplication
	POP	BC
;  478	    order_children(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_order_children
	POP	BC
;  479	    
;  480	    return;
;  481	    
;  482	}
L_199:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _simplify_multiplication ***************************
;Name                         Addr/Register   Size   Type
;_order_children                     IMPORT  -----   function
;_evaluate_multiplication            IMPORT  -----   function
;_expand_multiplication              IMPORT  -----   function
;_merge_additions_multiplications      IMPORT  -----   function
;source                                IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  483	
;  484	void simplify_division(expression* source) {
_simplify_division:
	CALL	__frameset0
;  485	    
;  486	    replace_expression(source, new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
;  487	                                              copy_expression(source->children[0]),
;  488	                                              new_expression(EXPT_OPERATION, EXPI_EXPONENTATION, 2,
;  489	                                                             copy_expression(source->children[1]),
;  490	                                                             new_literal(-1, 1, 1))));
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,16777215
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,9
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  491	    
;  492	    changed = true;
	LD	A,1
	LD	(_changed),A
;  493	    
;  494	    return;
;  495	    
;  496	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _simplify_division ***************************
;Name                         Addr/Register   Size   Type
;_changed                            STATIC      1   variable
;_copy_expression                    IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;source                                IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  497	
;  498	void merge_nested_exponentations(expression* source) {
_merge_nested_exponentations:
	LD	HL,-6
	CALL	__frameset
;  499	    
;  500	    expression* result;
;  501	    
;  502	    if (!expression_is_constant(source)) return;
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_expression_is_constant
	POP	BC
	OR	A,A
	JR	Z,L_205
;  503	    
;  504	    if (source->children[0]->identifier == EXPI_EXPONENTATION) {
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-3),BC
	LD	HL,BC
	LD	IY,(HL)
	LD	HL,(IY+3)
	LD	BC,9
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_205
;  505	        result = new_expression(EXPT_OPERATION, EXPI_EXPONENTATION, 2,
;  506	                                copy_expression(source->children[0]->children[0]),
;  507	                                new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
;  508	                                               copy_expression(source->children[0]->children[1]),
;  509	                                               copy_expression(source->children[1])));
	LD	IY,(IX+-3)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	HL,(IX+-3)
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	HL,(IX+-3)
	LD	IY,(HL)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,9
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-6),HL
;  510	        replace_expression(source, result);
	LD	BC,HL
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  511	        simplify(source->children[1], true);
	LD	BC,1
	PUSH	BC
	LD	IY,(IX+6)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  512	        changed = true;
	LD	A,1
	LD	(_changed),A
;  513	    }
;  514	    
;  515	    return;
;  516	    
;  517	}
L_205:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _merge_nested_exponentations ***************************
;Name                         Addr/Register   Size   Type
;_changed                            STATIC      1   variable
;_simplify                           IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;_expression_is_constant             IMPORT  -----   function
;result                                IX-6      3   variable
;G_56                                  IX-3      3   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


;  518	
;  519	uint8_t expand_exponentation_base(expression* source) {
_expand_exponentation_base:
	LD	HL,-35
	CALL	__frameset
;  520	    
;  521	    uint8_t i;
;  522	    expression* base = source->children[0];
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-3),BC
	LD	HL,BC
	LD	BC,(HL)
	LD	(IX+-13),BC
;  523	    expression* exponent = source->children[1];
	LD	IY,(IX+-3)
	LEA	HL,IY+3
	LD	BC,(HL)
	LD	(IX+-7),BC
;  524	    expression* result;
;  525	    uintmax_t* coefficients;
;  526	    
;  527	    if (base->identifier == EXPI_ADDITION && base->child_count == 2 && exponent->identifier == EXPI_LITERAL && exponent->value.numeric.numerator <= 10 && exponent->value.numeric.denominator == 1 && exponent->sign == 1) {
	LD	IY,(IX+-13)
	LD	BC,(IY+3)
	LD	(IX+-25),BC
	LD	HL,BC
	LD	BC,5
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_223
	LD	IY,(IX+-13)
	LD	A,(IY+10)
	CP	A,2
	JR	NZ,L_223
	LD	IY,(IX+-7)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_223
	LD	IY,(IX+-7)
	LD	BC,(IY+14)
	LD	A,(IY+17)
	LD	HL,10
	LD	E,0
	CALL	__lcmpu
	JR	C,L_223
	LD	IY,(IX+-7)
	LD	HL,(IY+18)
	LD	E,(IY+21)
	LD	BC,1
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_223
	LD	IY,(IX+-7)
	LD	A,(IY+6)
	CP	A,1
	JR	NZ,L_223
;  528	        
;  529	        result = new_expression(EXPT_OPERATION, EXPI_ADDITION, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	(IX+-35),A
	CALL	_new_expression
	LD	A,(IX+-35)
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-10),HL
;  530	        coefficients = binomial_coefficients(exponent->value.numeric.numerator);
	LD	IY,(IX+-7)
	LEA	BC,IY+14
	LD	(IX+-22),BC
	LD	C,(IY+14)
	LD	B,0
	PUSH	BC
	LD	(IX+-35),A
	CALL	_binomial_coefficients
	LD	A,(IX+-35)
	POP	BC
	LD	(IX+-28),HL
;  531	        
;  532	        for (i = 0; i <= exponent->value.numeric.numerator; i++) {
	LD	(IX+-4),0
	JR	L_214
L_212:
;  533	            append_child(result, new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 3,
;  534	                                                new_literal(1, coefficients[i], 1),
;  535	                                                new_expression(EXPT_OPERATION, EXPI_EXPONENTATION, 2,
;  536	                                                               copy_expression(base->children[0]),
;  537	                                                               new_literal(1, exponent->value.numeric.numerator - i, 1)),
;  538	                                                new_expression(EXPT_OPERATION, EXPI_EXPONENTATION, 2,
;  539	                                                               copy_expression(base->children[1]),
;  540	                                                               new_literal(1, i, 1))));
	LD	BC,(IX+-16)
	LD	(IX+-22),BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	UEXT	HL
	LD	C,H
	LD	B,0
	LD	L,(IX+-4)
	PUSH	BC
	PUSH	HL
	LD	BC,1
	PUSH	BC
	LD	(IX+-35),A
	CALL	_new_literal
	LD	A,(IX+-35)
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+-13)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	LD	(IX+-35),A
	CALL	_copy_expression
	LD	A,(IX+-35)
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,9
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	(IX+-35),A
	CALL	_new_expression
	LD	A,(IX+-35)
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	UEXT	HL
	LD	L,(IX+-4)
	LD	BC,HL
	LD	A,H
	LD	IY,(IX+-16)
	LD	HL,(IY+0)
	LD	E,(IY+3)
	CALL	__lsub
	LD	(IX+-31),HL	; spill
	LD	HL,1
	LD	(IX+-34),HL	; spill
	LD	HL,(IX+-31)	; unspill
	LD	C,E
	LD	B,0
	PUSH	BC
	PUSH	HL
	LD	HL,(IX+-34)	; unspill
	PUSH	HL
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+-13)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,9
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(IX+-28)
	ADD	HL,BC
	LD	IY,HL
	LD	A,(IY+3)
	LD	H,0
	LD	L,A
	PUSH	HL
	LD	BC,(IY)
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	(IX+-35),A
	CALL	_new_literal
	LD	A,(IX+-35)
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,3
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	(IX+-35),A
	CALL	_new_expression
	LD	A,(IX+-35)
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-10)
	PUSH	BC
	LD	(IX+-35),A
	CALL	_append_child
	LD	A,(IX+-35)
	POP	BC
	POP	BC
	INC	(IX+-4)
;  541	        }
L_214:
	LD	BC,(IX+-22)
	LD	(IX+-16),BC
	UEXT	HL
	LD	L,(IX+-4)
	LD	BC,HL
	LD	A,H
	LD	IY,(IX+-16)
	LD	HL,(IY+0)
	LD	E,(IY+3)
	CALL	__lcmpu
	JR	NC,L_212
;  542	        
;  543	        smart_free(coefficients);
	LD	BC,(IX+-28)
	PUSH	BC
	CALL	_smart_free
	POP	BC
;  544	        replace_expression(source, result);
	LD	BC,(IX+-10)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  545	        
;  546	        changed = true;
	LD	A,1
	LD	(_changed),A
;  547	        
;  548	        return RETS_CHANGED;
	LD	A,3
	JR	L_225
;  549	        
;  550	    } else if (base->identifier == EXPI_MULTIPLICATION) {
L_223:
	LD	BC,7
	LD	HL,(IX+-25)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_224
;  551	        
;  552	        result = new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-10),HL
;  553	        
;  554	        for (i = 0; i < source->children[0]->child_count; i++) {
	LD	(IX+-4),0
	JR	L_219
L_217:
;  555	            append_child(result, new_expression(EXPT_OPERATION, EXPI_EXPONENTATION, 2,
;  556	                                                copy_expression(source->children[0]->children[i]),
;  557	                                                copy_expression(source->children[1])));
	LD	IY,(IX+-19)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	IY,(IX+-19)
	LD	IY,(IY)
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IY+11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,9
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-10)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
	INC	(IX+-4)
;  558	        }
L_219:
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-19),BC
	LD	HL,BC
	LD	IY,(HL)
	LD	A,(IX+-4)
	CP	A,(IY+10)
	JR	C,L_217
;  559	        
;  560	        replace_expression(source, result);
	LD	BC,(IX+-10)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  561	        
;  562	        changed = true;
	LD	A,1
	LD	(_changed),A
;  563	        
;  564	        return RETS_CHANGED;
	LD	A,3
	JR	L_225
;  565	        
;  566	    }
L_224:
;  567	    
;  568	    return RETS_UNCHANGED;
	LD	A,4
;  569	    
;  570	}
L_225:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _expand_exponentation_base ***************************
;Name                         Addr/Register   Size   Type
;_changed                            STATIC      1   variable
;_replace_expression                 IMPORT  -----   function
;_smart_free                         IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;_binomial_coefficients              IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;coefficients                         IX-28      3   variable
;G_61                                 IX-25      3   variable
;G_60                                 IX-22      3   variable
;G_62                                 IX-19      3   variable
;G_59                                 IX-16      3   variable
;base                                 IX-13      3   variable
;result                               IX-10      3   variable
;exponent                              IX-7      3   variable
;i                                     IX-4      1   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 44 (bytes)
;       Spill Code: 0 (instruction)


;  571	
;  572	uint8_t expand_exponentation_exponent(expression* source) {
_expand_exponentation_exponent:
	LD	HL,-10
	CALL	__frameset
;  573	    
;  574	    uint8_t i;
;  575	    expression* result;
;  576	    
;  577	    if (source->children[1]->identifier != EXPI_ADDITION) return RETS_UNCHANGED;
	LD	IY,(IX+6)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	IY,(HL)
	LD	HL,(IY+3)
	LD	BC,5
	OR	A,A
	SBC	HL,BC
	JR	Z,L_227
	LD	A,4
	JR	L_233
L_227:
;  578	    
;  579	    result = new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-10),HL
;  580	    
;  581	    for (i = 0; i < source->children[1]->child_count; i++) {
	LD	(IX+-1),0
	JR	L_231
L_229:
;  582	        append_child(result, new_expression(EXPT_OPERATION, EXPI_EXPONENTATION, 2,
;  583	                                            copy_expression(source->children[0]),
;  584	                                            copy_expression(source->children[1]->children[i])));
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	IY,(IX+-7)
	LD	IY,(IY)
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IY+11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	HL,(IX+-4)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,9
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-10)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
	INC	(IX+-1)
;  585	    }
L_231:
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-4),BC
	LD	IY,(IX+-4)
	LEA	BC,IY+3
	LD	(IX+-7),BC
	LD	HL,BC
	LD	IY,(HL)
	LD	A,(IX+-1)
	CP	A,(IY+10)
	JR	C,L_229
;  586	    
;  587	    replace_expression(source, result);
	LD	BC,(IX+-10)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  588	    
;  589	    changed = true;
	LD	A,1
	LD	(_changed),A
;  590	    
;  591	    return RETS_CHANGED;
	LD	A,3
;  592	    
;  593	}
L_233:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _expand_exponentation_exponent ***************************
;Name                         Addr/Register   Size   Type
;_changed                            STATIC      1   variable
;_replace_expression                 IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;result                               IX-10      3   variable
;G_63                                  IX-7      3   variable
;G_64                                  IX-4      3   variable
;i                                     IX-1      1   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 19 (bytes)
;       Spill Code: 0 (instruction)


;  594	
;  595	uint8_t remove_exponentation_identities(expression* source) {
_remove_exponentation_identities:
	LD	HL,-9
	CALL	__frameset
;  596	    
;  597	    expression* base = source->children[0];
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-3),BC
	LD	HL,BC
	LD	BC,(HL)
	LD	(IX+-9),BC
;  598	    expression* exponent = source->children[1];
	LD	IY,(IX+-3)
	LEA	HL,IY+3
	LD	BC,(HL)
	LD	(IX+-6),BC
;  599	    
;  600	    if (exponent->identifier == EXPI_LITERAL && literal_to_double(exponent) == 0) {
	LD	IY,(IX+-6)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_238
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	BC,0
	XOR	A,A
	CALL	__fcmp
	JR	NZ,L_238
;  601	        replace_expression(source, new_literal(1, 1, 1));
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  602	        return RETS_CHANGED;
	LD	A,3
	JR	L_252
;  603	    }
L_238:
;  604	    
;  605	    if (exponent->identifier == EXPI_LITERAL && literal_to_double(exponent) == 1) {
	LD	IY,(IX+-6)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_241
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	BC,8388608
	LD	A,63
	CALL	__fcmp
	JR	NZ,L_241
;  606	        replace_expression(source, copy_expression(base));
	LD	BC,(IX+-9)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  607	        return RETS_CHANGED;
	LD	A,3
	JR	L_252
;  608	    }
L_241:
;  609	    
;  610	    if (base->identifier == EXPI_LITERAL && literal_to_double(base) == 0) {
	LD	IY,(IX+-9)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_244
	LD	BC,(IX+-9)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	BC,0
	XOR	A,A
	CALL	__fcmp
	JR	NZ,L_244
;  611	        replace_expression(source, new_literal(1, 0, 1));
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  612	        return RETS_CHANGED;
	LD	A,3
	JR	L_252
;  613	    }
L_244:
;  614	    
;  615	    if (base->identifier == EXPI_LITERAL && literal_to_double(base) == 1) {
	LD	IY,(IX+-9)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_250
	LD	BC,(IX+-9)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	BC,8388608
	LD	A,63
	CALL	__fcmp
	JR	NZ,L_250
;  616	        replace_expression(source, new_literal(1, 1, 1));
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  617	        return RETS_CHANGED;
	LD	A,3
	JR	L_252
;  618	    }
L_250:
;  619	    
;  620	    if (base->identifier == EXPI_LITERAL && literal_to_double(base) == -1 && exponent->identifier == EXPI_LITERAL && exponent->value.numeric.numerator % 2 == 1 && exponent->value.numeric.denominator == 1) {
	LD	IY,(IX+-9)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_251
	LD	BC,(IX+-9)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	BC,8388608
	LD	A,191
	CALL	__fcmp
	JR	NZ,L_251
	LD	IY,(IX+-6)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_251
	LD	IY,(IX+-6)
	LD	A,(IY+14)
	AND	A,1
	UEXT	HL
	LD	L,A
	XOR	A,A
	LD	E,H
	CALL	__lcmpu
	JR	NZ,L_251
	LD	IY,(IX+-6)
	LD	HL,(IY+18)
	LD	E,(IY+21)
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_251
;  621	        replace_expression(source, new_literal(-1, 1, 1));
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,16777215
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  622	        return RETS_CHANGED;
	LD	A,3
	JR	L_252
;  623	    }
L_251:
;  624	    
;  625	    return RETS_UNCHANGED;
	LD	A,4
;  626	    
;  627	}
L_252:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _remove_exponentation_identities ***************************
;Name                         Addr/Register   Size   Type
;_copy_expression                    IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;_literal_to_double                  IMPORT  -----   function
;base                                  IX-9      3   variable
;exponent                              IX-6      3   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: 0 (instruction)


;  628	
;  629	uint8_t numeric_exponentation(expression* source) {
_numeric_exponentation:
	LD	HL,-35
	CALL	__frameset
;  630	    
;  631	    expression* base = source->children[0];
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-3),BC
	LD	HL,BC
	LD	BC,(HL)
	LD	(IX+-9),BC
;  632	    expression* exponent = source->children[1];
	LD	IY,(IX+-3)
	LEA	HL,IY+3
	LD	BC,(HL)
	LD	(IX+-6),BC
;  633	    expression* base_result;
;  634	    expression* factor;
;  635	    expression* result;
;  636	    
;  637	    uintmax_t temp;
;  638	    
;  639	    if (base->identifier != EXPI_LITERAL || exponent->identifier != EXPI_LITERAL) return RETS_UNCHANGED;
	LD	IY,(IX+-9)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_254
	LD	IY,(IX+-6)
	LD	HL,(IY+3)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_255
L_254:
	LD	A,4
	JR	L_277
L_255:
;  640	    
;  641	    base_result = new_literal(1, 0, 1);
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-12),HL
;  642	    factor = new_literal(1, 1, 1);
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-18),HL
;  643	    
;  644	    simplify_literal(base);
	LD	BC,(IX+-9)
	PUSH	BC
	CALL	_simplify_literal
	POP	BC
;  645	    simplify_literal(exponent);
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_simplify_literal
	POP	BC
;  646	    
;  647	    if (literal_to_double(base) == -1 && exponent->value.numeric.denominator == 2) {
	LD	BC,(IX+-9)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	BC,8388608
	LD	A,191
	CALL	__fcmp
	JR	NZ,L_262
	LD	IY,(IX+-6)
	LD	HL,(IY+18)
	LD	E,(IY+21)
	LD	BC,2
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_262
;  648	        
;  649	        if ((exponent->value.numeric.numerator - 1) % 4 == 0) {
	LD	IY,(IX+-6)
	LD	HL,(IY+14)
	LD	E,(IY+17)
	LD	BC,1
	XOR	A,A
	CALL	__lsub
	LD	BC,HL
	LD	A,C
	AND	A,3
	UEXT	HL
	LD	L,A
	LD	E,H
	CALL	__lcmpzero
	JR	NZ,L_258
;  650	            replace_expression(source, new_symbol(EXPI_SYMBOL, "i"));
	LD	BC,L__128
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  651	        } else {
	JR	L_259
L_258:
;  652	            replace_expression(source, new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
;  653	                                                      new_literal(-1, 1, 1),
;  654	                                                      new_symbol(EXPI_SYMBOL, "i")));
	LD	BC,L__129
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,16777215
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  655	        }
L_259:
;  656	        
;  657	        return RETS_CHANGED;
	LD	A,3
	JR	L_277
;  658	        
;  659	    }
L_262:
;  660	    
;  661	    if (exponent->sign == -1) {
	LD	IY,(IX+-6)
	LD	A,(IY+6)
	CP	A,-1
	JR	NZ,L_264
;  662	        temp = base->value.numeric.numerator;
	LD	IY,(IX+-9)
	LD	BC,(IY+14)
	LD	A,(IY+17)
	LD	(IX+-22),BC
	LD	(IX+-19),A
;  663	        base->value.numeric.numerator = base->value.numeric.denominator;
	LD	BC,(IY+18)
	LD	A,(IY+21)
	LD	(IY+14),BC
	LD	(IY+17),A
;  664	        base->value.numeric.denominator = temp;
	LD	BC,(IX+-22)
	LD	A,(IX+-19)
	LD	(IY+18),BC
	LD	(IY+21),A
;  665	        exponent->sign = 1;
	LD	IY,(IX+-6)
	LD	(IY+6),1
;  666	    }
L_264:
;  667	    
;  668	    if (int_power(&base_result->value.numeric.numerator, base->value.numeric.numerator, exponent->value.numeric.numerator) == RETS_ERROR) return RETS_UNCHANGED;
	LD	IY,(IX+-6)
	LD	BC,(IY+14)
	LD	A,(IY+17)
	LD	H,0
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	IY,(IX+-9)
	LD	BC,(IY+14)
	LD	A,(IY+17)
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	IY,(IX+-12)
	PEA	IY+14
	CALL	_int_power
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	NZ,L_266
	LD	A,4
	JR	L_277
L_266:
;  669	    if (int_power(&base_result->value.numeric.denominator, base->value.numeric.denominator, exponent->value.numeric.numerator) == RETS_ERROR) return RETS_UNCHANGED;
	LD	IY,(IX+-6)
	LD	BC,(IY+14)
	LD	A,(IY+17)
	LD	H,0
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	IY,(IX+-9)
	LD	BC,(IY+18)
	LD	A,(IY+21)
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	IY,(IX+-12)
	PEA	IY+18
	CALL	_int_power
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	NZ,L_267
	LD	A,4
	JR	L_277
L_267:
;  670	    
;  671	    int_root(&factor->value.numeric.numerator, &base_result->value.numeric.numerator, base_result->value.numeric.numerator, exponent->value.numeric.denominator);
	LD	IY,(IX+-12)
	LEA	BC,IY+14
	LD	(IX+-25),BC
	LD	IY,(IX+-6)
	LD	BC,(IY+18)
	LD	A,(IY+21)
	LD	H,0
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	IY,(IX+-25)
	LD	BC,(IY+0)
	LD	A,(IY+3)
	LD	L,A
	PUSH	HL
	PUSH	BC
	PEA	IY+0
	LD	IY,(IX+-18)
	PEA	IY+14
	CALL	_int_root
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  672	    int_root(&factor->value.numeric.denominator, &base_result->value.numeric.denominator, base_result->value.numeric.denominator, exponent->value.numeric.denominator);
	LD	IY,(IX+-12)
	LEA	BC,IY+14
	LD	(IX+-28),BC
	LD	IY,(IX+-6)
	LD	BC,(IY+18)
	LD	A,(IY+21)
	LD	H,0
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	IY,(IX+-28)
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	L,A
	PUSH	HL
	PUSH	BC
	PEA	IY+4
	LD	IY,(IX+-18)
	PEA	IY+18
	CALL	_int_root
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  673	    
;  674	    result = new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-15),HL
;  675	    
;  676	    if (base->sign == -1 && exponent->value.numeric.numerator % 2 == 1) {
	LD	IY,(IX+-9)
	LD	A,(IY+6)
	CP	A,-1
	JR	NZ,L_275
	LD	IY,(IX+-6)
	LD	A,(IY+14)
	AND	A,1
	UEXT	HL
	LD	L,A
	XOR	A,A
	LD	E,H
	LD	BC,1
	CALL	__lcmpu
	JR	NZ,L_275
;  677	        append_child(result, new_expression(EXPT_OPERATION, EXPI_EXPONENTATION, 2,
;  678	                                            new_literal(-1, 1, 1),
;  679	                                            copy_expression(exponent)));
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,16777215
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,9
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-15)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  680	//        symbolic_exponentation(result->children[result->child_count - 1]);
;  681	    }
L_275:
;  682	    
;  683	    if (literal_to_double(factor) == literal_to_double(base_result)) {
	LD	BC,(IX+-18)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	BC,(IX+-12)
	PUSH	BC
	LD	(IX+-34),HL
	LD	(IX+-35),E
	CALL	_literal_to_double
	POP	BC
	LD	A,E
	LD	BC,HL
	LD	HL,(IX+-34)
	LD	E,(IX+-35)
	CALL	__fcmp
	JR	NZ,L_274
;  684	        append_child(result, new_expression(EXPT_OPERATION, EXPI_EXPONENTATION, 2,
;  685	                                            base_result,
;  686	                                            new_literal(1, exponent->value.numeric.numerator + exponent->value.numeric.denominator, exponent->value.numeric.denominator)));
	LD	IY,(IX+-6)
	LEA	BC,IY+14
	LD	(IX+-31),BC
	LD	IY,(IX+-31)
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	H,0
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	HL,(IY+4)
	LD	E,(IY+7)
	LD	BC,(IY+0)
	LD	A,(IY+3)
	CALL	__ladd
	LD	C,E
	LD	B,0
	PUSH	BC
	PUSH	HL
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-12)
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,9
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-15)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  687	        
;  688	        remove_exponentation_identities(result->children[result->child_count - 1]);
	LD	IY,(IX+-15)
	LD	A,(IY+10)
	LD	BC,(IY+11)
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_remove_exponentation_identities
	POP	BC
;  689	    } else {
	JR	L_276
L_274:
;  690	        if (literal_to_double(factor) != 1) append_child(result, factor);
	LD	BC,(IX+-18)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	BC,8388608
	LD	A,63
	CALL	__fcmp
	JR	Z,L_272
	LD	BC,(IX+-18)
	PUSH	BC
	LD	BC,(IX+-15)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
L_272:
;  691	        if (literal_to_double(base_result) != 1) append_child(result, new_expression(EXPT_OPERATION, EXPI_EXPONENTATION, 2,
	LD	BC,(IX+-12)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	BC,8388608
	LD	A,63
	CALL	__fcmp
	JR	Z,L_276
;  692	                                                                                     base_result,
;  693	                                                                                     copy_expression(exponent)));
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-12)
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,9
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-15)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  694	    }
L_276:
;  695	    
;  696	    simplify_multiplication(result);
	LD	BC,(IX+-15)
	PUSH	BC
	CALL	_simplify_multiplication
	POP	BC
;  697	    
;  698	    replace_expression(source, result);
	LD	BC,(IX+-15)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  699	    
;  700	    return RETS_CHANGED;
	LD	A,3
;  701	    
;  702	}
L_277:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _numeric_exponentation ***************************
;Name                         Addr/Register   Size   Type
;_simplify_multiplication            IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;_int_root                           IMPORT  -----   function
;_int_power                          IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;_new_symbol                         IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;_literal_to_double                  IMPORT  -----   function
;_simplify_literal                   IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;temp                                 IX-22      4   variable
;factor                               IX-18      3   variable
;result                               IX-15      3   variable
;base_result                          IX-12      3   variable
;base                                  IX-9      3   variable
;exponent                              IX-6      3   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 44 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__128:
	DB	"i"
	DB	0
L__129:
	DB	"i"
	DB	0
	SEGMENT CODE
;  703	
;  704	uint8_t symbolic_exponentation(expression* source) {
_symbolic_exponentation:
	LD	HL,-9
	CALL	__frameset
;  705	    
;  706	    expression* base = source->children[0];
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-3),BC
	LD	HL,BC
	LD	BC,(HL)
	LD	(IX+-9),BC
;  707	    expression* exponent = source->children[1];
	LD	IY,(IX+-3)
	LEA	HL,IY+3
	LD	BC,(HL)
	LD	(IX+-6),BC
;  708	    
;  709	    if (expressions_are_identical(base, new_symbol(EXPI_SYMBOL, "i"), false) && exponent->identifier == EXPI_LITERAL) {
	LD	BC,0
	PUSH	BC
	LD	BC,L__139
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-9)
	PUSH	BC
	CALL	_expressions_are_identical
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_280
	LD	IY,(IX+-6)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_280
;  710	        replace_expression(source, new_expression(EXPT_OPERATION, EXPI_EXPONENTATION, 2,
;  711	                                                  new_literal(-1, 1, 1),
;  712	                                                  new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
;  713	                                                                 new_literal(1, 1, 2),
;  714	                                                                 copy_expression(exponent))));
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,16777215
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,9
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  715	        simplify(source, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  716	        return RETS_CHANGED;
	LD	A,3
	JR	L_281
;  717	    }
L_280:
;  718	    
;  719	    return RETS_UNCHANGED;
	LD	A,4
;  720	    
;  721	}
L_281:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _symbolic_exponentation ***************************
;Name                         Addr/Register   Size   Type
;_simplify                           IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;_new_symbol                         IMPORT  -----   function
;_expressions_are_identical          IMPORT  -----   function
;base                                  IX-9      3   variable
;exponent                              IX-6      3   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__139:
	DB	"i"
	DB	0
	SEGMENT CODE
;  722	
;  723	return_status exponentation_remove_logarithms(expression* source) {
_exponentation_remove_logarithms:
	LD	HL,-19
	CALL	__frameset
;  724	    
;  725	    uint8_t i;
;  726	    expression* base = source->children[0];
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-3),BC
	LD	HL,BC
	LD	BC,(HL)
	LD	(IX+-10),BC
;  727	    expression* exponent = source->children[1];
	LD	IY,(IX+-3)
	LEA	HL,IY+3
	LD	BC,(HL)
	LD	(IX+-6),BC
;  728	    expression* temp;
;  729	    
;  730	    if (exponent->identifier == EXPI_LN && expressions_are_identical(base, new_symbol(EXPI_SYMBOL, "e"), false)) {
	LD	IY,(IX+-6)
	LD	HL,(IY+3)
	LD	BC,11
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_287
	LD	BC,0
	PUSH	BC
	LD	BC,L__144
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-10)
	PUSH	BC
	CALL	_expressions_are_identical
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_287
;  731	        replace_expression(source, copy_expression(source->children[1]->children[0]));
	LD	IY,(IX+6)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	IY,(HL)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  732	        return RETS_CHANGED;
	LD	HL,3
	JR	L_303
;  733	    }
L_287:
;  734	    
;  735	    if (exponent->identifier == EXPI_LOG && exponent->child_count == 1 && expressions_are_identical(base, new_literal(1, 10, 1), false)) {
	LD	IY,(IX+-6)
	LD	HL,(IY+3)
	LD	BC,12
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_291
	LD	IY,(IX+-6)
	LD	A,(IY+10)
	CP	A,1
	JR	NZ,L_291
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,10
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-10)
	PUSH	BC
	CALL	_expressions_are_identical
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_291
;  736	        replace_expression(source, copy_expression(source->children[1]->children[0]));
	LD	IY,(IX+6)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	IY,(HL)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  737	        return RETS_CHANGED;
	LD	HL,3
	JR	L_303
;  738	    }
L_291:
;  739	    
;  740	    if (exponent->identifier == EXPI_LOG && exponent->child_count == 2 && expressions_are_identical(base, exponent->children[1], true)) {
	LD	IY,(IX+-6)
	LD	HL,(IY+3)
	LD	BC,12
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_301
	LD	IY,(IX+-6)
	LD	A,(IY+10)
	CP	A,2
	JR	NZ,L_301
	LD	BC,1
	PUSH	BC
	LD	IY,(IX+-6)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+-10)
	PUSH	BC
	CALL	_expressions_are_identical
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_301
;  741	        replace_expression(source, copy_expression(source->children[1]->children[0]));
	LD	IY,(IX+6)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	IY,(HL)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  742	        return RETS_CHANGED;
	LD	HL,3
	JR	L_303
;  743	    }
L_301:
;  744	    
;  745	    if (exponent->identifier == EXPI_MULTIPLICATION) {
	LD	IY,(IX+-6)
	LD	HL,(IY+3)
	LD	BC,7
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_302
;  746	        for (i = 0; i < exponent->child_count; i++) {
	LD	(IX+-7),0
	JR	L_299
L_297:
;  747	            if (exponent->children[i]->identifier == EXPI_LN || exponent->children[i]->identifier == EXPI_LOG) {
	LD	A,(IX+-7)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+-6)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	(IX+-16),HL
	LD	IY,(HL)
	LD	BC,(IY+3)
	LD	(IX+-19),BC
	LD	HL,BC
	OR	A,A
	LD	BC,11
	SBC	HL,BC
	JR	Z,L_296
	LD	BC,12
	LD	HL,(IX+-19)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_298
L_296:
;  748	                
;  749	                temp = new_expression(EXPT_OPERATION, EXPI_EXPONENTATION, 2,
;  750	                                      copy_expression(base),
;  751	                                      copy_expression(exponent->children[i]));
	LD	HL,(IX+-16)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-10)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,9
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-13),HL
;  752	                
;  753	                if (exponentation_remove_logarithms(temp) == RETS_CHANGED) {
	LD	BC,HL
	PUSH	BC
	CALL	_exponentation_remove_logarithms
	POP	BC
	LD	BC,3
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_295
;  754	                    remove_child_at_index(exponent, i);
	LD	C,(IX+-7)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_remove_child_at_index
	POP	BC
	POP	BC
;  755	                    replace_expression(source, new_expression(EXPT_OPERATION, EXPI_EXPONENTATION, 2,
;  756	                                                              temp,
;  757	                                                              copy_expression(exponent)));
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-13)
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,9
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  758	                    simplify(source, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  759	                    
;  760	                    return RETS_CHANGED;
	LD	HL,3
	JR	L_303
;  761	                    
;  762	                }
L_295:
;  763	                
;  764	                smart_free(temp);
	LD	BC,(IX+-13)
	PUSH	BC
	CALL	_smart_free
	POP	BC
;  765	                
;  766	            }
;  767	        }
L_298:
	INC	(IX+-7)
L_299:
	LD	A,(IX+-7)
	LD	IY,(IX+-6)
	CP	A,(IY+10)
	JR	C,L_297
;  768	    }
L_302:
;  769	    
;  770	    return RETS_UNCHANGED;
	LD	HL,4
;  771	    
;  772	}
L_303:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _exponentation_remove_logarithms ***************************
;Name                         Addr/Register   Size   Type
;_smart_free                         IMPORT  -----   function
;_simplify                           IMPORT  -----   function
;_remove_child_at_index              IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;_new_symbol                         IMPORT  -----   function
;_expressions_are_identical          IMPORT  -----   function
;G_76                                 IX-19      3   variable
;G_77                                 IX-16      3   variable
;temp                                 IX-13      3   variable
;base                                 IX-10      3   variable
;i                                     IX-7      1   variable
;exponent                              IX-6      3   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 28 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__144:
	DB	"e"
	DB	0
	SEGMENT CODE
;  773	
;  774	return_status evaluate_exponentation(expression* source) {
_evaluate_exponentation:
	LD	HL,-3
	CALL	__frameset
;  775	    
;  776	    if (source->children[0]->identifier == EXPI_LITERAL && source->children[0]->value.numeric.numerator == 0 && source->children[1]->sign == -1) {
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-3),BC
	LD	HL,BC
	LD	IY,(HL)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_308
	LD	HL,(IX+-3)
	LD	IY,(HL)
	LD	HL,(IY+14)
	LD	E,(IY+17)
	CALL	__lcmpzero
	JR	NZ,L_308
	LD	IY,(IX+-3)
	LD	IY,(IY+3)
	LD	A,(IY+6)
	CP	A,-1
	JR	NZ,L_308
;  777	        return set_error(ERRD_MATH, ERRI_UNDEFINED_VALUE, "");
	LD	BC,L__161
	PUSH	BC
	LD	BC,10
	PUSH	BC
	LD	BC,3
	PUSH	BC
	CALL	_set_error
	POP	BC
	POP	BC
	POP	BC
	UEXT	HL
	LD	L,A
	JR	L_312
;  778	    }
L_308:
;  779	    
;  780	    if (remove_exponentation_identities(source) == RETS_CHANGED) return RETS_SUCCESS;
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_remove_exponentation_identities
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,3
	SBC	HL,BC
	JR	NZ,L_310
	LD	HL,2
	JR	L_312
L_310:
;  781	    if (numeric_exponentation(source) == RETS_CHANGED) return RETS_SUCCESS;
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_numeric_exponentation
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,3
	SBC	HL,BC
	JR	NZ,L_311
	LD	HL,2
	JR	L_312
L_311:
;  782	    symbolic_exponentation(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_symbolic_exponentation
	POP	BC
;  783	    
;  784	    return RETS_SUCCESS;
	LD	HL,2
;  785	    
;  786	}
L_312:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _evaluate_exponentation ***************************
;Name                         Addr/Register   Size   Type
;_symbolic_exponentation             IMPORT  -----   function
;_numeric_exponentation              IMPORT  -----   function
;_set_error                          IMPORT  -----   function
;G_78                                  IX-3      3   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__161:
	DB	0
	SEGMENT CODE
;  787	
;  788	return_status simplify_exponentation(expression* source) {
_simplify_exponentation:
	CALL	__frameset0
;  789	    
;  790	    merge_nested_exponentations(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_merge_nested_exponentations
	POP	BC
;  791	    if (expand_exponentation_base(source) == RETS_CHANGED) return RETS_SUCCESS;
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_expand_exponentation_base
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,3
	SBC	HL,BC
	JR	NZ,L_315
	LD	HL,2
	JR	L_321
L_315:
;  792	    if (expand_exponentation_exponent(source) == RETS_CHANGED) return RETS_SUCCESS;
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_expand_exponentation_exponent
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,3
	SBC	HL,BC
	JR	NZ,L_317
	LD	HL,2
	JR	L_321
L_317:
;  793	    if (exponentation_remove_logarithms(source) == RETS_CHANGED) return RETS_SUCCESS;
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_exponentation_remove_logarithms
	POP	BC
	LD	BC,3
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_319
	LD	HL,2
	JR	L_321
L_319:
;  794	    ERROR_CHECK(evaluate_exponentation(source));
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_evaluate_exponentation
	POP	BC
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_320
	LD	HL,1
	JR	L_321
L_320:
;  795	    
;  796	    return RETS_SUCCESS;
	LD	HL,2
;  797	    
;  798	}
L_321:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _simplify_exponentation ***************************
;Name                         Addr/Register   Size   Type
;_evaluate_exponentation             IMPORT  -----   function
;_expand_exponentation_exponent      IMPORT  -----   function
;_expand_exponentation_base          IMPORT  -----   function
;source                                IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  799	
;  800	void simplify_abs(expression* source) {
_simplify_abs:
	LD	HL,-12
	CALL	__frameset
;  801	    
;  802	    expression* result;
;  803	    
;  804	    if (source->child_count == 1) {
	LD	IY,(IX+6)
	LD	A,(IY+10)
	CP	A,1
	JR	NZ,L_329
;  805	        if (source->children[0]->identifier == EXPI_LITERAL || symbol_is_constant(source->children[0])) {
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-12),BC
	LD	HL,BC
	LD	IY,(HL)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	Z,L_323
	LD	HL,(IX+-12)
	LD	BC,(HL)
	PUSH	BC
	CALL	_symbol_is_constant
	POP	BC
	OR	A,A
	JR	Z,L_330
L_323:
;  806	            result = copy_expression(source->children[0]);
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-3),HL
;  807	            result->sign = 1;
	LD	IY,(IX+-3)
	LD	(IY+6),1
;  808	            replace_expression(source, result);
	LD	BC,HL
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  809	            changed = true;
	LD	A,1
	LD	(_changed),A
;  810	        }
;  811	    } else if (source->children[0]->identifier == EXPI_MULTIPLICATION && source->children[0]->child_count == 2 && source->children[0]->children[0]->sign == -1 && symbol_is_constant(source->children[0]->children[1])) {
	JR	L_330
L_329:
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-6),BC
	LD	HL,BC
	LD	IY,(HL)
	LD	HL,(IY+3)
	LD	BC,7
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_330
	LD	HL,(IX+-6)
	LD	IY,(HL)
	LD	A,(IY+10)
	CP	A,2
	JR	NZ,L_330
	LD	HL,(IX+-6)
	LD	IY,(HL)
	LD	BC,(IY+11)
	LD	(IX+-9),BC
	LD	HL,BC
	LD	IY,(HL)
	LD	A,(IY+6)
	CP	A,-1
	JR	NZ,L_330
	LD	IY,(IX+-9)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_symbol_is_constant
	POP	BC
	OR	A,A
	JR	Z,L_330
;  812	        result = copy_expression(source->children[0]);
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-3),HL
;  813	        result->children[0]->sign = 1;
	LD	IY,(IX+-3)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	(IY+6),1
;  814	        replace_expression(source, result);
	LD	BC,(IX+-3)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  815	        changed = true;
	LD	A,1
	LD	(_changed),A
;  816	    }
L_330:
;  817	    
;  818	    return;
;  819	    
;  820	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _simplify_abs ***************************
;Name                         Addr/Register   Size   Type
;_changed                            STATIC      1   variable
;_replace_expression                 IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_symbol_is_constant                 IMPORT  -----   function
;G_80                                 IX-12      3   variable
;G_83                                  IX-9      3   variable
;G_81                                  IX-6      3   variable
;result                                IX-3      3   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: 0 (instruction)


;  821	
;  822	uint8_t evaluate_logarithm(expression** result, expression* value, expression* base) {
_evaluate_logarithm:
	CALL	__frameset0
;  823	    
;  824	    if (expressions_are_identical(value, new_literal(1, 0, 1), false)) {
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_expressions_are_identical
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_334
;  825	        return set_error(ERRD_MATH, ERRI_UNDEFINED_VALUE, "");
	LD	BC,L__179
	PUSH	BC
	LD	BC,10
	PUSH	BC
	LD	BC,3
	PUSH	BC
	CALL	_set_error
	POP	BC
	POP	BC
	POP	BC
	JR	L_341
;  826	    }
L_334:
;  827	    
;  828	    if (expressions_are_identical(value, base, true)) {
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+12)
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_expressions_are_identical
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_339
;  829	        *result = new_literal(1, 1, 1);
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+6)
	LD	(IY),HL
;  830	        return RETS_SUCCESS;
	LD	A,2
	JR	L_341
;  831	    }
L_339:
;  832	    
;  833	    if (expressions_are_identical(base, new_symbol(EXPI_SYMBOL, "e"), false)) {
	LD	BC,0
	PUSH	BC
	LD	BC,L__181
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_expressions_are_identical
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_338
;  834	        *result = new_expression(EXPT_FUNCTION, EXPI_LN, 1, copy_expression(value));
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,1
	PUSH	BC
	LD	BC,11
	PUSH	BC
	LD	BC,3
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+6)
	LD	(IY),HL
;  835	    } else if (expressions_are_identical(base, new_literal(1, 10, 1), false)) {
	JR	L_340
L_338:
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,10
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_expressions_are_identical
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_336
;  836	        *result = new_expression(EXPT_FUNCTION, EXPI_LOG, 1, copy_expression(value));
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,1
	PUSH	BC
	LD	BC,12
	PUSH	BC
	LD	BC,3
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+6)
	LD	(IY),HL
;  837	    } else {
	JR	L_340
L_336:
;  838	        *result = new_expression(EXPT_FUNCTION, EXPI_LOG, 2,
;  839	                                 copy_expression(value),
;  840	                                 copy_expression(base));
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,12
	PUSH	BC
	LD	BC,3
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+6)
	LD	(IY),HL
;  841	    }
L_340:
;  842	    
;  843	    return RETS_SUCCESS;
	LD	A,2
;  844	    
;  845	}
L_341:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _evaluate_logarithm ***************************
;Name                         Addr/Register   Size   Type
;_copy_expression                    IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;_new_symbol                         IMPORT  -----   function
;_set_error                          IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_expressions_are_identical          IMPORT  -----   function
;base                                 IX+12      3   parameter
;value                                 IX+9      3   parameter
;result                                IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__179:
	DB	0
L__181:
	DB	"e"
	DB	0
	SEGMENT CODE
;  846	
;  847	uint8_t expand_logarithm(expression* source) {
_expand_logarithm:
	LD	HL,-25
	CALL	__frameset
;  848	    
;  849	    uint8_t i;
;  850	    expression* factors;
;  851	    expression* result;
;  852	    
;  853	    if (source->identifier != EXPI_LN || source->identifier != EXPI_LN) return RETS_UNCHANGED;
	LD	IY,(IX+6)
	LD	BC,(IY+3)
	LD	(IX+-25),BC
	LD	HL,BC
	LD	BC,11
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_343
	LD	HL,(IX+-25)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_366
L_343:
	LD	A,4
	JR	L_368
L_366:
;  854	    
;  855	    if (source->children[0]->identifier == EXPI_MULTIPLICATION) {
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-10),BC
	LD	HL,BC
	LD	IY,(HL)
	LD	BC,(IY+3)
	LD	(IX+-13),BC
	LD	HL,BC
	LD	BC,7
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_365
;  856	        
;  857	        result = new_expression(EXPT_OPERATION, EXPI_ADDITION, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-4),HL
;  858	        
;  859	        for (i = 0; i < source->children[0]->child_count; i++) {
	LD	(IX+-1),0
	JR	L_348
L_346:
;  860	            append_child(result, new_expression(EXPT_FUNCTION, source->identifier, 1, copy_expression(source->children[0]->children[i])));
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	IY,(IX+-16)
	LD	IY,(IY)
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IY+11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,1
	PUSH	BC
	LD	IY,(IX+6)
	LD	BC,(IY+3)
	PUSH	BC
	LD	BC,3
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  861	            if (source->child_count == 2) {
	LD	IY,(IX+6)
	LD	A,(IY+10)
	CP	A,2
	JR	NZ,L_347
;  862	                append_child(result->children[i], copy_expression(source->children[1]));
	LD	IY,(IX+6)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+-4)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	BC,(HL)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  863	            }
;  864	        }
L_347:
	INC	(IX+-1)
L_348:
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-16),BC
	LD	HL,BC
	LD	IY,(HL)
	LD	A,(IX+-1)
	CP	A,(IY+10)
	JR	C,L_346
	JR	L_367
;  865	        
;  866	    } else if (source->children[0]->identifier == EXPI_EXPONENTATION && expression_is_constant(source->children[0]->children[0]) && source->children[0]->children[0]->sign == 1) {
L_365:
	LD	BC,9
	LD	HL,(IX+-13)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_363
	LD	HL,(IX+-10)
	LD	IY,(HL)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expression_is_constant
	POP	BC
	OR	A,A
	JR	Z,L_363
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	BC,(IY+11)
	LD	(IX+-19),BC
	LD	HL,BC
	LD	IY,(HL)
	LD	A,(IY+6)
	CP	A,1
	JR	NZ,L_363
;  867	        
;  868	        result = new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
;  869	                                copy_expression(source->children[0]->children[1]),
;  870	                                copy_expression(source));
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	IY,(IX+-19)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-4),HL
;  871	        
;  872	        replace_expression(result->children[1]->children[0], copy_expression(result->children[1]->children[0]->children[0]));
	LD	IY,(IX+-4)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	IY,(HL)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	IY,(IX+-4)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	IY,(HL)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  873	        
;  874	    } else if (source->children[0]->identifier == EXPI_LITERAL && source->children[0]->value.numeric.denominator == 1) {
	JR	L_367
L_363:
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-22),BC
	LD	HL,BC
	LD	IY,(HL)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_361
	LD	HL,(IX+-22)
	LD	IY,(HL)
	LD	HL,(IY+18)
	LD	E,(IY+21)
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_361
;  875	        
;  876	        result = new_expression(EXPT_OPERATION, EXPI_ADDITION, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-4),HL
;  877	        
;  878	        factors = prime_factors(source->children[0]->value.numeric.numerator);
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	BC,(IY+14)
	LD	A,(IY+17)
	LD	H,0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_prime_factors
	POP	BC
	POP	BC
	LD	(IX+-7),HL
;  879	        
;  880	        if (factors->child_count == 1 && factors->children[0]->children[1]->value.numeric.numerator == 1) return RETS_CHANGED;
	LD	IY,(IX+-7)
	LD	A,(IY+10)
	CP	A,1
	JR	NZ,L_358
	LD	IY,(IX+-7)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	IY,(HL)
	LD	HL,(IY+14)
	LD	E,(IY+17)
	LD	BC,1
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_358
	LD	A,3
	JR	L_368
L_358:
;  881	        
;  882	        for (i = 0; i < factors->child_count; i++) {
	LD	(IX+-1),0
	JR	L_357
L_355:
;  883	            append_child(result, new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
;  884	                                                copy_expression(factors->children[i]->children[1]),
;  885	                                                new_expression(EXPT_FUNCTION, source->identifier, 1, copy_expression(factors->children[i]->children[0]))));
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+-7)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	IY,(HL)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,1
	PUSH	BC
	LD	IY,(IX+6)
	LD	BC,(IY+3)
	PUSH	BC
	LD	BC,3
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	IY,(IX+-7)
	LD	BC,(IY+11)
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	ADD	HL,BC
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
	INC	(IX+-1)
;  886	        }
L_357:
	LD	A,(IX+-1)
	LD	IY,(IX+-7)
	CP	A,(IY+10)
	JR	C,L_355
;  887	        
;  888	        free_expression(factors, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  889	        
;  890	    } else {
	JR	L_367
L_361:
;  891	        return RETS_UNCHANGED;
	LD	A,4
	JR	L_368
;  892	    }
L_367:
;  893	    
;  894	    replace_expression(source, result);
	LD	BC,(IX+-4)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  895	    
;  896	    changed = true;
	LD	A,1
	LD	(_changed),A
;  897	    
;  898	    return RETS_CHANGED;
	LD	A,3
;  899	    
;  900	}
L_368:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _expand_logarithm ***************************
;Name                         Addr/Register   Size   Type
;_changed                            STATIC      1   variable
;_free_expression                    IMPORT  -----   function
;_prime_factors                      IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;_expression_is_constant             IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;G_84                                 IX-25      3   variable
;G_89                                 IX-22      3   variable
;G_88                                 IX-19      3   variable
;G_85                                 IX-16      3   variable
;G_86                                 IX-13      3   variable
;G_87                                 IX-10      3   variable
;factors                               IX-7      3   variable
;result                                IX-4      3   variable
;i                                     IX-1      1   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 34 (bytes)
;       Spill Code: 0 (instruction)


;  901	
;  902	uint8_t simplify_logarithm(expression* source) {
_simplify_logarithm:
	LD	HL,-13
	CALL	__frameset
;  903	    
;  904	    expression* value;
;  905	    expression* base;
;  906	    expression* result;
;  907	    
;  908	    if (source->identifier == EXPI_LN && source->child_count == 1) {
	LD	IY,(IX+6)
	LD	BC,(IY+3)
	LD	(IX+-10),BC
	LD	HL,BC
	LD	BC,11
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_377
	LD	IY,(IX+6)
	LD	A,(IY+10)
	CP	A,1
	JR	NZ,L_377
;  909	        base = new_symbol(EXPI_SYMBOL, "e");
	LD	BC,L__201
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	LD	(IX+-4),HL
;  910	    } else if (source->identifier == EXPI_LOG && source->child_count == 1) {
	JR	L_378
L_377:
	LD	BC,12
	LD	HL,(IX+-10)
	OR	A,A
	SBC	HL,BC
	JR	Z,L__203
	LD	A,1
	JR	L__204
L__203:
	XOR	A,A
L__204:
	LD	(IX+-1),A
	OR	A,A
	JR	NZ,L_375
	LD	IY,(IX+6)
	LD	A,(IY+10)
	CP	A,1
	JR	NZ,L_375
;  911	        base = new_literal(1, 10, 1);
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,10
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-4),HL
;  912	    } else if (source->identifier == EXPI_LOG && source->child_count == 2) {
	JR	L_378
L_375:
	LD	A,(IX+-1)
	OR	A,A
	JR	NZ,L_373
	LD	IY,(IX+6)
	LD	A,(IY+10)
	CP	A,2
	JR	NZ,L_373
;  913	        base = copy_expression(source->children[1]);
	LD	IY,(IX+6)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-4),HL
;  914	    } else {
	JR	L_378
L_373:
;  915	        return set_error(ERRD_SYNTAX, ERRI_ARGUMENTS, "");
	LD	BC,L__209
	PUSH	BC
	LD	BC,8
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_set_error
	POP	BC
	POP	BC
	POP	BC
	JR	L_383
;  916	    }
L_378:
;  917	    
;  918	    value = copy_expression(source->children[0]);
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-13),HL
;  919	    
;  920	    ERROR_CHECK(evaluate_logarithm(&result, value, base));
	LD	BC,(IX+-4)
	PUSH	BC
	LD	BC,(IX+-13)
	PUSH	BC
	PEA	IX+-7
	CALL	_evaluate_logarithm
	POP	BC
	POP	BC
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	NZ,L_382
	LD	A,1
	JR	L_383
L_382:
;  921	    
;  922	    if (expand_logarithm(result) == RETS_CHANGED) {
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_expand_logarithm
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,3
	SBC	HL,BC
	JR	NZ,L_381
;  923	        replace_expression(source, result);
	LD	BC,(IX+-7)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  924	        return RETS_CHANGED;
	LD	A,3
	JR	L_383
;  925	    } else {
L_381:
;  926	        replace_expression(source, result);
	LD	BC,(IX+-7)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  927	        return RETS_SUCCESS;
	LD	A,2
;  928	    }
;  929	    
;  930	}
L_383:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _simplify_logarithm ***************************
;Name                         Addr/Register   Size   Type
;_replace_expression                 IMPORT  -----   function
;_set_error                          IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_new_symbol                         IMPORT  -----   function
;value                                IX-13      3   variable
;G_90                                 IX-10      3   variable
;result                                IX-7      3   variable
;base                                  IX-4      3   variable
;G_91                                  IX-1      1   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 22 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__201:
	DB	"e"
	DB	0
L__209:
	DB	0
	SEGMENT CODE
;  931	
;  932	void simplify_sin(expression* source) {
_simplify_sin:
	CALL	__frameset0
;  933	    
;  934	    if (expressions_are_equivalent(source->children[0], new_literal(1, 0, 1), false)) {
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_equivalent
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_393
;  935	        replace_expression(source, new_literal(1, 0, 1));
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  936	    } else if (expressions_are_equivalent(source->children[0], new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
	JR	L_394
L_393:
;  937	                                                                              new_literal(1, 1, 6),
;  938	                                                                              new_symbol(EXPI_SYMBOL, "pi")), false)) {
	LD	BC,0
	PUSH	BC
	LD	BC,L__214
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,6
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_equivalent
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_391
;  939	        replace_expression(source, new_literal(1, 1, 2));
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  940	    } else if (expressions_are_equivalent(source->children[0], new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
	JR	L_394
L_391:
;  941	                                                                              new_literal(1, 1, 4),
;  942	                                                                              new_symbol(EXPI_SYMBOL, "pi")), false)) {
	LD	BC,0
	PUSH	BC
	LD	BC,L__216
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,4
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_equivalent
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_389
;  943	        replace_expression(source, new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
;  944	                                                  new_expression(EXPT_OPERATION, EXPI_EXPONENTATION, 2,
;  945	                                                                 new_literal(1, 2, 1),
;  946	                                                                 new_literal(1, 1, 2)),
;  947	                                                  new_literal(1, 1, 2)));
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,9
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  948	    } else if (expressions_are_equivalent(source->children[0], new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
	JR	L_394
L_389:
;  949	                                                                              new_literal(1, 1, 3),
;  950	                                                                              new_symbol(EXPI_SYMBOL, "pi")), false)) {
	LD	BC,0
	PUSH	BC
	LD	BC,L__218
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,3
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_equivalent
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_387
;  951	        replace_expression(source, new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
;  952	                                                  new_expression(EXPT_OPERATION, EXPI_EXPONENTATION, 2,
;  953	                                                                 new_literal(1, 3, 1),
;  954	                                                                 new_literal(1, 1, 2)),
;  955	                                                  new_literal(1, 1, 2)));
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,3
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,9
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  956	    } else if (expressions_are_equivalent(source->children[0], new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
	JR	L_394
L_387:
;  957	                                                                              new_literal(1, 1, 2),
;  958	                                                                              new_symbol(EXPI_SYMBOL, "pi")), false)) {
	LD	BC,0
	PUSH	BC
	LD	BC,L__220
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_equivalent
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_395
;  959	        replace_expression(source, new_literal(1, 1, 1));
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  960	    } else {
;  961	        return;
;  962	    }
L_394:
;  963	    
;  964	    changed = true;
	LD	A,1
	LD	(_changed),A
;  965	    
;  966	}
L_395:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _simplify_sin ***************************
;Name                         Addr/Register   Size   Type
;_changed                            STATIC      1   variable
;_new_symbol                         IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_expressions_are_equivalent         IMPORT  -----   function
;source                                IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__214:
	DB	"pi"
	DB	0
L__216:
	DB	"pi"
	DB	0
L__218:
	DB	"pi"
	DB	0
L__220:
	DB	"pi"
	DB	0
	SEGMENT CODE
;  967	
;  968	void simplify_cos(expression* source) {
_simplify_cos:
	CALL	__frameset0
;  969	    
;  970	    if (expressions_are_equivalent(source->children[0], new_literal(1, 0, 1), false)) {
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_equivalent
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_405
;  971	        replace_expression(source, new_literal(1, 1, 1));
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  972	    } else if (expressions_are_equivalent(source->children[0], new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
	JR	L_406
L_405:
;  973	                                                                              new_literal(1, 1, 6),
;  974	                                                                              new_symbol(EXPI_SYMBOL, "pi")), false)) {
	LD	BC,0
	PUSH	BC
	LD	BC,L__224
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,6
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_equivalent
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_403
;  975	        replace_expression(source, new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
;  976	                                                  new_expression(EXPT_OPERATION, EXPI_EXPONENTATION, 2,
;  977	                                                                 new_literal(1, 3, 1),
;  978	                                                                 new_literal(1, 1, 2)),
;  979	                                                  new_literal(1, 1, 2)));
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,3
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,9
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  980	    } else if (expressions_are_equivalent(source->children[0], new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
	JR	L_406
L_403:
;  981	                                                                              new_literal(1, 1, 4),
;  982	                                                                              new_symbol(EXPI_SYMBOL, "pi")), false)) {
	LD	BC,0
	PUSH	BC
	LD	BC,L__226
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,4
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_equivalent
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_401
;  983	        replace_expression(source, new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
;  984	                                                  new_expression(EXPT_OPERATION, EXPI_EXPONENTATION, 2,
;  985	                                                                 new_literal(1, 2, 1),
;  986	                                                                 new_literal(1, 1, 2)),
;  987	                                                  new_literal(1, 1, 2)));
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,9
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  988	    } else if (expressions_are_equivalent(source->children[0], new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
	JR	L_406
L_401:
;  989	                                                                              new_literal(1, 1, 3),
;  990	                                                                              new_symbol(EXPI_SYMBOL, "pi")), false)) {
	LD	BC,0
	PUSH	BC
	LD	BC,L__228
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,3
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_equivalent
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_399
;  991	        replace_expression(source, new_literal(1, 1, 2));
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  992	    } else if (expressions_are_equivalent(source->children[0], new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
	JR	L_406
L_399:
;  993	                                                                              new_literal(1, 1, 2),
;  994	                                                                              new_symbol(EXPI_SYMBOL, "pi")), false)) {
	LD	BC,0
	PUSH	BC
	LD	BC,L__230
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_equivalent
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_407
;  995	        replace_expression(source, new_literal(1, 0, 1));
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  996	    } else {
;  997	        return;
;  998	    }
L_406:
;  999	    
; 1000	    changed = true;
	LD	A,1
	LD	(_changed),A
; 1001	    
; 1002	}
L_407:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _simplify_cos ***************************
;Name                         Addr/Register   Size   Type
;_changed                            STATIC      1   variable
;_new_symbol                         IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_expressions_are_equivalent         IMPORT  -----   function
;source                                IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__224:
	DB	"pi"
	DB	0
L__226:
	DB	"pi"
	DB	0
L__228:
	DB	"pi"
	DB	0
L__230:
	DB	"pi"
	DB	0
	SEGMENT CODE
; 1003	
; 1004	return_status simplify_tan(expression* source) {
_simplify_tan:
	CALL	__frameset0
; 1005	    
; 1006	    if (expressions_are_equivalent(source->children[0], new_literal(1, 0, 1), false)) {
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_equivalent
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_417
; 1007	        replace_expression(source, new_literal(1, 0, 1));
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
; 1008	    } else if (expressions_are_equivalent(source->children[0], new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
	JR	L_418
L_417:
; 1009	                                                                              new_literal(1, 1, 6),
; 1010	                                                                              new_symbol(EXPI_SYMBOL, "pi")), false)) {
	LD	BC,0
	PUSH	BC
	LD	BC,L__234
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,6
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_equivalent
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_415
; 1011	        replace_expression(source, new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
; 1012	                                                  new_expression(EXPT_OPERATION, EXPI_EXPONENTATION, 2,
; 1013	                                                                 new_literal(1, 3, 1),
; 1014	                                                                 new_literal(1, 1, 2)),
; 1015	                                                  new_literal(1, 1, 3)));
	LD	BC,0
	PUSH	BC
	LD	BC,3
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,3
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,9
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
; 1016	    } else if (expressions_are_equivalent(source->children[0], new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
	JR	L_418
L_415:
; 1017	                                                                              new_literal(1, 1, 4),
; 1018	                                                                              new_symbol(EXPI_SYMBOL, "pi")), false)) {
	LD	BC,0
	PUSH	BC
	LD	BC,L__236
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,4
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_equivalent
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_413
; 1019	        replace_expression(source, new_literal(1, 1, 1));
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
; 1020	    } else if (expressions_are_equivalent(source->children[0], new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
	JR	L_418
L_413:
; 1021	                                                                              new_literal(1, 1, 3),
; 1022	                                                                              new_symbol(EXPI_SYMBOL, "pi")), false)) {
	LD	BC,0
	PUSH	BC
	LD	BC,L__238
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,3
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_equivalent
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_411
; 1023	        replace_expression(source, new_expression(EXPT_OPERATION, EXPI_EXPONENTATION, 2,
; 1024	                                                  new_literal(1, 3, 1),
; 1025	                                                  new_literal(1, 1, 2)));
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,3
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,9
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
; 1026	    } else if (expressions_are_equivalent(source->children[0], new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
	JR	L_418
L_411:
; 1027	                                                                              new_literal(1, 1, 2),
; 1028	                                                                              new_symbol(EXPI_SYMBOL, "pi")), false)) {
	LD	BC,0
	PUSH	BC
	LD	BC,L__240
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_equivalent
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_409
; 1029	        return set_error(ERRD_MATH, ERRI_UNDEFINED_VALUE, "tan");
	LD	BC,L__242
	PUSH	BC
	LD	BC,10
	PUSH	BC
	LD	BC,3
	PUSH	BC
	CALL	_set_error
	POP	BC
	POP	BC
	POP	BC
	UEXT	HL
	LD	L,A
	JR	L_419
; 1030	    } else {
L_409:
; 1031	        return RETS_SUCCESS;
	LD	HL,2
	JR	L_419
; 1032	    }
L_418:
; 1033	    
; 1034	    changed = true;
	LD	A,1
	LD	(_changed),A
; 1035	    
; 1036	    return RETS_SUCCESS;
	LD	HL,2
; 1037	    
; 1038	}
L_419:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _simplify_tan ***************************
;Name                         Addr/Register   Size   Type
;_changed                            STATIC      1   variable
;_set_error                          IMPORT  -----   function
;_new_symbol                         IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_expressions_are_equivalent         IMPORT  -----   function
;source                                IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__234:
	DB	"pi"
	DB	0
L__236:
	DB	"pi"
	DB	0
L__238:
	DB	"pi"
	DB	0
L__240:
	DB	"pi"
	DB	0
L__242:
	DB	"tan"
	DB	0
	SEGMENT CODE
; 1039	
; 1040	void simplify_arcsin(expression* source) {
_simplify_arcsin:
	CALL	__frameset0
; 1041	    
; 1042	    if (expressions_are_identical(source->children[0], new_literal(1, 0, 1), false)) {
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_identical
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_429
; 1043	        replace_expression(source, new_literal(1, 0, 1));
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
; 1044	    } else if (expressions_are_identical(source->children[0], new_literal(1, 1, 2), false)) {
	JR	L_430
L_429:
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_identical
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_427
; 1045	        replace_expression(source, new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
; 1046	                                                  new_symbol(EXPI_SYMBOL, "pi"),
; 1047	                                                  new_literal(1, 1, 6)));
	LD	BC,0
	PUSH	BC
	LD	BC,6
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,L__246
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
; 1048	    } else if (expressions_are_equivalent(source->children[0], new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
	JR	L_430
L_427:
; 1049	                                                                              new_expression(EXPT_OPERATION, EXPI_EXPONENTATION, 2,
; 1050	                                                                                             new_literal(1, 2, 1),
; 1051	                                                                                             new_literal(1, 1, 2)),
; 1052	                                                                              new_literal(1, 1, 2)), false)) {
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,9
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_equivalent
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_425
; 1053	        replace_expression(source, new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
; 1054	                                                  new_symbol(EXPI_SYMBOL, "pi"),
; 1055	                                                  new_literal(1, 1, 4)));
	LD	BC,0
	PUSH	BC
	LD	BC,4
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,L__248
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
; 1056	    } else if (expressions_are_equivalent(source->children[0], new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
	JR	L_430
L_425:
; 1057	                                                                              new_expression(EXPT_OPERATION, EXPI_EXPONENTATION, 2,
; 1058	                                                                                             new_literal(1, 3, 1),
; 1059	                                                                                             new_literal(1, 1, 2)),
; 1060	                                                                              new_literal(1, 1, 2)), false)) {
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,3
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,9
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_equivalent
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_423
; 1061	        replace_expression(source, new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
; 1062	                                                  new_symbol(EXPI_SYMBOL, "pi"),
; 1063	                                                  new_literal(1, 1, 3)));
	LD	BC,0
	PUSH	BC
	LD	BC,3
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,L__250
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
; 1064	    } else if (expressions_are_identical(source->children[0], new_literal(1, 1, 1), false)) {
	JR	L_430
L_423:
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_identical
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_431
; 1065	        replace_expression(source, new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
; 1066	                                                  new_symbol(EXPI_SYMBOL, "pi"),
; 1067	                                                  new_literal(1, 1, 2)));
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,L__252
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
; 1068	    } else {
; 1069	        return;
; 1070	    }
L_430:
; 1071	    
; 1072	    changed = true;
	LD	A,1
	LD	(_changed),A
; 1073	    
; 1074	}
L_431:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _simplify_arcsin ***************************
;Name                         Addr/Register   Size   Type
;_changed                            STATIC      1   variable
;_expressions_are_equivalent         IMPORT  -----   function
;_new_symbol                         IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_expressions_are_identical          IMPORT  -----   function
;source                                IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__246:
	DB	"pi"
	DB	0
L__248:
	DB	"pi"
	DB	0
L__250:
	DB	"pi"
	DB	0
L__252:
	DB	"pi"
	DB	0
	SEGMENT CODE
; 1075	
; 1076	void simplify_arccos(expression* source) {
_simplify_arccos:
	CALL	__frameset0
; 1077	    
; 1078	    if (expressions_are_identical(source->children[0], new_literal(1, 1, 1), false)) {
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_identical
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_441
; 1079	        replace_expression(source, new_literal(1, 1, 1));
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
; 1080	    } else if (expressions_are_equivalent(source->children[0], new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
	JR	L_442
L_441:
; 1081	                                                                              new_expression(EXPT_OPERATION, EXPI_EXPONENTATION, 2,
; 1082	                                                                                             new_literal(1, 3, 1),
; 1083	                                                                                             new_literal(1, 1, 2)),
; 1084	                                                                              new_literal(1, 1, 2)), false)) {
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,3
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,9
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_equivalent
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_439
; 1085	        replace_expression(source, new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
; 1086	                                                  new_symbol(EXPI_SYMBOL, "pi"),
; 1087	                                                  new_literal(1, 1, 6)));
	LD	BC,0
	PUSH	BC
	LD	BC,6
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,L__256
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
; 1088	    } else if (expressions_are_equivalent(source->children[0], new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
	JR	L_442
L_439:
; 1089	                                                                              new_expression(EXPT_OPERATION, EXPI_EXPONENTATION, 2,
; 1090	                                                                                             new_literal(1, 2, 1),
; 1091	                                                                                             new_literal(1, 1, 2)),
; 1092	                                                                              new_literal(1, 1, 2)), false)) {
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,9
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_equivalent
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_437
; 1093	        replace_expression(source, new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
; 1094	                                                  new_symbol(EXPI_SYMBOL, "pi"),
; 1095	                                                  new_literal(1, 1, 4)));
	LD	BC,0
	PUSH	BC
	LD	BC,4
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,L__258
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
; 1096	    } else if (expressions_are_identical(source->children[0], new_literal(1, 1, 2), false)) {
	JR	L_442
L_437:
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_identical
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_435
; 1097	        replace_expression(source, new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
; 1098	                                                  new_symbol(EXPI_SYMBOL, "pi"),
; 1099	                                                  new_literal(1, 1, 3)));
	LD	BC,0
	PUSH	BC
	LD	BC,3
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,L__260
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
; 1100	    } else if (expressions_are_identical(source->children[0], new_literal(1, 0, 1), false)) {
	JR	L_442
L_435:
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_identical
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_443
; 1101	        replace_expression(source, new_literal(1, 0, 1));
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
; 1102	    } else {
; 1103	        return;
; 1104	    }
L_442:
; 1105	    
; 1106	    changed = true;
	LD	A,1
	LD	(_changed),A
; 1107	    
; 1108	}
L_443:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _simplify_arccos ***************************
;Name                         Addr/Register   Size   Type
;_changed                            STATIC      1   variable
;_new_symbol                         IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;_expressions_are_equivalent         IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_expressions_are_identical          IMPORT  -----   function
;source                                IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__256:
	DB	"pi"
	DB	0
L__258:
	DB	"pi"
	DB	0
L__260:
	DB	"pi"
	DB	0
	SEGMENT CODE
; 1109	
; 1110	void simplify_arctan(expression* source) {
_simplify_arctan:
	CALL	__frameset0
; 1111	    
; 1112	    if (expressions_are_identical(source->children[0], new_literal(1, 0, 1), false)) {
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_identical
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_451
; 1113	        replace_expression(source, new_literal(1, 0, 1));
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
; 1114	    } else if (expressions_are_equivalent(source->children[0], new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
	JR	L_452
L_451:
; 1115	                                                                              new_expression(EXPT_OPERATION, EXPI_EXPONENTATION, 2,
; 1116	                                                                                             new_literal(1, 3, 1),
; 1117	                                                                                             new_literal(1, 1, 2)),
; 1118	                                                                              new_literal(1, 1, 3)), false)) {
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,3
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,3
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,9
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_equivalent
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_449
; 1119	        replace_expression(source, new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
; 1120	                                                  new_symbol(EXPI_SYMBOL, "pi"),
; 1121	                                                  new_literal(1, 1, 6)));
	LD	BC,0
	PUSH	BC
	LD	BC,6
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,L__265
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
; 1122	    } else if (expressions_are_identical(source->children[0], new_literal(1, 1, 1), false)) {
	JR	L_452
L_449:
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_identical
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_447
; 1123	        replace_expression(source, new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
; 1124	                                                  new_symbol(EXPI_SYMBOL, "pi"),
; 1125	                                                  new_literal(1, 1, 4)));
	LD	BC,0
	PUSH	BC
	LD	BC,4
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,L__267
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
; 1126	    } else if (expressions_are_equivalent(source->children[0], new_expression(EXPT_OPERATION, EXPI_EXPONENTATION, 2,
	JR	L_452
L_447:
; 1127	                                                                              new_literal(1, 3, 1),
; 1128	                                                                              new_literal(1, 1, 2)), false)) {
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,3
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,9
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_equivalent
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_453
; 1129	        replace_expression(source, new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
; 1130	                                                  new_symbol(EXPI_SYMBOL, "pi"),
; 1131	                                                  new_literal(1, 1, 3)));
	LD	BC,0
	PUSH	BC
	LD	BC,3
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,L__269
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
; 1132	    } else {
; 1133	        return;
; 1134	    }
L_452:
; 1135	    
; 1136	    changed = true;
	LD	A,1
	LD	(_changed),A
; 1137	    
; 1138	}
L_453:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _simplify_arctan ***************************
;Name                         Addr/Register   Size   Type
;_changed                            STATIC      1   variable
;_new_symbol                         IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;_expressions_are_equivalent         IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_expressions_are_identical          IMPORT  -----   function
;source                                IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__265:
	DB	"pi"
	DB	0
L__267:
	DB	"pi"
	DB	0
L__269:
	DB	"pi"
	DB	0
	SEGMENT CODE
; 1139	
; 1140	uint8_t simplify(expression* source, bool recursive) {
_simplify:
	LD	HL,-4
	CALL	__frameset
; 1141	    
; 1142	    uint8_t i;
; 1143	    
; 1144	    changed = false;
	XOR	A,A
	LD	(_changed),A
; 1145	    
; 1146	    for (i = 0; i < source->child_count && recursive; i++) {
	LD	(IX+-1),0
	JR	L_461
L_459:
; 1147	        if (source->children[i] == NULL) continue;
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	ADD	HL,DE
	ADD	HL,BC
	LD	(IX+-4),HL
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_460
; 1148	        ERROR_CHECK(simplify(source->children[i], true));
	LD	BC,1
	PUSH	BC
	LD	HL,(IX+-4)
	LD	BC,(HL)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	NZ,L_460
	LD	A,1
	JR	L_496
; 1149	    }
L_460:
	INC	(IX+-1)
L_461:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	NC,L_462
	LD	A,(IX+9)
	OR	A,A
	JR	NZ,L_459
L_462:
; 1150	    
; 1151	    any_expression_to_expression(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_any_expression_to_expression
	POP	BC
; 1152	    
; 1153	    switch (source->identifier) {
	LD	IY,(IX+6)
	LD	HL,(IY+3)
	CALL	__case8
L__275:
	DW	22
	DB	1
	DW24	L_463	

	DB	2
	DW24	L_494	

	DB	3
	DW24	L_494	

	DB	5
	DW24	L_466	

	DB	6
	DW24	L_467	

	DB	7
	DW24	L_468	

	DB	8
	DW24	L_469	

	DB	9
	DW24	L_470	

	DB	10
	DW24	L_473	

	DB	11
	DW24	L_474	

	DB	12
	DW24	L_475	

	DB	13
	DW24	L_478	

	DB	14
	DW24	L_479	

	DB	15
	DW24	L_480	

	DB	16
	DW24	L_483	

	DB	17
	DW24	L_484	

	DB	18
	DW24	L_485	

	DB	38
	DW24	L_494	

	DB	39
	DW24	L_494	

	DB	40
	DW24	L_494	

	DB	41
	DW24	L_494	

	DB	42
	DW24	L_494	

	DW24	L_494	

; 1154	        case EXPI_LITERAL: simplify_literal(source); break;
L_463:
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_simplify_literal
	POP	BC
	JR	L_494
; 1155	        case EXPI_SYMBOL: break;
; 1156	        case EXPI_VARIABLE: break;
; 1157	        case EXPI_ADDITION: simplify_addition(source); break;
L_466:
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_simplify_addition
	POP	BC
	JR	L_494
; 1158	        case EXPI_SUBTRACTION: simplify_subtraction(source); break;
L_467:
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_simplify_subtraction
	POP	BC
	JR	L_494
; 1159	        case EXPI_MULTIPLICATION: simplify_multiplication(source); break;
L_468:
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_simplify_multiplication
	POP	BC
	JR	L_494
; 1160	        case EXPI_DIVISION: simplify_division(source); break;
L_469:
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_simplify_division
	POP	BC
	JR	L_494
; 1161	        case EXPI_EXPONENTATION: ERROR_CHECK(simplify_exponentation(source)); break;
L_470:
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_simplify_exponentation
	POP	BC
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_494
	LD	A,1
	JR	L_496
; 1162	        case EXPI_ABS: simplify_abs(source); break;
L_473:
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_simplify_abs
	POP	BC
	JR	L_494
; 1163	        case EXPI_LN:
L_474:
; 1164	        case EXPI_LOG: ERROR_CHECK(simplify_logarithm(source)); break;
L_475:
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_simplify_logarithm
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	NZ,L_494
	LD	A,1
	JR	L_496
; 1165	        case EXPI_SIN: simplify_sin(source); break;
L_478:
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_simplify_sin
	POP	BC
	JR	L_494
; 1166	        case EXPI_COS: simplify_cos(source); break;
L_479:
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_simplify_cos
	POP	BC
	JR	L_494
; 1167	        case EXPI_TAN: ERROR_CHECK(simplify_tan(source)); break;
L_480:
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_simplify_tan
	POP	BC
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_494
	LD	A,1
	JR	L_496
; 1168	        case EXPI_ARCSIN: simplify_arcsin(source); break;
L_483:
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_simplify_arcsin
	POP	BC
	JR	L_494
; 1169	        case EXPI_ARCCOS: simplify_arccos(source); break;
L_484:
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_simplify_arccos
	POP	BC
	JR	L_494
; 1170	        case EXPI_ARCTAN: simplify_arctan(source); break;
L_485:
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_simplify_arctan
	POP	BC
; 1171	        case EXPI_POLYNOMIAL_SPARSE: break;
; 1172	        case EXPI_POLYNOMIAL_DENSE: break;
; 1173	        case EXPI_LIST: break;
; 1174	        case EXPI_MATRIX: break;
; 1175	        case EXPI_EXTENSION: break;
; 1176	        default: break;
; 1177	    }
L_494:
; 1178	    
; 1179	    if (changed) ERROR_CHECK(simplify(source, true));
	LD	A,(_changed)
	OR	A,A
	JR	Z,L_495
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	NZ,L_495
	LD	A,1
	JR	L_496
L_495:
; 1180	    
; 1181	    return RETS_SUCCESS;
	LD	A,2
; 1182	    
; 1183	}
L_496:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _simplify ***************************
;Name                         Addr/Register   Size   Type
;_simplify_exponentation             IMPORT  -----   function
;_simplify_multiplication            IMPORT  -----   function
;_simplify_addition                  IMPORT  -----   function
;_simplify_literal                   IMPORT  -----   function
;_any_expression_to_expression       IMPORT  -----   function
;_changed                            STATIC      1   variable
;G_92                                  IX-4      3   variable
;i                                     IX-1      1   variable
;recursive                             IX+9      1   parameter
;source                                IX+6      3   parameter


; Stack Frame Size: 16 (bytes)
;       Spill Code: 0 (instruction)


; 1184	
; 1185	void approximate_addition(expression* source) {
_approximate_addition:
	LD	HL,-11
	CALL	__frameset
; 1186	    
; 1187	    uint8_t i;
; 1188	    double result = 0;
	LD	BC,0
	LD	(IX+-8),BC
	XOR	A,A
	LD	(IX+-5),A
; 1189	    
; 1190	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_501
L_499:
; 1191	        if (source->children[i]->identifier == EXPI_LITERAL) {
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	(IX+-4),HL
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	ADD	HL,BC
	LD	(IX+-11),HL
	LD	IY,(HL)
	LD	HL,(IY+3)
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	NZ,L_500
; 1192	            result += literal_to_double(source->children[i]);
	LD	HL,(IX+-11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	A,E
	LD	BC,HL
	LD	HL,(IX+-8)
	LD	E,(IX+-5)
	CALL	__fadd
	LD	(IX+-8),BC
	LD	(IX+-5),A
; 1193	            free_expression(source->children[i], false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-4)
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
; 1194	            source->children[i] = NULL;
	LD	BC,(IX+-4)
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	BC,0
	LD	(HL),BC
; 1195	        }
; 1196	    }
L_500:
	INC	(IX+-1)
L_501:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_499
; 1197	    
; 1198	    remove_null_children(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_remove_null_children
	POP	BC
; 1199	    
; 1200	    if (source->child_count == 0) {
	LD	IY,(IX+6)
	LD	A,(IY+10)
	OR	A,A
	JR	NZ,L_504
; 1201	        replace_expression(source, double_to_literal(result));
	LD	C,(IX+-5)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-8)
	PUSH	BC
	CALL	_double_to_literal
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
; 1202	    } else {
	JR	L_505
L_504:
; 1203	        append_child(source, double_to_literal(result));
	LD	C,(IX+-5)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-8)
	PUSH	BC
	CALL	_double_to_literal
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
; 1204	    }
L_505:
; 1205	    
; 1206	    return;
; 1207	    
; 1208	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _approximate_addition ***************************
;Name                         Addr/Register   Size   Type
;_append_child                       IMPORT  -----   function
;_double_to_literal                  IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;_remove_null_children               IMPORT  -----   function
;_free_expression                    IMPORT  -----   function
;_literal_to_double                  IMPORT  -----   function
;G_93                                 IX-11      3   variable
;result                                IX-8      4   variable
;G_94                                  IX-4      3   variable
;i                                     IX-1      1   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 20 (bytes)
;       Spill Code: 0 (instruction)


; 1209	
; 1210	void approximate_multiplication(expression* source) {
_approximate_multiplication:
	LD	HL,-11
	CALL	__frameset
; 1211	    
; 1212	    uint8_t i;
; 1213	    double result = 1;
	LD	BC,8388608
	LD	(IX+-8),BC
	LD	A,63
	LD	(IX+-5),A
; 1214	    
; 1215	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_511
L_509:
; 1216	        if (source->children[i]->identifier == EXPI_LITERAL) {
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	(IX+-4),HL
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	ADD	HL,BC
	LD	(IX+-11),HL
	LD	IY,(HL)
	LD	HL,(IY+3)
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	NZ,L_510
; 1217	            result *= literal_to_double(source->children[i]);
	LD	HL,(IX+-11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	A,E
	LD	BC,HL
	LD	HL,(IX+-8)
	LD	E,(IX+-5)
	CALL	__fmul
	LD	(IX+-8),BC
	LD	(IX+-5),A
; 1218	            free_expression(source->children[i], false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-4)
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
; 1219	            source->children[i] = NULL;
	LD	BC,(IX+-4)
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	BC,0
	LD	(HL),BC
; 1220	        }
; 1221	    }
L_510:
	INC	(IX+-1)
L_511:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_509
; 1222	    
; 1223	    remove_null_children(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_remove_null_children
	POP	BC
; 1224	    
; 1225	    if (source->child_count == 0) {
	LD	IY,(IX+6)
	LD	A,(IY+10)
	OR	A,A
	JR	NZ,L_514
; 1226	        replace_expression(source, double_to_literal(result));
	LD	C,(IX+-5)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-8)
	PUSH	BC
	CALL	_double_to_literal
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
; 1227	    } else {
	JR	L_515
L_514:
; 1228	        append_child(source, double_to_literal(result));
	LD	C,(IX+-5)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-8)
	PUSH	BC
	CALL	_double_to_literal
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
; 1229	    }
L_515:
; 1230	    
; 1231	    return;
; 1232	    
; 1233	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _approximate_multiplication ***************************
;Name                         Addr/Register   Size   Type
;_append_child                       IMPORT  -----   function
;_double_to_literal                  IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;_remove_null_children               IMPORT  -----   function
;_free_expression                    IMPORT  -----   function
;_literal_to_double                  IMPORT  -----   function
;G_96                                 IX-11      3   variable
;result                                IX-8      4   variable
;G_97                                  IX-4      3   variable
;i                                     IX-1      1   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 20 (bytes)
;       Spill Code: 0 (instruction)


; 1234	
; 1235	void approximate_exponentation(expression* source) {
_approximate_exponentation:
	LD	HL,-10
	CALL	__frameset
; 1236	    
; 1237	    double result;
; 1238	    
; 1239	    if (source->children[0]->identifier != EXPI_LITERAL || source->children[1]->identifier != EXPI_LITERAL) return;
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-3),BC
	LD	HL,BC
	LD	IY,(HL)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_520
	LD	IY,(IX+-3)
	LEA	BC,IY+3
	LD	(IX+-6),BC
	LD	HL,BC
	LD	IY,(HL)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_520
; 1240	    
; 1241	    result = pow(literal_to_double(source->children[0]), literal_to_double(source->children[1]));
	LD	HL,(IX+-6)
	LD	BC,(HL)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	C,E
	LD	B,0
	PUSH	BC
	PUSH	HL
	LD	HL,(IX+-3)
	LD	BC,(HL)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	C,E
	LD	B,0
	PUSH	BC
	PUSH	HL
	CALL	_pow
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-10),HL
	LD	(IX+-7),E
; 1242	    replace_expression(source,  double_to_literal(result));
	LD	C,(IX+-7)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-10)
	PUSH	BC
	CALL	_double_to_literal
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
; 1243	    
; 1244	    return;
; 1245	    
; 1246	}
L_520:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _approximate_exponentation ***************************
;Name                         Addr/Register   Size   Type
;_double_to_literal                  IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;_literal_to_double                  IMPORT  -----   function
;_pow                                IMPORT  -----   function
;result                               IX-10      4   variable
;G_100                                 IX-6      3   variable
;G_99                                  IX-3      3   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 19 (bytes)
;       Spill Code: 0 (instruction)


; 1247	
; 1248	void approximate_ln(expression* source) {
_approximate_ln:
	LD	HL,-7
	CALL	__frameset
; 1249	    
; 1250	    double result;
; 1251	    
; 1252	    if (source->children[0]->identifier != EXPI_LITERAL) return;
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-3),BC
	LD	HL,BC
	LD	IY,(HL)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_523
; 1253	    
; 1254	    result = log(literal_to_double(source->children[0]));
	LD	HL,(IX+-3)
	LD	BC,(HL)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	C,E
	LD	B,0
	PUSH	BC
	PUSH	HL
	CALL	_log
	POP	BC
	POP	BC
	LD	(IX+-7),HL
	LD	(IX+-4),E
; 1255	    replace_expression(source,  double_to_literal(result));
	LD	C,(IX+-4)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_double_to_literal
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
; 1256	    
; 1257	    return;
; 1258	    
; 1259	}
L_523:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _approximate_ln ***************************
;Name                         Addr/Register   Size   Type
;_double_to_literal                  IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;_literal_to_double                  IMPORT  -----   function
;_log                                IMPORT  -----   function
;result                                IX-7      4   variable
;G_102                                 IX-3      3   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 16 (bytes)
;       Spill Code: 0 (instruction)


; 1260	
; 1261	void approximate_log(expression* source) {
_approximate_log:
	LD	HL,-10
	CALL	__frameset
; 1262	    
; 1263	    double result;
; 1264	    
; 1265	    if (source->children[0]->identifier != EXPI_LITERAL) return;
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-3),BC
	LD	HL,BC
	LD	IY,(HL)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_530
; 1266	    
; 1267	    result = log10(literal_to_double(source->children[0]));
	LD	HL,(IX+-3)
	LD	BC,(HL)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	C,E
	LD	B,0
	PUSH	BC
	PUSH	HL
	CALL	_log10
	POP	BC
	POP	BC
	LD	(IX+-10),HL
	LD	(IX+-7),E
; 1268	    
; 1269	    if (source->child_count == 2) {
	LD	IY,(IX+6)
	LD	A,(IY+10)
	CP	A,2
	JR	NZ,L_529
; 1270	        if (source->children[1]->identifier != EXPI_LITERAL) return;
	LD	IY,(IX+6)
	LD	IY,(IY+11)
	LEA	BC,IY+3
	LD	(IX+-6),BC
	LD	HL,BC
	LD	IY,(HL)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_530
; 1271	        result /= log10(literal_to_double(source->children[1]));
	LD	HL,(IX+-6)
	LD	BC,(HL)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	C,E
	LD	B,0
	PUSH	BC
	PUSH	HL
	CALL	_log10
	POP	BC
	POP	BC
	LD	BC,(IX+-10)
	LD	A,(IX+-7)
	CALL	__fdiv
	LD	(IX+-10),BC
	LD	(IX+-7),A
; 1272	    }
L_529:
; 1273	    
; 1274	    replace_expression(source, double_to_literal(result));
	LD	C,(IX+-7)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-10)
	PUSH	BC
	CALL	_double_to_literal
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
; 1275	    
; 1276	    return;
; 1277	    
; 1278	}
L_530:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _approximate_log ***************************
;Name                         Addr/Register   Size   Type
;_double_to_literal                  IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;_literal_to_double                  IMPORT  -----   function
;_log10                              IMPORT  -----   function
;result                               IX-10      4   variable
;G_104                                 IX-6      3   variable
;G_103                                 IX-3      3   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 19 (bytes)
;       Spill Code: 0 (instruction)


; 1279	
; 1280	void approximate_trigonometric(expression* source) {
_approximate_trigonometric:
	LD	HL,-7
	CALL	__frameset
; 1281	    
; 1282	    double result;
; 1283	    
; 1284	    if (source->children[0]->identifier != EXPI_LITERAL) return;
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-3),BC
	LD	HL,BC
	LD	IY,(HL)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_541
; 1285	    
; 1286	    switch (source->identifier) {
	LD	IY,(IX+6)
	LD	HL,(IY+3)
	CALL	__seqcase
L__300:
	DW	6
	DW	13
	DB	0
	DW24	L_532	

	DW24	L_533	

	DW24	L_534	

	DW24	L_535	

	DW24	L_536	

	DW24	L_537	

	DW24	L_538	

; 1287	        case EXPI_SIN: result = sin(literal_to_double(source->children[0])); break;
L_532:
	LD	HL,(IX+-3)
	LD	BC,(HL)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	C,E
	LD	B,0
	PUSH	BC
	PUSH	HL
	CALL	_sin
	POP	BC
	POP	BC
	LD	(IX+-7),HL
	LD	(IX+-4),E
	JR	L_540
; 1288	        case EXPI_COS: result = cos(literal_to_double(source->children[0])); break;
L_533:
	LD	HL,(IX+-3)
	LD	BC,(HL)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	C,E
	LD	B,0
	PUSH	BC
	PUSH	HL
	CALL	_cos
	POP	BC
	POP	BC
	LD	(IX+-7),HL
	LD	(IX+-4),E
	JR	L_540
; 1289	        case EXPI_TAN: result = tan(literal_to_double(source->children[0])); break;
L_534:
	LD	HL,(IX+-3)
	LD	BC,(HL)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	C,E
	LD	B,0
	PUSH	BC
	PUSH	HL
	CALL	_tan
	POP	BC
	POP	BC
	LD	(IX+-7),HL
	LD	(IX+-4),E
	JR	L_540
; 1290	        case EXPI_ARCSIN: result = asin(literal_to_double(source->children[0])); break;
L_535:
	LD	HL,(IX+-3)
	LD	BC,(HL)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	C,E
	LD	B,0
	PUSH	BC
	PUSH	HL
	CALL	_asin
	POP	BC
	POP	BC
	LD	(IX+-7),HL
	LD	(IX+-4),E
	JR	L_540
; 1291	        case EXPI_ARCCOS: result = acos(literal_to_double(source->children[0])); break;
L_536:
	LD	HL,(IX+-3)
	LD	BC,(HL)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	C,E
	LD	B,0
	PUSH	BC
	PUSH	HL
	CALL	_acos
	POP	BC
	POP	BC
	LD	(IX+-7),HL
	LD	(IX+-4),E
	JR	L_540
; 1292	        case EXPI_ARCTAN: result = atan(literal_to_double(source->children[0])); break;
L_537:
	LD	HL,(IX+-3)
	LD	BC,(HL)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	C,E
	LD	B,0
	PUSH	BC
	PUSH	HL
	CALL	_atan
	POP	BC
	POP	BC
	LD	(IX+-7),HL
	LD	(IX+-4),E
	JR	L_540
; 1293	        default: return;
L_538:
	JR	L_541
; 1294	    }
L_540:
; 1295	    
; 1296	    replace_expression(source, double_to_literal(result));
	LD	C,(IX+-4)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_double_to_literal
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
; 1297	    
; 1298	    return;
; 1299	    
; 1300	}
L_541:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _approximate_trigonometric ***************************
;Name                         Addr/Register   Size   Type
;_double_to_literal                  IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;_atan                               IMPORT  -----   function
;_acos                               IMPORT  -----   function
;_asin                               IMPORT  -----   function
;_tan                                IMPORT  -----   function
;_cos                                IMPORT  -----   function
;_literal_to_double                  IMPORT  -----   function
;_sin                                IMPORT  -----   function
;result                                IX-7      4   variable
;G_105                                 IX-3      3   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 16 (bytes)
;       Spill Code: 0 (instruction)


; 1301	
; 1302	void approximate(expression* source) {
_approximate:
	LD	HL,-4
	CALL	__frameset
; 1303	    
; 1304	    uint8_t i;
; 1305	    
; 1306	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_547
L_545:
; 1307	        if (source->children[i] == 0) continue;
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	ADD	HL,DE
	ADD	HL,BC
	LD	(IX+-4),HL
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_546
; 1308	        approximate(source->children[i]);
	LD	HL,(IX+-4)
	LD	BC,(HL)
	PUSH	BC
	CALL	_approximate
	POP	BC
; 1309	    }
L_546:
	INC	(IX+-1)
L_547:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_545
; 1310	    
; 1311	    if (expressions_are_identical(source, new_symbol(EXPI_SYMBOL, "pi"), false)) {
	LD	BC,0
	PUSH	BC
	LD	BC,L__304
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_expressions_are_identical
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_550
; 1312	        replace_expression(source, double_to_literal(M_PI));
	LD	C,64
	LD	B,0
	PUSH	BC
	LD	BC,4788187
	PUSH	BC
	CALL	_double_to_literal
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
; 1313	    } else if (expressions_are_identical(source, new_symbol(EXPI_SYMBOL, "e"), false)) {
	JR	L_564
L_550:
	LD	BC,0
	PUSH	BC
	LD	BC,L__306
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_expressions_are_identical
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_564
; 1314	        replace_expression(source, double_to_literal(M_E));
	LD	C,64
	LD	B,0
	PUSH	BC
	LD	BC,3012692
	PUSH	BC
	CALL	_double_to_literal
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
; 1315	    }
L_564:
; 1316	    
; 1317	    switch (source->identifier) {
	LD	IY,(IX+6)
	LD	HL,(IY+3)
	CALL	__case8
L__308:
	DW	11
	DB	5
	DW24	L_552	

	DB	7
	DW24	L_553	

	DB	9
	DW24	L_554	

	DB	11
	DW24	L_555	

	DB	12
	DW24	L_556	

	DB	13
	DW24	L_557	

	DB	14
	DW24	L_558	

	DB	15
	DW24	L_559	

	DB	16
	DW24	L_560	

	DB	17
	DW24	L_561	

	DB	18
	DW24	L_562	

	DW24	L_565	

; 1318	        case EXPI_ADDITION: approximate_addition(source); break;
L_552:
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_approximate_addition
	POP	BC
	JR	L_565
; 1319	        case EXPI_MULTIPLICATION: approximate_multiplication(source); break;
L_553:
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_approximate_multiplication
	POP	BC
	JR	L_565
; 1320	        case EXPI_EXPONENTATION: approximate_exponentation(source); break;
L_554:
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_approximate_exponentation
	POP	BC
	JR	L_565
; 1321	        case EXPI_LN: approximate_ln(source); break;
L_555:
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_approximate_ln
	POP	BC
	JR	L_565
; 1322	        case EXPI_LOG: approximate_log(source); break;
L_556:
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_approximate_log
	POP	BC
	JR	L_565
; 1323	        case EXPI_SIN:
L_557:
; 1324	        case EXPI_COS:
L_558:
; 1325	        case EXPI_TAN:
L_559:
; 1326	        case EXPI_ARCSIN:
L_560:
; 1327	        case EXPI_ARCCOS:
L_561:
; 1328	        case EXPI_ARCTAN: approximate_trigonometric(source); break;
L_562:
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_approximate_trigonometric
	POP	BC
; 1329	        default: break;
; 1330	    }
; 1331	    
; 1332	}
L_565:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _approximate ***************************
;Name                         Addr/Register   Size   Type
;_double_to_literal                  IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;_new_symbol                         IMPORT  -----   function
;_expressions_are_identical          IMPORT  -----   function
;G_111                                 IX-4      3   variable
;i                                     IX-1      1   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 13 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__304:
	DB	"pi"
	DB	0
L__306:
	DB	"e"
	DB	0
	XREF _int_root:ROM
	XREF _int_power:ROM
	XREF _multiplication:ROM
	XREF _addition:ROM
	XREF _binomial_coefficients:ROM
	XREF _prime_factors:ROM
	XREF _euclidean_gcd:ROM
	XREF _any_expression_to_expression:ROM
	XREF _literal_to_double:ROM
	XREF _double_to_literal:ROM
	XREF _order_children:ROM
	XREF _remove_null_children:ROM
	XREF _remove_child_at_index:ROM
	XREF _symbol_is_constant:ROM
	XREF _expression_is_constant:ROM
	XREF _expressions_are_equivalent:ROM
	XREF _expressions_are_identical:ROM
	XREF _append_child:ROM
	XREF _free_expression:ROM
	XREF _replace_expression:ROM
	XREF _copy_expression:ROM
	XREF _new_symbol:ROM
	XREF _new_literal:ROM
	XREF _new_expression:ROM
	XREF _set_error:ROM
	XREF _smart_free:ROM
	XREF _pow:ROM
	XREF _log10:ROM
	XREF _log:ROM
	XREF _tan:ROM
	XREF _sin:ROM
	XREF _cos:ROM
	XREF _atan:ROM
	XREF _asin:ROM
	XREF _acos:ROM
	XREF __lcmpu:ROM
	XREF __ladd:ROM
	XREF __lsub:ROM
	XREF __ldivu:ROM
	XREF __fadd:ROM
	XREF __fmul:ROM
	XREF __fdiv:ROM
	XREF __fcmp:ROM
	XREF __frameset0:ROM
	XREF __frameset:ROM
	XREF __icmpzero:ROM
	XREF __lcmpzero:ROM
	XREF __case8:ROM
	XREF __seqcase:ROM
	XDEF _approximate
	XDEF _approximate_trigonometric
	XDEF _approximate_log
	XDEF _approximate_ln
	XDEF _approximate_exponentation
	XDEF _approximate_multiplication
	XDEF _approximate_addition
	XDEF _simplify
	XDEF _simplify_arctan
	XDEF _simplify_arccos
	XDEF _simplify_arcsin
	XDEF _simplify_tan
	XDEF _simplify_cos
	XDEF _simplify_sin
	XDEF _simplify_logarithm
	XDEF _expand_logarithm
	XDEF _evaluate_logarithm
	XDEF _simplify_abs
	XDEF _simplify_exponentation
	XDEF _evaluate_exponentation
	XDEF _exponentation_remove_logarithms
	XDEF _symbolic_exponentation
	XDEF _numeric_exponentation
	XDEF _remove_exponentation_identities
	XDEF _expand_exponentation_exponent
	XDEF _expand_exponentation_base
	XDEF _merge_nested_exponentations
	XDEF _simplify_division
	XDEF _simplify_multiplication
	XDEF _expand_multiplication
	XDEF _expand_multiplication_addition_factors
	XDEF _evaluate_multiplication
	XDEF _symbolic_multiplication
	XDEF _numeric_multiplication
	XDEF _simplify_subtraction
	XDEF _simplify_addition
	XDEF _evaluate_addition
	XDEF _symbolic_addition
	XDEF _numeric_addition
	XDEF _merge_additions_multiplications
	XDEF _simplify_literal
	XDEF _changed
	END
