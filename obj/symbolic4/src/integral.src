; Zilog eZ80 ANSI C Compiler Release 3.4
; -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"SRC\SYMBOLIC4\SRC\INTEGRAL.C"
	.assume ADL=1
	SEGMENT CODE
;    1	
;    2	/*
;    3	 
;    4	 Copyright (c) 2019 Hannes Eberhard
;    5	 
;    6	 Permission is hereby granted, free of charge, to any person obtaining a copy
;    7	 of this software and associated documentation files (the "Software"), to deal
;    8	 in the Software without restriction, including without limitation the rights
;    9	 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
;   10	 copies of the Software, and to permit persons to whom the Software is
;   11	 furnished to do so, subject to the following conditions:
;   12	 
;   13	 The above copyright notice and this permission notice shall be included in all
;   14	 copies or substantial portions of the Software.
;   15	 
;   16	 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;   17	 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;   18	 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;   19	 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;   20	 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;   21	 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;   22	 SOFTWARE.
;   23	 
;   24	 */
;   25	
;   26	#include "symbolic4.h"
;   27	
;   28	bool expression_is_risch_integrable(expression* source, expression* variable) {
_expression_is_risch_integrable:
	LD	HL,-4
	CALL	__frameset
;   29	    
;   30	    uint8_t i;
;   31	    
;   32	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_4
L_2:
;   33	        if (!expression_is_risch_integrable(source->children[i], variable)) return false;
	LD	BC,(IX+9)
	PUSH	BC
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	ADD	HL,DE
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_expression_is_risch_integrable
	POP	BC
	POP	BC
	OR	A,A
	JR	NZ,L_3
	XOR	A,A
	JR	L_20
;   34	    }
L_3:
	INC	(IX+-1)
L_4:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_2
;   35	    
;   36	    if (source->identifier == EXPI_EXPONENTATION && source->children[0]->value.symbolic[0] != 'e' && count_occurrences(source->children[1], variable, true) != 0) {
	LD	IY,(IX+6)
	LD	HL,(IY+3)
	LD	BC,9
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_17
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-4),BC
	LD	HL,BC
	LD	IY,(HL)
	LD	A,(IY+14)
	LD	B,A
	SEXT	HL
	LD	L,B
	OR	A,A
	LD	BC,101
	SBC	HL,BC
	JR	Z,L_17
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	LD	IY,(IX+-4)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_count_occurrences
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_17
;   37	        return false;
	XOR	A,A
	JR	L_20
;   38	    } else if (source->identifier == EXPI_EXPONENTATION && count_occurrences(source->children[0], variable, true) != 0 && source->children[1]->identifier != EXPI_LITERAL) {
L_17:
	LD	IY,(IX+6)
	LD	HL,(IY+3)
	LD	BC,9
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_15
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_count_occurrences
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_15
	LD	IY,(IX+6)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	IY,(HL)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	Z,L_15
;   39	        return false;
	XOR	A,A
	JR	L_20
;   40	    }  else if (source->identifier == EXPI_EXPONENTATION && count_occurrences(source->children[0], variable, true) != 0 && source->children[1]->value.numeric.denominator != 1) {
L_15:
	LD	IY,(IX+6)
	LD	HL,(IY+3)
	LD	BC,9
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_13
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_count_occurrences
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_13
	LD	IY,(IX+6)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	IY,(HL)
	LD	HL,(IY+18)
	LD	E,(IY+21)
	LD	BC,1
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_13
;   41	        return false;
	XOR	A,A
	JR	L_20
;   42	    } else if (source->identifier == EXPI_LOG) {
L_13:
	LD	IY,(IX+6)
	LD	HL,(IY+3)
	LD	BC,12
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_19
;   43	        return false;
	XOR	A,A
	JR	L_20
;   44	    }
L_19:
;   45	    
;   46	    return true;
	LD	A,1
;   47	    
;   48	}
L_20:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _expression_is_risch_integrable ***************************
;Name                         Addr/Register   Size   Type
;_count_occurrences                  IMPORT  -----   function
;G_0                                   IX-4      3   variable
;i                                     IX-1      1   variable
;variable                              IX+9      3   parameter
;source                                IX+6      3   parameter


; Stack Frame Size: 16 (bytes)
;       Spill Code: 0 (instruction)


;   49	
;   50	void risch_get_extensions(expression* extensions, expression* source, expression* variable) {
_risch_get_extensions:
	LD	HL,-17
	CALL	__frameset
;   51	    
;   52	    uint8_t i;
;   53	    expression* extension;
;   54	    
;   55	    if (count_occurrences(source, variable, true) == 0) {
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+12)
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_count_occurrences
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_36
;   56	        return;
;   57	    }
;   58	    
;   59	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_27
L_25:
;   60	        if (source->children[i] == NULL) continue;
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+9)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	(IX+-7),HL
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_26
;   61	        risch_get_extensions(extensions, source->children[i], variable);
	LD	BC,(IX+12)
	PUSH	BC
	LD	HL,(IX+-7)
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_risch_get_extensions
	POP	BC
	POP	BC
	POP	BC
;   62	    }
L_26:
	INC	(IX+-1)
L_27:
	LD	A,(IX+-1)
	LD	IY,(IX+9)
	CP	A,(IY+10)
	JR	C,L_25
;   63	    
;   64	    if (source->identifier == EXPI_EXPONENTATION && source->children[0]->value.symbolic[0] == 'e') {
	LD	IY,(IX+9)
	LD	BC,(IY+3)
	LD	(IX+-10),BC
	LD	HL,BC
	LD	BC,9
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_33
	LD	IY,(IX+9)
	LD	BC,(IY+11)
	LD	(IX+-13),BC
	LD	HL,BC
	LD	IY,(HL)
	LD	A,(IY+14)
	LD	B,A
	SEXT	HL
	LD	L,B
	OR	A,A
	LD	BC,101
	SBC	HL,BC
	JR	NZ,L_33
;   65	        extension = new_expression(EXPT_STRUCTURE, EXPI_EXTENSION, 2,
;   66	                                   new_symbol(EXPI_SYMBOL, "EE____"),
;   67	                                   copy_expression(source->children[1]));
	LD	IY,(IX+-13)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	LD	(IX+-14),A
	CALL	_copy_expression
	LD	A,(IX+-14)
	POP	BC
	PUSH	HL
	LD	BC,L__18
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	(IX+-14),A
	CALL	_new_symbol
	LD	A,(IX+-14)
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,42
	PUSH	BC
	LD	BC,4
	PUSH	BC
	LD	(IX+-14),A
	CALL	_new_expression
	LD	A,(IX+-14)
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-4),HL
;   68	    } else if (source->identifier == EXPI_LN) {
	JR	L_35
L_33:
	LD	BC,11
	LD	HL,(IX+-10)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_36
;   69	        extension = new_expression(EXPT_STRUCTURE, EXPI_EXTENSION, 2,
;   70	                                   new_symbol(EXPI_SYMBOL, "LE____"),
;   71	                                   copy_expression(source->children[1]));
	LD	IY,(IX+9)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	LD	(IX+-14),A
	CALL	_copy_expression
	LD	A,(IX+-14)
	POP	BC
	PUSH	HL
	LD	BC,L__20
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	(IX+-14),A
	CALL	_new_symbol
	LD	A,(IX+-14)
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,42
	PUSH	BC
	LD	BC,4
	PUSH	BC
	LD	(IX+-14),A
	CALL	_new_expression
	LD	A,(IX+-14)
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-4),HL
;   72	    } else {
;   73	        return;
;   74	    }
L_35:
;   75	    
;   76	    itoa(extension->children[0]->value.symbolic + 2, extensions->child_count);
	UEXT	HL
	LD	IY,(IX+6)
	LD	L,(IY+10)
	LD	C,H
	LD	B,0
	PUSH	BC
	PUSH	HL
	LD	IY,(IX+-4)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LEA	BC,IY+16
	PUSH	BC
	CALL	_itoa
	POP	BC
	POP	BC
	POP	BC
;   77	    extension->children[0]->value.symbolic[strlen(extension->children[0]->value.symbolic)] = '_';
	LD	IY,(IX+-4)
	LD	HL,(IY+11)
	LD	DE,(HL)
	LD	HL,(IY+11)
	LD	IY,(HL)
	PEA	IY+14
	LD	(IX+-16),DE
	LD	(IX+-17),D
	CALL	_strlen
	LD	DE,(IX+-16)
	LD	D,(IX+-17)
	POP	BC
	LD	BC,HL
	LD	IY,DE
	LEA	HL,IY+14
	ADD	HL,BC
	LD	(HL),95
;   78	    append_child(extensions, extension);
	LD	BC,(IX+-4)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;   79	    
;   80	    replace_expression(source, copy_expression(extension->children[0]));
	LD	IY,(IX+-4)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;   81	    
;   82	}
L_36:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _risch_get_extensions ***************************
;Name                         Addr/Register   Size   Type
;_replace_expression                 IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;_strlen                             IMPORT  -----   function
;_itoa                               IMPORT  -----   function
;_new_symbol                         IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;_count_occurrences                  IMPORT  -----   function
;G_2                                  IX-13      3   variable
;G_3                                  IX-10      3   variable
;G_1                                   IX-7      3   variable
;extension                             IX-4      3   variable
;i                                     IX-1      1   variable
;variable                             IX+12      3   parameter
;source                                IX+9      3   parameter
;extensions                            IX+6      3   parameter


; Stack Frame Size: 32 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__18:
	DB	"EE____"
	DB	0
L__20:
	DB	"LE____"
	DB	0
	SEGMENT CODE
;   83	
;   84	uint8_t risch_determine_parts(expression** polynominal_part, expression** rational_part, expression* source, expression* variable, expression* extensions) {
_risch_determine_parts:
	LD	HL,-11
	CALL	__frameset
;   85	    
;   86	    int8_t index;
;   87	    expression* quotient;
;   88	    expression* remainder;
;   89	    expression* temp;
;   90	    
;   91	    if (extensions->child_count > 0) {
	LD	IY,(IX+18)
	LD	A,(IY+10)
	LD	(IX+-5),A
	XOR	A,A
	CP	A,(IX+-5)
	JR	NC,L_55
;   92	        if (any_expression_to_sparse_polynomial(source, extensions->children[extensions->child_count - 1]->children[1]) == RETS_SUCCESS) {
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+18)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_any_expression_to_sparse_polynomial
	POP	BC
	POP	BC
	LD	BC,2
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_56
;   93	            *polynominal_part = source;
	LD	HL,(IX+6)
	LD	BC,(IX+12)
	LD	(HL),BC
;   94	            *rational_part = NULL;
	LD	HL,(IX+9)
	LD	BC,0
	LD	(HL),BC
;   95	            return RETS_SUCCESS;
	LD	A,2
	JR	L_57
;   96	        }
;   97	    } else if ((index = expression_contains_division(source)) != -1) {
L_55:
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_expression_contains_division
	POP	BC
	LD	(IX+-4),A
	CP	A,-1
	JR	Z,L_53
;   98	        
;   99	        source->children[index]->children[1]->sign = 1;
	LD	A,(IX+-4)
	SEXT	HL
	LD	L,(IX+-4)
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+12)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	IY,(HL)
	LD	(IY+6),1
;  100	        temp = copy_expression(source->children[index]);
	LD	A,(IX+-4)
	SEXT	HL
	LD	L,(IX+-4)
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+12)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-3),HL
;  101	        
;  102	        simplify(temp, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  103	        
;  104	        ERROR_CHECK(any_expression_to_sparse_polynomial(temp, variable));
	LD	BC,(IX+15)
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_any_expression_to_sparse_polynomial
	POP	BC
	POP	BC
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_40
	LD	A,1
	JR	L_57
L_40:
;  105	        ERROR_CHECK(validate_sparse_polynomial(temp, false, false, false));
	LD	BC,0
	PUSH	BC
	PUSH	BC
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_validate_sparse_polynomial
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_42
	LD	A,1
	JR	L_57
L_42:
;  106	        
;  107	        ERROR_CHECK(any_expression_to_sparse_polynomial(source->children[0], variable));
	LD	BC,(IX+15)
	PUSH	BC
	LD	IY,(IX+12)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_any_expression_to_sparse_polynomial
	POP	BC
	POP	BC
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_44
	LD	A,1
	JR	L_57
L_44:
;  108	        ERROR_CHECK(validate_sparse_polynomial(temp, false, false, false));
	LD	BC,0
	PUSH	BC
	PUSH	BC
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_validate_sparse_polynomial
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_45
	LD	A,1
	JR	L_57
L_45:
;  109	        
;  110	        poly_div(&quotient, &remainder, source->children[0], temp);
	LD	BC,(IX+-3)
	PUSH	BC
	LD	IY,(IX+12)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	PEA	IX+-11
	PEA	IX+-8
	CALL	_poly_div
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  111	        
;  112	        *polynominal_part = quotient;
	LD	HL,(IX+6)
	LD	BC,(IX+-8)
	LD	(HL),BC
;  113	        *rational_part = new_expression(EXPT_STRUCTURE, EXPI_LIST, 2,
;  114	                                        remainder,
;  115	                                        temp);
	LD	BC,(IX+-3)
	PUSH	BC
	LD	BC,(IX+-11)
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+9)
	LD	(IY),HL
;  116	        
;  117	    } else if (expression_is_reziprocal(source)) {
	JR	L_56
L_53:
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_expression_is_reziprocal
	POP	BC
	OR	A,A
	JR	Z,L_51
;  118	        
;  119	        *polynominal_part = NULL;
	LD	HL,(IX+6)
	LD	BC,0
	LD	(HL),BC
;  120	        
;  121	        *rational_part = new_expression(EXPT_STRUCTURE, EXPI_LIST, 2,
;  122	                                        new_literal(1, 1, 1),
;  123	                                        copy_expression(source));
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+9)
	LD	(IY),HL
;  124	        
;  125	        (*rational_part)->children[1]->children[1]->sign = 1;
	LD	HL,(IX+9)
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	IY,(HL)
	LD	(IY+6),1
;  126	        
;  127	        simplify(*rational_part, true);
	LD	BC,1
	PUSH	BC
	LD	HL,(IX+9)
	LD	BC,(HL)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  128	        
;  129	        ERROR_CHECK(any_expression_to_sparse_polynomial((*rational_part)->children[0], variable));
	LD	BC,(IX+15)
	PUSH	BC
	LD	HL,(IX+9)
	LD	IY,(HL)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_any_expression_to_sparse_polynomial
	POP	BC
	POP	BC
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_48
	LD	A,1
	JR	L_57
L_48:
;  130	        ERROR_CHECK(any_expression_to_sparse_polynomial((*rational_part)->children[1], variable));
	LD	BC,(IX+15)
	PUSH	BC
	LD	HL,(IX+9)
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_any_expression_to_sparse_polynomial
	POP	BC
	POP	BC
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_56
	LD	A,1
	JR	L_57
;  131	        
;  132	    } else {
L_51:
;  133	        
;  134	        *polynominal_part = copy_expression(source);
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	IY,(IX+6)
	LD	(IY),HL
;  135	        *rational_part = NULL;
	LD	HL,(IX+9)
	LD	BC,0
	LD	(HL),BC
;  136	        ERROR_CHECK(any_expression_to_sparse_polynomial(*polynominal_part, variable));
	LD	BC,(IX+15)
	PUSH	BC
	LD	HL,(IX+6)
	LD	BC,(HL)
	PUSH	BC
	CALL	_any_expression_to_sparse_polynomial
	POP	BC
	POP	BC
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_56
	LD	A,1
	JR	L_57
;  137	        
;  138	    }
L_56:
;  139	    
;  140	    return RETS_SUCCESS;
	LD	A,2
;  141	    
;  142	}
L_57:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _risch_determine_parts ***************************
;Name                         Addr/Register   Size   Type
;_new_literal                        IMPORT  -----   function
;_expression_is_reziprocal           IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;_poly_div                           IMPORT  -----   function
;_validate_sparse_polynomial         IMPORT  -----   function
;_simplify                           IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_expression_contains_division       IMPORT  -----   function
;_any_expression_to_sparse_polynomial      IMPORT  -----   function
;remainder                            IX-11      3   variable
;quotient                              IX-8      3   variable
;G_4                                   IX-5      1   variable
;index                                 IX-4      1   variable
;temp                                  IX-3      3   variable
;extensions                           IX+18      3   parameter
;variable                             IX+15      3   parameter
;source                               IX+12      3   parameter
;rational_part                         IX+9      3   parameter
;polynominal_part                      IX+6      3   parameter


; Stack Frame Size: 32 (bytes)
;       Spill Code: 0 (instruction)


;  143	
;  144	void risch_integrate_polynominal_part(expression* source) {
_risch_integrate_polynominal_part:
	LD	HL,-7
	CALL	__frameset
;  145	    
;  146	    uint8_t i;
;  147	    expression* exponent;
;  148	    expression* result;
;  149	    
;  150	    if (source == NULL) return;
	LD	HL,(IX+6)
	CALL	__icmpzero
	JR	Z,L_65
;  151	    
;  152	    result = new_expression(EXPT_STRUCTURE, EXPI_POLYNOMIAL_SPARSE, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,38
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-7),HL
;  153	    
;  154	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_63
L_61:
;  155	        
;  156	        exponent = new_expression(EXPT_OPERATION, EXPI_ADDITION, 2,
;  157	                                  copy_expression(source->children[i]->children[0]),
;  158	                                  new_literal(1, 1, 1));
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	ADD	HL,BC
	LD	IY,(HL)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-4),HL
;  159	        
;  160	        simplify(exponent, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  161	        
;  162	        append_child(result, new_expression(EXPT_STRUCTURE, EXPI_LIST, 3,
;  163	                                            copy_expression(exponent),
;  164	                                            new_expression(EXPT_OPERATION, EXPI_DIVISION, 2,
;  165	                                                           copy_expression(source->children[i]->children[1]),
;  166	                                                                          copy_expression(exponent)),
;  167	                                            copy_expression(source->children[i]->children[2])));
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+6
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,8
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,3
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  168	        
;  169	        free_expression(exponent, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
	INC	(IX+-1)
;  170	        
;  171	    }
L_63:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_61
;  172	    
;  173	    simplify(result, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  174	    replace_expression(source, result);
	LD	BC,(IX+-7)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  175	    
;  176	}
L_65:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _risch_integrate_polynominal_part ***************************
;Name                         Addr/Register   Size   Type
;_replace_expression                 IMPORT  -----   function
;_free_expression                    IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;_simplify                           IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;result                                IX-7      3   variable
;exponent                              IX-4      3   variable
;i                                     IX-1      1   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 16 (bytes)
;       Spill Code: 0 (instruction)


;  177	
;  178	void rothstein_trager_method(expression* source) {
_rothstein_trager_method:
	LD	HL,-67
	CALL	__frameset
;  179	    
;  180	    uint8_t i, j;
;  181	    expression* a = copy_expression(source->children[0]);
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-5),HL
;  182	    uint8_t a_degree;
;  183	    expression* b = copy_expression(source->children[1]);
	LD	IY,(IX+6)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-8),HL
;  184	    expression* b_derivative;
;  185	    expression* b_derivative_negative;
;  186	    expression* a_coefficients = new_expression(EXPT_STRUCTURE, EXPI_LIST, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-40),HL
;  187	    expression* b_coefficients = new_expression(EXPT_STRUCTURE, EXPI_LIST, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-43),HL
;  188	    expression* z = new_symbol(EXPI_SYMBOL, "EZ");
	LD	BC,L__37
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	LD	(IX+-17),HL
;  189	    expression* extentions = new_expression(EXPT_STRUCTURE, EXPI_LIST, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-58),HL
;  190	    expression* resultant_poly;
;  191	    expression* resultant;
;  192	    expression* primitive_part;
;  193	    expression* factor;
;  194	    uint8_t factor_degree;
;  195	    expression* equation;
;  196	    expression* temp;
;  197	    expression* gcd;
;  198	    expression* result = new_expression(EXPT_OPERATION, EXPI_ADDITION, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-34),HL
;  199	    
;  200	    derivative(&b_derivative, b, NULL, true);
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-8)
	PUSH	BC
	PEA	IX+-11
	CALL	_derivative
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  201	    b_derivative_negative = new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
;  202	                                           copy_expression(b_derivative),
;  203	                                           new_literal(-1, 1, 1));
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,16777215
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-11)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-14),HL
;  204	    simplify(b_derivative_negative, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-14)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  205	    
;  206	    simplify(b, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-8)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  207	    any_expression_to_sparse_polynomial(b, NULL);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-8)
	PUSH	BC
	CALL	_any_expression_to_sparse_polynomial
	POP	BC
	POP	BC
;  208	    any_expression_to_sparse_polynomial(b_derivative, NULL);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-11)
	PUSH	BC
	CALL	_any_expression_to_sparse_polynomial
	POP	BC
	POP	BC
;  209	    any_expression_to_sparse_polynomial(b_derivative_negative, NULL);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-14)
	PUSH	BC
	CALL	_any_expression_to_sparse_polynomial
	POP	BC
	POP	BC
;  210	    
;  211	    append_child(extentions, new_expression(EXPT_OPERATION, EXPI_EQUATION, 2,
;  212	                                            copy_expression(z),
;  213	                                            copy_expression(z)));
	LD	BC,(IX+-17)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-17)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,4
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-58)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  214	    
;  215	    resultant_poly = new_expression(EXPT_STRUCTURE, EXPI_POLYNOMIAL_DENSE, 2,
;  216	                                    copy_expression(z),
;  217	                                    new_expression(EXPT_STRUCTURE, EXPI_LIST, 2,
;  218	                                                   copy_expression(a),
;  219	                                                   copy_expression(b_derivative_negative)));
	LD	BC,(IX+-14)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-5)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-17)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,39
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-49),HL
;  220	    
;  221	    any_expression_to_expression(resultant_poly->children[1]->children[0]);
	LD	IY,(IX+-49)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	IY,(HL)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_any_expression_to_expression
	POP	BC
;  222	    any_expression_to_expression(resultant_poly->children[1]->children[1]);
	LD	IY,(IX+-49)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_any_expression_to_expression
	POP	BC
;  223	    
;  224	    a_degree = max(a->children[0]->children[0]->value.numeric.numerator, b_derivative->children[0]->children[0]->value.numeric.numerator);
	LD	IY,(IX+-11)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	BC,(IY+14)
	LD	A,(IY+17)
	LD	H,0
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	IY,(IX+-5)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	BC,(IY+14)
	LD	A,(IY+17)
	LD	H,0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_max
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	BC,HL
	LD	(IX+-28),C
;  225	    
;  226	    any_expression_to_dense_polynomial(a, NULL);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-5)
	PUSH	BC
	CALL	_any_expression_to_dense_polynomial
	POP	BC
	POP	BC
;  227	    any_expression_to_dense_polynomial(b, NULL);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-8)
	PUSH	BC
	CALL	_any_expression_to_dense_polynomial
	POP	BC
	POP	BC
;  228	    any_expression_to_dense_polynomial(b_derivative_negative, NULL);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-14)
	PUSH	BC
	CALL	_any_expression_to_dense_polynomial
	POP	BC
	POP	BC
;  229	    
;  230	    for (i = 0; i < a_degree + 1; i++) {
	LD	(IX+-1),0
	JR	L_69
L_67:
;  231	        append_child(a_coefficients, new_expression(EXPT_STRUCTURE, EXPI_POLYNOMIAL_DENSE, 2,
;  232	                                                    copy_expression(z),
;  233	                                                    new_expression(EXPT_STRUCTURE, EXPI_LIST, 2,
;  234	                                                                   copy_expression(a->children[1]->children[i]),
;  235	                                                                   copy_expression(b_derivative_negative->children[1]->children[i]))));
	LD	IY,(IX+-14)
	LD	IY,(IY+11)
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	(IX+-61),HL	; spill
	LEA	HL,IY+3
	LD	(IX+-67),HL	; spill
	LD	HL,(IX+-61)	; unspill
	LD	(IX+-61),HL	; spill
	LD	HL,(IX+-67)	; unspill
	LD	IY,(HL)
	LD	HL,(IX+-61)	; unspill
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IY+11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	IY,(IX+-5)
	LD	IY,(IY+11)
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	(IX+-61),HL	; spill
	LEA	HL,IY+3
	LD	(IX+-64),HL	; spill
	LD	HL,(IX+-61)	; unspill
	LD	(IX+-61),HL	; spill
	LD	HL,(IX+-64)	; unspill
	LD	IY,(HL)
	LD	HL,(IX+-61)	; unspill
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IY+11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-17)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,39
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-40)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
	INC	(IX+-1)
;  236	    }
L_69:
	LD	A,(IX+-28)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	INC	BC
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	OR	A,A
	SBC	HL,BC
	JP	M,L_67
;  237	    
;  238	    for (i = 0; i < b->children[1]->child_count; i++) {
	LD	(IX+-1),0
	JR	L_73
L_71:
;  239	        append_child(b_coefficients, new_expression(EXPT_STRUCTURE, EXPI_POLYNOMIAL_DENSE, 2,
;  240	                                                    copy_expression(z),
;  241	                                                    new_expression(EXPT_STRUCTURE, EXPI_LIST, 1,
;  242	                                                                   copy_expression(b->children[1]->children[i]))));
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	IY,(IX+-37)
	LD	IY,(IY)
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IY+11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,1
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-17)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,39
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-43)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
	INC	(IX+-1)
;  243	    }
L_73:
	LD	IY,(IX+-8)
	LD	IY,(IY+11)
	LEA	BC,IY+3
	LD	(IX+-37),BC
	LD	HL,BC
	LD	IY,(HL)
	LD	A,(IX+-1)
	CP	A,(IY+10)
	JR	C,L_71
;  244	    
;  245	    calculate_resultant(&resultant, a_coefficients, b_coefficients);
	LD	BC,(IX+-43)
	PUSH	BC
	LD	BC,(IX+-40)
	PUSH	BC
	PEA	IX+-55
	CALL	_calculate_resultant
	POP	BC
	POP	BC
	POP	BC
;  246	    simplify(resultant, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-55)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  247	    primitive_part = copy_expression(resultant);
	LD	BC,(IX+-55)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-20),HL
;  248	    
;  249	    if (primitive_part != NULL) {
	CALL	__icmpzero
	JR	Z,L_77
;  250	        make_monic(primitive_part);
	LD	BC,(IX+-20)
	PUSH	BC
	CALL	_make_monic
	POP	BC
;  251	    }
L_77:
;  252	    
;  253	    factor_square_free(primitive_part);
	LD	BC,(IX+-20)
	PUSH	BC
	CALL	_factor_square_free
	POP	BC
;  254	    
;  255	    for (i = 0; i < primitive_part->child_count; i++) {
	LD	(IX+-1),0
	JR	L_88
L_86:
;  256	        
;  257	        factor = primitive_part->children[0];
	LD	IY,(IX+-20)
	LD	HL,(IY+11)
	LD	BC,(HL)
	LD	(IX+-26),BC
;  258	        
;  259	        if (literal_to_double(factor->children[0]) == 1) {
	LD	IY,(IX+-26)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	BC,8388608
	LD	A,63
	CALL	__fcmp
	JR	Z,L_87
;  260	            continue;
;  261	        }
;  262	        
;  263	        factor_degree = factor->children[0]->children[1]->child_count - 1;
	LD	IY,(IX+-26)
	LD	BC,(IY+11)
	LD	(IX+-46),BC
	LD	HL,BC
	LD	IY,(HL)
	LD	IY,(IY+11)
	LD	IY,(IY+3)
	LD	A,(IY+10)
	DEC	A
	LD	(IX+-27),A
;  264	        
;  265	        if (factor_degree <= 2) {
	LD	A,2
	CP	A,(IX+-27)
	JR	C,L_87
;  266	            
;  267	            any_expression_to_expression_recursive(factor->children[0]);
	LD	HL,(IX+-46)
	LD	BC,(HL)
	PUSH	BC
	CALL	_any_expression_to_expression_recursive
	POP	BC
;  268	            any_expression_to_expression_recursive(a);
	LD	BC,(IX+-5)
	PUSH	BC
	CALL	_any_expression_to_expression_recursive
	POP	BC
;  269	            any_expression_to_expression_recursive(b);
	LD	BC,(IX+-8)
	PUSH	BC
	CALL	_any_expression_to_expression_recursive
	POP	BC
;  270	            any_expression_to_expression_recursive(b_derivative);
	LD	BC,(IX+-11)
	PUSH	BC
	CALL	_any_expression_to_expression_recursive
	POP	BC
;  271	            
;  272	            equation = new_expression(EXPT_OPERATION, EXPI_EQUATION, 2,
;  273	                                      factor->children[0],
;  274	                                      new_literal(1, 0, 1));
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+-26)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,4
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-23),HL
;  275	            solve(equation, NULL);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-23)
	PUSH	BC
	CALL	_solve
	POP	BC
	POP	BC
;  276	            embed_in_list_if_necessary(equation);
	LD	BC,(IX+-23)
	PUSH	BC
	CALL	_embed_in_list_if_necessary
	POP	BC
;  277	            
;  278	            for (j = 0; j < equation->child_count; j++) {
	LD	(IX+-2),0
	JR	L_84
L_82:
;  279	                
;  280	                temp = new_expression(EXPT_OPERATION, EXPI_ADDITION, 2,
;  281	                                      new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 3,
;  282	                                                     new_literal(-1, 1, 1),
;  283	                                                     copy_expression(equation->children[j]->children[1]),
;  284	                                                     copy_expression(b_derivative)),
;  285	                                      copy_expression(a));
	LD	BC,(IX+-5)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-11)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	A,(IX+-2)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+-23)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,16777215
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,3
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-31),HL
;  286	                
;  287	                simplify(temp, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-31)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  288	                
;  289	                any_expression_to_sparse_polynomial(temp, NULL);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-31)
	PUSH	BC
	CALL	_any_expression_to_sparse_polynomial
	POP	BC
	POP	BC
;  290	                poly_GCD(&gcd, temp, copy_expression(source->children[1]));
	LD	IY,(IX+6)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-31)
	PUSH	BC
	PEA	IX+-52
	CALL	_poly_GCD
	POP	BC
	POP	BC
	POP	BC
;  291	                any_expression_to_expression_recursive(gcd);
	LD	BC,(IX+-52)
	PUSH	BC
	CALL	_any_expression_to_expression_recursive
	POP	BC
;  292	                
;  293	                append_child(result, new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
;  294	                                                    new_expression(EXPT_FUNCTION, EXPI_LN, 1, copy_expression(gcd)),
;  295	                                                    copy_expression(equation->children[j]->children[1])));
	LD	A,(IX+-2)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+-23)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-52)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,1
	PUSH	BC
	LD	BC,11
	PUSH	BC
	LD	BC,3
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-34)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
	INC	(IX+-2)
;  296	                
;  297	                
;  298	            }
L_84:
	LD	A,(IX+-2)
	LD	IY,(IX+-23)
	CP	A,(IY+10)
	JR	C,L_82
;  299	            
;  300	        }
;  301	        
;  302	    }
L_87:
	INC	(IX+-1)
L_88:
	LD	A,(IX+-1)
	LD	IY,(IX+-20)
	CP	A,(IY+10)
	JR	C,L_86
;  303	    
;  304	    simplify(result, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-34)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  305	    
;  306	    replace_expression(source, result);
	LD	BC,(IX+-34)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  307	    
;  308	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _rothstein_trager_method ***************************
;Name                         Addr/Register   Size   Type
;_replace_expression                 IMPORT  -----   function
;_poly_GCD                           IMPORT  -----   function
;_embed_in_list_if_necessary         IMPORT  -----   function
;_solve                              IMPORT  -----   function
;_any_expression_to_expression_recursive      IMPORT  -----   function
;_literal_to_double                  IMPORT  -----   function
;_factor_square_free                 IMPORT  -----   function
;_make_monic                         IMPORT  -----   function
;_calculate_resultant                IMPORT  -----   function
;_any_expression_to_dense_polynomial      IMPORT  -----   function
;_max                                IMPORT  -----   function
;_any_expression_to_expression       IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;_any_expression_to_sparse_polynomial      IMPORT  -----   function
;_simplify                           IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_derivative                         IMPORT  -----   function
;_new_symbol                         IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;extentions                           IX-58      3   variable
;resultant                            IX-55      3   variable
;gcd                                  IX-52      3   variable
;resultant_poly                       IX-49      3   variable
;G_6                                  IX-46      3   variable
;b_coefficients                       IX-43      3   variable
;a_coefficients                       IX-40      3   variable
;G_5                                  IX-37      3   variable
;result                               IX-34      3   variable
;temp                                 IX-31      3   variable
;a_degree                             IX-28      1   variable
;factor_degree                        IX-27      1   variable
;factor                               IX-26      3   variable
;equation                             IX-23      3   variable
;primitive_part                       IX-20      3   variable
;z                                    IX-17      3   variable
;b_derivative_negative                IX-14      3   variable
;b_derivative                         IX-11      3   variable
;b                                     IX-8      3   variable
;a                                     IX-5      3   variable
;j                                     IX-2      1   variable
;i                                     IX-1      1   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 76 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__37:
	DB	"EZ"
	DB	0
	SEGMENT CODE
;  309	
;  310	uint8_t risch_integrate_rational_part(expression* source) {
_risch_integrate_rational_part:
	CALL	__frameset0
;  311	    
;  312	    if (source == NULL) return RETS_UNCHANGED;
	LD	HL,(IX+6)
	CALL	__icmpzero
	JR	NZ,L_94
	LD	A,4
	JR	L_95
L_94:
;  313	    
;  314	    if (poly_is_square_free(source->children[1])) {
	LD	IY,(IX+6)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_poly_is_square_free
	POP	BC
	OR	A,A
	JR	Z,L_93
;  315	        rothstein_trager_method(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_rothstein_trager_method
	POP	BC
;  316	        return RETS_CHANGED;
	LD	A,3
	JR	L_95
;  317	    } else {
L_93:
;  318	        return RETS_UNCHANGED;
	LD	A,4
;  319	    }
;  320	    
;  321	}
L_95:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _risch_integrate_rational_part ***************************
;Name                         Addr/Register   Size   Type
;_poly_is_square_free                IMPORT  -----   function
;source                                IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  322	
;  323	uint8_t risch_integrate(expression* source, expression* variable) {
_risch_integrate:
	LD	HL,-22
	CALL	__frameset
;  324	    
;  325	    expression* polynominal_part;
;  326	    expression* rational_part;
;  327	    expression* extensions = new_expression(EXPT_STRUCTURE, EXPI_LIST, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-3),HL
;  328	    expression* last_extension;
;  329	    expression* temp_source = copy_expression(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-22),HL
;  330	    
;  331	    if (!expression_is_risch_integrable(source, variable)) return RETS_UNCHANGED;
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_expression_is_risch_integrable
	POP	BC
	POP	BC
	OR	A,A
	JR	NZ,L_97
	LD	A,4
	JR	L_116
L_97:
;  332	    
;  333	    risch_get_extensions(extensions, temp_source, variable);
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(IX+-22)
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_risch_get_extensions
	POP	BC
	POP	BC
	POP	BC
;  334	    last_extension = (extensions->child_count) ? copy_expression(extensions->children[extensions->child_count - 1]) : NULL;
	LD	IY,(IX+-3)
	LD	A,(IY+10)
	LD	(IX+-7),A
	OR	A,A
	JR	Z,L_100
	LD	A,(IX+-7)
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+-3)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-16),HL
	JR	L_101
L_100:
	LD	BC,0
	LD	(IX+-16),BC
L_101:
	LD	BC,(IX+-16)
	LD	(IX+-19),BC
;  335	    
;  336	    ERROR_CHECK(risch_determine_parts(&polynominal_part, &rational_part, temp_source, (last_extension) ? last_extension->children[0] : variable, extensions));
	LD	HL,BC
	CALL	__icmpzero
	JR	Z,L_104
	LD	IY,(IX+-19)
	LD	HL,(IY+11)
	LD	BC,(HL)
	LD	(IX+-13),BC
	JR	L_105
L_104:
	LD	BC,(IX+9)
	LD	(IX+-13),BC
L_105:
	LD	BC,(IX+-3)
	PUSH	BC
	LD	BC,(IX+-13)
	PUSH	BC
	LD	BC,(IX+-22)
	PUSH	BC
	PEA	IX+-6
	PEA	IX+-10
	CALL	_risch_determine_parts
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	NZ,L_109
	LD	A,1
	JR	L_116
L_109:
;  337	    
;  338	    if (extensions->child_count == 0) {
	LD	IY,(IX+-3)
	LD	A,(IY+10)
	OR	A,A
	JR	NZ,L_108
;  339	        risch_integrate_polynominal_part(polynominal_part);
	LD	BC,(IX+-10)
	PUSH	BC
	CALL	_risch_integrate_polynominal_part
	POP	BC
;  340	        risch_integrate_rational_part(rational_part);
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_risch_integrate_rational_part
	POP	BC
;  341	    } else {
	JR	L_114
L_108:
;  342	        return RETS_UNCHANGED;
	LD	A,4
	JR	L_116
;  343	    }
L_114:
;  344	
;  345	    if (polynominal_part == NULL) {
	LD	HL,(IX+-10)
	CALL	__icmpzero
	JR	NZ,L_113
;  346	        replace_expression(source, rational_part);
	LD	BC,(IX+-6)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  347	    } else if (rational_part == NULL) {
	JR	L_115
L_113:
	LD	HL,(IX+-6)
	CALL	__icmpzero
	JR	NZ,L_111
;  348	        replace_expression(source, polynominal_part);
	LD	BC,(IX+-10)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  349	    } else {
	JR	L_115
L_111:
;  350	        replace_expression(source, new_expression(EXPT_OPERATION, EXPI_ADDITION, 2,
;  351	                                                  polynominal_part,
;  352	                                                  rational_part));
	LD	BC,(IX+-6)
	PUSH	BC
	LD	BC,(IX+-10)
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  353	    }
L_115:
;  354	    
;  355	    simplify(source, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  356	    
;  357	    return RETS_SUCCESS;
	LD	A,2
;  358	    
;  359	}
L_116:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _risch_integrate ***************************
;Name                         Addr/Register   Size   Type
;_simplify                           IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;temp_source                          IX-22      3   variable
;last_extension                       IX-19      3   variable
;temp98                               IX-16      3   variable
;temp102                              IX-13      3   variable
;polynominal_part                     IX-10      3   variable
;G_7                                   IX-7      1   variable
;rational_part                         IX-6      3   variable
;extensions                            IX-3      3   variable
;variable                              IX+9      3   parameter
;source                                IX+6      3   parameter


; Stack Frame Size: 34 (bytes)
;       Spill Code: 0 (instruction)


;  360	
;  361	uint8_t antiderivative(expression** result, expression* source, expression* variable, bool persistent) {
_antiderivative:
	LD	HL,-4
	CALL	__frameset
;  362	    
;  363	    uint8_t i;
;  364	    expression* temp_source = copy_expression(source);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-4),HL
;  365	    
;  366	    if (variable == NULL) {
	LD	HL,(IX+12)
	CALL	__icmpzero
	JR	NZ,L_120
;  367	        variable = guess_symbol(source, "", 0);
	LD	BC,0
	PUSH	BC
	LD	BC,L__58
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_guess_symbol
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+12),HL
;  368	        if (variable == NULL) return set_error(ERRD_SYNTAX, ERRI_ARGUMENTS, "");
	CALL	__icmpzero
	JR	NZ,L_120
	LD	BC,L__60
	PUSH	BC
	LD	BC,8
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_set_error
	POP	BC
	POP	BC
	POP	BC
	JR	L_131
;  369	    }
L_120:
;  370	    
;  371	    if (count_occurrences(source, variable, true) == 0) {
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+12)
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_count_occurrences
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	NZ,L_129
;  372	        *result = new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
;  373	                                 copy_expression(source),
;  374	                                 copy_expression(variable));
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+6)
	LD	(IY),HL
;  375	        simplify(*result, true);
	LD	BC,1
	PUSH	BC
	LD	HL,(IX+6)
	LD	BC,(HL)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  376	        return RETS_SUCCESS;
	LD	A,2
	JR	L_131
;  377	    }
L_129:
;  378	    
;  379	    if (temp_source->identifier == EXPI_ADDITION) {
	LD	IY,(IX+-4)
	LD	HL,(IY+3)
	LD	BC,5
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_128
;  380	        for (i = 0; i < temp_source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_125
L_123:
;  381	            ERROR_CHECK(risch_integrate(temp_source->children[i], variable));
	LD	BC,(IX+12)
	PUSH	BC
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	LD	IY,(IX+-4)
	LD	BC,(IY+11)
	ADD	HL,DE
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_risch_integrate
	POP	BC
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	NZ,L_124
	LD	A,1
	JR	L_131
;  382	        }
L_124:
	INC	(IX+-1)
L_125:
	LD	A,(IX+-1)
	LD	IY,(IX+-4)
	CP	A,(IY+10)
	JR	C,L_123
	JR	L_130
;  383	    } else {
L_128:
;  384	        ERROR_CHECK(risch_integrate(temp_source, variable));
	LD	BC,(IX+12)
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_risch_integrate
	POP	BC
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	NZ,L_130
	LD	A,1
	JR	L_131
;  385	    }
L_130:
;  386	    
;  387	    *result = temp_source;
	LD	HL,(IX+6)
	LD	BC,(IX+-4)
	LD	(HL),BC
;  388	    
;  389	    return RETS_SUCCESS;
	LD	A,2
;  390	    
;  391	}
L_131:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _antiderivative ***************************
;Name                         Addr/Register   Size   Type
;_simplify                           IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;_count_occurrences                  IMPORT  -----   function
;_set_error                          IMPORT  -----   function
;_guess_symbol                       IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;temp_source                           IX-4      3   variable
;i                                     IX-1      1   variable
;persistent                           IX+15      1   parameter
;variable                             IX+12      3   parameter
;source                                IX+9      3   parameter
;result                                IX+6      3   parameter


; Stack Frame Size: 22 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__58:
	DB	0
L__60:
	DB	0
	SEGMENT CODE
;  392	
;  393	uint8_t definite_integral(expression** result, expression* source, expression* variable, expression* lower_bound, expression* upper_bound) {
_definite_integral:
	LD	HL,-9
	CALL	__frameset
;  394	    
;  395	    expression* temp_source;
;  396	    expression* upper_bound_value;
;  397	    expression* lower_bound_value;
;  398	    
;  399	    if (variable == NULL) {
	LD	HL,(IX+12)
	CALL	__icmpzero
	JR	NZ,L_133
;  400	        variable = guess_symbol(source, "", 0);
	LD	BC,0
	PUSH	BC
	LD	BC,L__68
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_guess_symbol
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+12),HL
;  401	    }
L_133:
;  402	    
;  403	    antiderivative(&temp_source, source, variable, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+12)
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	PEA	IX+-3
	CALL	_antiderivative
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  404	    
;  405	    upper_bound_value = copy_expression(temp_source);
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-6),HL
;  406	    lower_bound_value = copy_expression(temp_source);
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-9),HL
;  407	    
;  408	    replace_occurences(upper_bound_value, variable, upper_bound);
	LD	BC,(IX+18)
	PUSH	BC
	LD	BC,(IX+12)
	PUSH	BC
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_replace_occurences
	POP	BC
	POP	BC
	POP	BC
;  409	    replace_occurences(lower_bound_value, variable, lower_bound);
	LD	BC,(IX+15)
	PUSH	BC
	LD	BC,(IX+12)
	PUSH	BC
	LD	BC,(IX+-9)
	PUSH	BC
	CALL	_replace_occurences
	POP	BC
	POP	BC
	POP	BC
;  410	    
;  411	    *result = new_expression(EXPT_OPERATION, EXPI_SUBTRACTION, 2,
;  412	                             upper_bound_value,
;  413	                             lower_bound_value);
	LD	BC,(IX+-9)
	PUSH	BC
	LD	BC,(IX+-6)
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,6
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+6)
	LD	(IY),HL
;  414	    
;  415	    ERROR_CHECK(simplify(*result, true));
	LD	BC,1
	PUSH	BC
	LD	HL,(IX+6)
	LD	BC,(HL)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	NZ,L_135
	LD	A,1
	JR	L_136
L_135:
;  416	    
;  417	    return RETS_SUCCESS;
	LD	A,2
;  418	    
;  419	}
L_136:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _definite_integral ***************************
;Name                         Addr/Register   Size   Type
;_simplify                           IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;_replace_occurences                 IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_antiderivative                     IMPORT  -----   function
;_guess_symbol                       IMPORT  -----   function
;lower_bound_value                     IX-9      3   variable
;upper_bound_value                     IX-6      3   variable
;temp_source                           IX-3      3   variable
;upper_bound                          IX+18      3   parameter
;lower_bound                          IX+15      3   parameter
;variable                             IX+12      3   parameter
;source                                IX+9      3   parameter
;result                                IX+6      3   parameter


; Stack Frame Size: 30 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__68:
	DB	0
	XREF _calculate_resultant:ROM
	XREF _derivative:ROM
	XREF _solve:ROM
	XREF _simplify:ROM
	XREF _max:ROM
	XREF _factor_square_free:ROM
	XREF _poly_GCD:ROM
	XREF _make_monic:ROM
	XREF _poly_is_square_free:ROM
	XREF _poly_div:ROM
	XREF _validate_sparse_polynomial:ROM
	XREF _any_expression_to_dense_polynomial:ROM
	XREF _any_expression_to_sparse_polynomial:ROM
	XREF _any_expression_to_expression_recursive:ROM
	XREF _any_expression_to_expression:ROM
	XREF _literal_to_double:ROM
	XREF _guess_symbol:ROM
	XREF _replace_occurences:ROM
	XREF _embed_in_list_if_necessary:ROM
	XREF _count_occurrences:ROM
	XREF _expression_is_reziprocal:ROM
	XREF _expression_contains_division:ROM
	XREF _append_child:ROM
	XREF _free_expression:ROM
	XREF _replace_expression:ROM
	XREF _copy_expression:ROM
	XREF _new_symbol:ROM
	XREF _new_literal:ROM
	XREF _new_expression:ROM
	XREF _itoa:ROM
	XREF _set_error:ROM
	XREF _strlen:ROM
	XREF __lcmpu:ROM
	XREF __fcmp:ROM
	XREF __frameset0:ROM
	XREF __frameset:ROM
	XREF __icmpzero:ROM
	XDEF _definite_integral
	XDEF _antiderivative
	XDEF _risch_integrate
	XDEF _risch_integrate_rational_part
	XDEF _rothstein_trager_method
	XDEF _risch_integrate_polynominal_part
	XDEF _risch_determine_parts
	XDEF _risch_get_extensions
	XDEF _expression_is_risch_integrable
	END
