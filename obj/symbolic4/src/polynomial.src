; Zilog eZ80 ANSI C Compiler Release 3.4
; -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"SRC\SYMBOLIC4\SRC\POLYNOMIAL.C"
	.assume ADL=1
	SEGMENT CODE
;    1	
;    2	/*
;    3	 
;    4	 Copyright (c) 2019 Hannes Eberhard
;    5	 
;    6	 Permission is hereby granted, free of charge, to any person obtaining a copy
;    7	 of this software and associated documentation files (the "Software"), to deal
;    8	 in the Software without restriction, including without limitation the rights
;    9	 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
;   10	 copies of the Software, and to permit persons to whom the Software is
;   11	 furnished to do so, subject to the following conditions:
;   12	 
;   13	 The above copyright notice and this permission notice shall be included in all
;   14	 copies or substantial portions of the Software.
;   15	 
;   16	 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;   17	 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;   18	 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;   19	 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;   20	 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;   21	 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;   22	 SOFTWARE.
;   23	 
;   24	 */
;   25	
;   26	#include "symbolic4.h"
;   27	
;   28	return_status expression_to_sparse_polynomial(expression* source, expression* variable);
;   29	void sparse_polynomial_to_expression(expression* source);
;   30	return_status sparse_polynomial_to_dense_polynomial(expression* source);
;   31	void dense_polynomial_to_sparse_polynomial(expression* source);
;   32	
;   33	void any_expression_to_expression(expression* source) {
_any_expression_to_expression:
	LD	HL,-3
	CALL	__frameset
;   34	    if (source->identifier == EXPI_POLYNOMIAL_SPARSE) {
	LD	IY,(IX+6)
	LD	BC,(IY+3)
	LD	(IX+-3),BC
	LD	HL,BC
	LD	BC,38
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_3
;   35	        sparse_polynomial_to_expression(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_sparse_polynomial_to_expression
	POP	BC
;   36	    } else if (source->identifier == EXPI_POLYNOMIAL_DENSE) {
	JR	L_4
L_3:
	LD	BC,39
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_4
;   37	        dense_polynomial_to_sparse_polynomial(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_dense_polynomial_to_sparse_polynomial
	POP	BC
;   38	        sparse_polynomial_to_expression(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_sparse_polynomial_to_expression
	POP	BC
;   39	    } else {
;   40	        return;
;   41	    }
;   42	}
L_4:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _any_expression_to_expression ***************************
;Name                         Addr/Register   Size   Type
;_dense_polynomial_to_sparse_polynomial      IMPORT  -----   function
;_sparse_polynomial_to_expression      IMPORT  -----   function
;G_0                                   IX-3      3   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


;   43	
;   44	void any_expression_to_expression_recursive(expression* source) {
_any_expression_to_expression_recursive:
	LD	HL,-4
	CALL	__frameset
;   45	    uint8_t i;
;   46	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_10
L_8:
;   47	        if (source->children[i] == NULL) continue;
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	ADD	HL,DE
	ADD	HL,BC
	LD	(IX+-4),HL
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_9
;   48	        any_expression_to_expression_recursive(source->children[i]);
	LD	HL,(IX+-4)
	LD	BC,(HL)
	PUSH	BC
	CALL	_any_expression_to_expression_recursive
	POP	BC
;   49	    }
L_9:
	INC	(IX+-1)
L_10:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_8
;   50	    any_expression_to_expression(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_any_expression_to_expression
	POP	BC
;   51	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _any_expression_to_expression_recursive ***************************
;Name                         Addr/Register   Size   Type
;_any_expression_to_expression       IMPORT  -----   function
;G_1                                   IX-4      3   variable
;i                                     IX-1      1   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 13 (bytes)
;       Spill Code: 0 (instruction)


;   52	
;   53	return_status any_expression_to_sparse_polynomial(expression* source, expression* variable) {
_any_expression_to_sparse_polynomial:
	LD	HL,-3
	CALL	__frameset
;   54	    if (source->identifier == EXPI_POLYNOMIAL_SPARSE) {
	LD	IY,(IX+6)
	LD	BC,(IY+3)
	LD	(IX+-3),BC
	LD	HL,BC
	LD	BC,38
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_17
;   55	        return RETS_SUCCESS;
	LD	HL,2
	JR	L_19
;   56	    } else if (source->identifier == EXPI_POLYNOMIAL_DENSE) {
L_17:
	LD	BC,39
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_15
;   57	        dense_polynomial_to_sparse_polynomial(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_dense_polynomial_to_sparse_polynomial
	POP	BC
;   58	    } else {
	JR	L_18
L_15:
;   59	        ERROR_CHECK(expression_to_sparse_polynomial(source, variable));
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_expression_to_sparse_polynomial
	POP	BC
	POP	BC
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_18
	LD	HL,1
	JR	L_19
;   60	    }
L_18:
;   61	    
;   62	    return RETS_SUCCESS;
	LD	HL,2
;   63	    
;   64	}
L_19:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _any_expression_to_sparse_polynomial ***************************
;Name                         Addr/Register   Size   Type
;_expression_to_sparse_polynomial      IMPORT  -----   function
;_dense_polynomial_to_sparse_polynomial      IMPORT  -----   function
;G_2                                   IX-3      3   variable
;variable                              IX+9      3   parameter
;source                                IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


;   65	
;   66	return_status any_expression_to_dense_polynomial(expression* source, expression* variable) {
_any_expression_to_dense_polynomial:
	LD	HL,-3
	CALL	__frameset
;   67	    
;   68	    if (source->identifier == EXPI_POLYNOMIAL_SPARSE) {
	LD	IY,(IX+6)
	LD	BC,(IY+3)
	LD	(IX+-3),BC
	LD	HL,BC
	LD	BC,38
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_27
;   69	        ERROR_CHECK(sparse_polynomial_to_dense_polynomial(source));
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_sparse_polynomial_to_dense_polynomial
	POP	BC
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_28
	LD	HL,1
	JR	L_29
;   70	    } else if (source->identifier == EXPI_POLYNOMIAL_DENSE) {
L_27:
	LD	BC,39
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_25
;   71	        return RETS_SUCCESS;
	LD	HL,2
	JR	L_29
;   72	    } else {
L_25:
;   73	        ERROR_CHECK(expression_to_sparse_polynomial(source, variable));
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_expression_to_sparse_polynomial
	POP	BC
	POP	BC
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_23
	LD	HL,1
	JR	L_29
L_23:
;   74	        ERROR_CHECK(sparse_polynomial_to_dense_polynomial(source));
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_sparse_polynomial_to_dense_polynomial
	POP	BC
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_28
	LD	HL,1
	JR	L_29
;   75	    }
L_28:
;   76	    
;   77	    return RETS_SUCCESS;
	LD	HL,2
;   78	    
;   79	}
L_29:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _any_expression_to_dense_polynomial ***************************
;Name                         Addr/Register   Size   Type
;_expression_to_sparse_polynomial      IMPORT  -----   function
;_sparse_polynomial_to_dense_polynomial      IMPORT  -----   function
;G_3                                   IX-3      3   variable
;variable                              IX+9      3   parameter
;source                                IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


;   80	
;   81	return_status validate_sparse_polynomial(expression* source, bool allow_decimal_exponents, bool allow_negative_exponents, bool allow_arbitrary_base) {
_validate_sparse_polynomial:
	LD	HL,-26
	CALL	__frameset
;   82	    
;   83	    uint8_t i;
;   84	    expression* temp_base = NULL;
	LD	BC,0
	LD	(IX+-4),BC
;   85	    
;   86	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_34
L_32:
;   87	        if (source->children[i]->children[2] != NULL) {
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	IY,IY+6
	LD	(IX+-23),IY
	LD	HL,(IX+-23)
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_33
;   88	            temp_base = copy_expression(source->children[i]->children[2]);
	LD	HL,(IX+-23)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-4),HL
;   89	            break;
	JR	L_36
;   90	        }
;   91	    }
L_33:
	INC	(IX+-1)
L_34:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_32
L_36:
;   92	    
;   93	    if (temp_base == NULL) temp_base = new_symbol(EXPI_SYMBOL, "x");
	LD	HL,(IX+-4)
	CALL	__icmpzero
	JR	NZ,L_55
	LD	BC,L__19
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	LD	(IX+-4),HL
L_55:
;   94	    
;   95	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_54
L_52:
;   96	        
;   97	        if (source->children[i]->children[2] == NULL) {
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-14),BC
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	(IX+-26),HL
	LD	BC,(IX+-14)
	ADD	HL,BC
	LD	IY,(HL)
	LD	BC,(IY+11)
	LD	(IX+-7),BC
	LD	IY,(IX+-7)
	LEA	IY,IY+6
	LD	(IX+-10),IY
	LD	(IX+-17),IY
	LD	HL,(IX+-10)
	LD	HL,(HL)
	CALL	__icmpzero
	JR	NZ,L_42
;   98	            source->children[i]->children[2] = copy_expression(temp_base);
	LD	BC,(IX+-10)
	LD	(IX+-17),BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	IY,(IX+-10)
	LD	(IY),HL
;   99	        }
L_42:
;  100	        
;  101	        if (source->children[i]->children[0]->identifier == EXPI_LITERAL &&
	LD	BC,(IX+-7)
	LD	(IX+-20),BC
	LD	HL,(IX+-7)
	LD	IY,(HL)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	Z,L__22
	LD	A,1
	JR	L__23
L__22:
	XOR	A,A
L__23:
	LD	(IX+-11),A
	OR	A,A
	JR	NZ,L_46
;  102	            source->children[i]->children[0]->value.numeric.denominator != 1 &&
	LD	BC,(IX+-7)
	LD	(IX+-20),BC
	LD	HL,(IX+-7)
	LD	IY,(HL)
	LD	HL,(IY+18)
	LD	E,(IY+21)
	LD	BC,1
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_46
;  103	            !allow_decimal_exponents) {
	LD	A,(IX+9)
	OR	A,A
	JR	NZ,L_46
;  104	            free_expression(temp_base, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  105	            return RETS_ERROR;
	LD	HL,1
	JR	L_57
;  106	        }
L_46:
;  107	        
;  108	        if (source->children[i]->children[0]->identifier == EXPI_LITERAL &&
	LD	A,(IX+-11)
	OR	A,A
	JR	NZ,L_49
;  109	            source->children[i]->children[0]->sign == -1 &&
	LD	HL,(IX+-20)
	LD	IY,(HL)
	LD	A,(IY+6)
	CP	A,-1
	JR	NZ,L_49
;  110	            !allow_negative_exponents) {
	LD	A,(IX+12)
	OR	A,A
	JR	NZ,L_49
;  111	            free_expression(temp_base, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  112	            return RETS_ERROR;
	LD	HL,1
	JR	L_57
;  113	        }
L_49:
;  114	        
;  115	        if (source->children[i]->children[2]->identifier != EXPI_SYMBOL && !allow_arbitrary_base) {
	LD	HL,(IX+-17)
	LD	IY,(HL)
	LD	HL,(IY+3)
	LD	BC,2
	OR	A,A
	SBC	HL,BC
	JR	Z,L_51
	LD	A,(IX+15)
	OR	A,A
	JR	NZ,L_51
;  116	            free_expression(temp_base, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  117	            return RETS_ERROR;
	LD	HL,1
	JR	L_57
;  118	        }
L_51:
;  119	        
;  120	        if (!expressions_are_identical(source->children[i]->children[2], source->children[0]->children[2], true)) {
	LD	BC,1
	PUSH	BC
	LD	HL,(IX+-14)
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+6
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+-26)
	LD	HL,(IX+-14)
	ADD	HL,BC
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+6
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_identical
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	NZ,L_53
;  121	            free_expression(temp_base, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  122	            return RETS_ERROR;
	LD	HL,1
	JR	L_57
;  123	        }
;  124	        
;  125	    }
L_53:
	INC	(IX+-1)
L_54:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_52
;  126	    
;  127	    free_expression(temp_base, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  128	    
;  129	    return RETS_SUCCESS;
	LD	HL,2
;  130	    
;  131	}
L_57:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _validate_sparse_polynomial ***************************
;Name                         Addr/Register   Size   Type
;_expressions_are_identical          IMPORT  -----   function
;_free_expression                    IMPORT  -----   function
;_new_symbol                         IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;G_12                                 IX-26      3   variable
;G_4                                  IX-23      3   variable
;G_9                                  IX-20      3   variable
;G_10                                 IX-17      3   variable
;G_11                                 IX-14      3   variable
;G_8                                  IX-11      1   variable
;G_5                                  IX-10      3   variable
;G_6                                   IX-7      3   variable
;temp_base                             IX-4      3   variable
;i                                     IX-1      1   variable
;allow_arbitrary_base                 IX+15      1   parameter
;allow_negative_exponents             IX+12      1   parameter
;allow_decimal_exponents               IX+9      1   parameter
;source                                IX+6      3   parameter


; Stack Frame Size: 44 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__19:
	DB	"x"
	DB	0
	SEGMENT CODE
;  132	
;  133	void sort_sparse_polynomial(expression* source) {
_sort_sparse_polynomial:
	LD	HL,-19
	CALL	__frameset
;  134	    
;  135	    uint8_t i, j;
;  136	    uint8_t hightest_exponent_index = 0;
	LD	(IX+-3),0
;  137	    double hightest_exponent_value;
;  138	    expression* result = new_expression(EXPT_STRUCTURE, EXPI_POLYNOMIAL_SPARSE, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,38
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-15),HL
;  139	    
;  140	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-2),0
	JR	L_69
L_67:
;  141	        
;  142	        hightest_exponent_value = -1000000;
	LD	BC,7611392
	LD	(IX+-19),BC
	LD	A,201
	LD	(IX+-16),A
;  143	        
;  144	        for (j = 0; j < source->child_count; j++) {
	LD	(IX+-1),0
	JR	L_65
L_63:
;  145	            if (source->children[j] == NULL) continue;
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	(IX+-12),HL
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	ADD	HL,BC
	LD	(IX+-6),HL
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_64
;  146	            if (literal_to_double(source->children[j]->children[0]) >= hightest_exponent_value) {
	LD	HL,(IX+-6)
	LD	IY,(HL)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	BC,(IX+-19)
	LD	A,(IX+-16)
	CALL	__fcmp
	JP	M,L_64
;  147	                hightest_exponent_index = j;
	LD	A,(IX+-1)
	LD	(IX+-3),A
;  148	                hightest_exponent_value = literal_to_double(source->children[j]->children[0]);
	LD	BC,(IX+-12)
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	IY,(HL)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	(IX+-19),HL
	LD	(IX+-16),E
;  149	            }
;  150	        }
L_64:
	INC	(IX+-1)
L_65:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_63
;  151	        
;  152	        append_child(result, source->children[hightest_exponent_index]);
	LD	A,(IX+-3)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	(IX+-9),HL
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+-15)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  153	        source->children[hightest_exponent_index] = NULL;
	LD	BC,(IX+-9)
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	BC,0
	LD	(HL),BC
	INC	(IX+-2)
;  154	        
;  155	    }
L_69:
	LD	A,(IX+-2)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_67
;  156	    
;  157	    replace_expression(source, result);
	LD	BC,(IX+-15)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  158	    
;  159	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _sort_sparse_polynomial ***************************
;Name                         Addr/Register   Size   Type
;_replace_expression                 IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;_literal_to_double                  IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;hightest_exponent_value              IX-19      4   variable
;result                               IX-15      3   variable
;G_14                                 IX-12      3   variable
;G_15                                  IX-9      3   variable
;G_13                                  IX-6      3   variable
;hightest_exponent_index               IX-3      1   variable
;i                                     IX-2      1   variable
;j                                     IX-1      1   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 28 (bytes)
;       Spill Code: 0 (instruction)


;  160	
;  161	void expression_to_sparse_polynomial_term(expression* source, expression* variable) {
_expression_to_sparse_polynomial_term:
	LD	HL,-10
	CALL	__frameset
;  162	    
;  163	    uint8_t i;
;  164	    expression* result;
;  165	    
;  166	    if (count_occurrences(source, variable, true) == 0) {
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_count_occurrences
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	NZ,L_73
;  167	        result = new_expression(EXPT_STRUCTURE, EXPI_LIST, 3,
;  168	                                new_literal(1, 0, 1),
;  169	                                copy_expression(source),
;  170	                                copy_expression(variable));
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,3
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-3),HL
;  171	        replace_expression(source, result);
	LD	BC,HL
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  172	        return;
	JR	L_88
;  173	    }
L_73:
;  174	    
;  175	    result = new_expression(EXPT_STRUCTURE, EXPI_LIST, 3,
;  176	                            NULL,
;  177	                            NULL,
;  178	                            NULL);
	LD	BC,0
	PUSH	BC
	PUSH	BC
	PUSH	BC
	LD	BC,3
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-3),HL
;  179	    
;  180	    if (source->identifier == EXPI_MULTIPLICATION) {
	LD	IY,(IX+6)
	LD	HL,(IY+3)
	LD	BC,7
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_83
;  181	        result->children[1] = new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+-3)
	LD	IY,(IY+11)
	LD	(IY+3),HL
;  182	        for (i = 0; i < source->child_count; i++) {
	LD	(IX+-4),0
	JR	L_80
L_78:
;  183	            if (source->children[i] == NULL) continue;
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	(IX+-7),HL
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	ADD	HL,BC
	LD	(IX+-10),HL
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_79
;  184	            if (count_occurrences(source->children[i], variable, true) == 0) {
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	LD	HL,(IX+-10)
	LD	BC,(HL)
	PUSH	BC
	CALL	_count_occurrences
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	NZ,L_79
;  185	                append_child(result->children[1], source->children[i]);
	LD	BC,(IX+-7)
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	IY,(IX+-3)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  186	                source->children[i] = NULL;
	LD	BC,(IX+-7)
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	BC,0
	LD	(HL),BC
;  187	            }
;  188	        }
L_79:
	INC	(IX+-4)
L_80:
	LD	A,(IX+-4)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_78
;  189	        simplify(source, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  190	        simplify(result->children[1], true);
	LD	BC,1
	PUSH	BC
	LD	IY,(IX+-3)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  191	    } else {
	JR	L_86
L_83:
;  192	        result->children[1] = new_literal(1, 1, 1);
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+-3)
	LD	IY,(IY+11)
	LD	(IY+3),HL
;  193	    }
L_86:
;  194	    
;  195	    if (source->identifier == EXPI_EXPONENTATION) {
	LD	IY,(IX+6)
	LD	HL,(IY+3)
	LD	BC,9
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_85
;  196	        result->children[0] = copy_expression(source->children[1]);
	LD	IY,(IX+6)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	IY,(IX+-3)
	LD	IY,(IY+11)
	LD	(IY),HL
;  197	        result->children[2] = copy_expression(source->children[0]);
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	IY,(IX+-3)
	LD	IY,(IY+11)
	LD	(IY+6),HL
;  198	    } else {
	JR	L_87
L_85:
;  199	        result->children[0] = new_literal(1, 1, 1);
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+-3)
	LD	IY,(IY+11)
	LD	(IY),HL
;  200	        result->children[2] = copy_expression(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	IY,(IX+-3)
	LD	IY,(IY+11)
	LD	(IY+6),HL
;  201	    }
L_87:
;  202	    
;  203	    replace_expression(source, result);
	LD	BC,(IX+-3)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  204	    
;  205	    return;
;  206	    
;  207	}
L_88:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _expression_to_sparse_polynomial_term ***************************
;Name                         Addr/Register   Size   Type
;_simplify                           IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;_count_occurrences                  IMPORT  -----   function
;G_16                                 IX-10      3   variable
;G_17                                  IX-7      3   variable
;i                                     IX-4      1   variable
;result                                IX-3      3   variable
;variable                              IX+9      3   parameter
;source                                IX+6      3   parameter


; Stack Frame Size: 22 (bytes)
;       Spill Code: 0 (instruction)


;  208	
;  209	return_status expression_to_sparse_polynomial(expression* source, expression* variable) {
_expression_to_sparse_polynomial:
	LD	HL,-13
	CALL	__frameset
;  210	    
;  211	    uint8_t i;
;  212	    expression* temp_source = copy_expression(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-4),HL
;  213	    expression* result;
;  214	    
;  215	    if (variable == NULL) {
	LD	HL,(IX+9)
	CALL	__icmpzero
	JR	NZ,L_91
;  216	        variable = guess_symbol(source, "", 0);
	LD	BC,0
	PUSH	BC
	LD	BC,L__48
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_guess_symbol
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+9),HL
;  217	        if (variable == NULL) {
	CALL	__icmpzero
	JR	NZ,L_91
;  218	            variable = new_symbol(EXPI_SYMBOL, "x");
	LD	BC,L__50
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	LD	(IX+9),HL
;  219	        }
;  220	    }
L_91:
;  221	    
;  222	    result = new_expression(EXPT_STRUCTURE, EXPI_POLYNOMIAL_SPARSE, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,38
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-7),HL
;  223	    
;  224	    if (temp_source->identifier == EXPI_ADDITION) {
	LD	IY,(IX+-4)
	LD	HL,(IY+3)
	LD	BC,5
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_99
;  225	        for (i = 0; i < temp_source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_97
L_95:
;  226	            if (temp_source->children[i] == NULL) continue;
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	(IX+-13),HL
	LD	IY,(IX+-4)
	LD	BC,(IY+11)
	ADD	HL,BC
	LD	(IX+-10),HL
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_96
;  227	            expression_to_sparse_polynomial_term(temp_source->children[i], variable);
	LD	BC,(IX+9)
	PUSH	BC
	LD	HL,(IX+-10)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expression_to_sparse_polynomial_term
	POP	BC
	POP	BC
;  228	            append_child(result, temp_source->children[i]);
	LD	BC,(IX+-13)
	LD	IY,(IX+-4)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  229	        }
L_96:
	INC	(IX+-1)
L_97:
	LD	A,(IX+-1)
	LD	IY,(IX+-4)
	CP	A,(IY+10)
	JR	C,L_95
	JR	L_102
;  230	    } else {
L_99:
;  231	        simplify(temp_source, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  232	        expression_to_sparse_polynomial_term(temp_source, variable);
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_expression_to_sparse_polynomial_term
	POP	BC
	POP	BC
;  233	        append_child(result, temp_source);
	LD	BC,(IX+-4)
	PUSH	BC
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  234	    }
L_102:
;  235	    
;  236	    if (validate_sparse_polynomial(result, true, true, true) == RETS_ERROR) {
	LD	BC,1
	PUSH	BC
	PUSH	BC
	PUSH	BC
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_validate_sparse_polynomial
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_101
;  237	        free_expression(result, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  238	        return RETS_ERROR;
	LD	HL,1
	JR	L_103
;  239	    } else {
L_101:
;  240	        sort_sparse_polynomial(result);
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_sort_sparse_polynomial
	POP	BC
;  241	        replace_expression(source, result);
	LD	BC,(IX+-7)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  242	        return RETS_SUCCESS;
	LD	HL,2
;  243	    }
;  244	    
;  245	}
L_103:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _expression_to_sparse_polynomial ***************************
;Name                         Addr/Register   Size   Type
;_replace_expression                 IMPORT  -----   function
;_sort_sparse_polynomial             IMPORT  -----   function
;_free_expression                    IMPORT  -----   function
;_validate_sparse_polynomial         IMPORT  -----   function
;_simplify                           IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;_new_symbol                         IMPORT  -----   function
;_guess_symbol                       IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;G_20                                 IX-13      3   variable
;G_19                                 IX-10      3   variable
;result                                IX-7      3   variable
;temp_source                           IX-4      3   variable
;i                                     IX-1      1   variable
;variable                              IX+9      3   parameter
;source                                IX+6      3   parameter


; Stack Frame Size: 25 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__48:
	DB	0
L__50:
	DB	"x"
	DB	0
	SEGMENT CODE
;  246	
;  247	void sparse_polynomial_to_expression(expression* source) {
_sparse_polynomial_to_expression:
	LD	HL,-4
	CALL	__frameset
;  248	    
;  249	    uint8_t i;
;  250	    expression* result = new_expression(EXPT_OPERATION, EXPI_ADDITION, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-4),HL
;  251	    
;  252	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_107
L_105:
;  253	        append_child(result, new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
;  254	                                            copy_expression(source->children[i]->children[1]),
;  255	                                            new_expression(EXPT_OPERATION, EXPI_EXPONENTATION, 2,
;  256	                                                           copy_expression(source->children[i]->children[2]),
;  257	                                                           copy_expression(source->children[i]->children[0]))));
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	IY,(HL)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+6
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,9
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	ADD	HL,BC
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
	INC	(IX+-1)
;  258	    }
L_107:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_105
;  259	    
;  260	//    simplify(result, true);
;  261	    replace_expression(source, result);
	LD	BC,(IX+-4)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  262	    
;  263	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _sparse_polynomial_to_expression ***************************
;Name                         Addr/Register   Size   Type
;_replace_expression                 IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;result                                IX-4      3   variable
;i                                     IX-1      1   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 13 (bytes)
;       Spill Code: 0 (instruction)


;  264	
;  265	return_status sparse_polynomial_to_dense_polynomial(expression* source) {
_sparse_polynomial_to_dense_polynomial:
	LD	HL,-13
	CALL	__frameset
;  266	    
;  267	    uint8_t i;
;  268	    expression* result = new_expression(EXPT_STRUCTURE, EXPI_POLYNOMIAL_DENSE, 2,
;  269	                                        copy_expression(source->children[0]->children[2]),
;  270	                                        new_expression(EXPT_STRUCTURE, EXPI_LIST, 0));
	LD	BC,0
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+6
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,39
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-4),HL
;  271	    
;  272	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_115
L_113:
;  273	        if (source->children[i]->children[0]->identifier != EXPI_LITERAL &&
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	IY,(HL)
	LD	BC,(IY+11)
	LD	(IX+-7),BC
	LD	HL,BC
	LD	IY,(HL)
	LD	HL,(IY+3)
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	Z,L_114
;  274	            source->children[i]->children[0]->value.numeric.denominator != 1) {
	LD	HL,(IX+-7)
	LD	IY,(HL)
	LD	HL,(IY+18)
	LD	E,(IY+21)
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_114
;  275	            free_expression(result, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  276	            return RETS_ERROR;
	LD	HL,1
	JR	L_127
;  277	        }
;  278	    }
L_114:
	INC	(IX+-1)
L_115:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_113
;  279	    
;  280	    for (i = 0; i < source->children[0]->children[0]->value.numeric.numerator + 1; i++) {
	LD	(IX+-1),0
	JR	L_119
L_117:
;  281	        append_child(result->children[1], new_literal(1, 0, 1));
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+-4)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
	INC	(IX+-1)
;  282	    }
L_119:
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	HL,(IY+14)
	LD	E,(IY+17)
	LD	A,1
	CALL	__ladd_b
	LD	BC,HL
	UEXT	HL
	LD	A,E
	LD	E,H
	LD	L,(IX+-1)
	CALL	__lcmpu
	JR	C,L_117
;  283	    
;  284	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_124
L_122:
;  285	        replace_expression(result->children[1]->children[source->children[i]->children[0]->value.numeric.numerator], copy_expression(source->children[i]->children[1]));
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	ADD	HL,DE
	ADD	HL,BC
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	IY,(IX+-4)
	LD	IY,(IY+11)
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	(IX+-10),HL	; spill
	LD	HL,(IY+3)
	LD	(IX+-13),HL	; spill
	LD	HL,(IX+-10)	; unspill
	LD	IY,(IX+6)
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IY+11)
	ADD	HL,BC
	LD	IY,(HL)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	HL,(IY+14)
	LD	E,(IY+17)
	LD	(IX+-10),HL	; spill
	LD	IY,(IX+-13)
	LD	HL,(IX+-10)	; unspill
	XOR	A,A
	LD	BC,3
	CALL	__lmulu
	LD	BC,(IY+11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
	INC	(IX+-1)
;  286	    }
L_124:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_122
;  287	    
;  288	    replace_expression(source, result);
	LD	BC,(IX+-4)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  289	    
;  290	    return RETS_SUCCESS;
	LD	HL,2
;  291	    
;  292	}
L_127:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _sparse_polynomial_to_dense_polynomial ***************************
;Name                         Addr/Register   Size   Type
;_replace_expression                 IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;_free_expression                    IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;G_21                                  IX-7      3   variable
;result                                IX-4      3   variable
;i                                     IX-1      1   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 22 (bytes)
;       Spill Code: -1 (instruction)


;  293	
;  294	void dense_polynomial_to_sparse_polynomial(expression* source) {
_dense_polynomial_to_sparse_polynomial:
	LD	HL,-14
	CALL	__frameset
;  295	    
;  296	    uint8_t i;
;  297	    expression* result = new_expression(EXPT_STRUCTURE, EXPI_POLYNOMIAL_SPARSE, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,38
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-13),HL
;  298	    
;  299	    for (i = 0; i < source->children[1]->child_count; i++) {
	LD	(IX+-1),0
	JR	L_134
L_132:
;  300	        if (source->children[1]->children[i] == 0) continue;
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	IY,(IX+-10)
	LD	IY,(IY)
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IY+11)
	ADD	HL,BC
	LD	(IX+-4),HL
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_133
;  301	        if (source->children[1]->children[i]->value.numeric.numerator != 0) {
	LD	HL,(IX+-4)
	LD	IY,(HL)
	LD	HL,(IY+14)
	LD	E,(IY+17)
	CALL	__lcmpzero
	JR	Z,L_133
;  302	            append_child(result, new_expression(EXPT_STRUCTURE, EXPI_LIST, 3,
;  303	                                                new_literal(1, i, 1),
;  304	                                                copy_expression(source->children[1]->children[i]),
;  305	                                                copy_expression(source->children[0])));
	LD	HL,(IX+-7)
	LD	BC,(HL)
	PUSH	BC
	LD	(IX+-14),A
	CALL	_copy_expression
	LD	A,(IX+-14)
	POP	BC
	PUSH	HL
	LD	HL,(IX+-4)
	LD	BC,(HL)
	PUSH	BC
	LD	(IX+-14),A
	CALL	_copy_expression
	LD	A,(IX+-14)
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	UEXT	HL
	LD	C,H
	LD	B,0
	LD	L,(IX+-1)
	PUSH	BC
	PUSH	HL
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,3
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-13)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  306	        }
;  307	    }
L_133:
	INC	(IX+-1)
L_134:
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-7),BC
	LD	IY,(IX+-7)
	LEA	BC,IY+3
	LD	(IX+-10),BC
	LD	HL,BC
	LD	IY,(HL)
	LD	A,(IX+-1)
	CP	A,(IY+10)
	JR	C,L_132
;  308	    
;  309	    replace_expression(source, result);
	LD	BC,(IX+-13)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  310	    
;  311	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _dense_polynomial_to_sparse_polynomial ***************************
;Name                         Addr/Register   Size   Type
;_replace_expression                 IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;result                               IX-13      3   variable
;G_22                                 IX-10      3   variable
;G_25                                  IX-7      3   variable
;G_23                                  IX-4      3   variable
;i                                     IX-1      1   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 23 (bytes)
;       Spill Code: -1 (instruction)


;  312	
;  313	void quadratic_formula(expression** result, expression* a, expression* b, expression* c) {
_quadratic_formula:
	LD	HL,-6
	CALL	__frameset
;  314	    
;  315	    expression* discriminant;
;  316	    expression* divisor;
;  317	    
;  318	    discriminant = new_expression(EXPT_OPERATION, EXPI_ADDITION, 2,
;  319	                                  new_expression(EXPT_OPERATION, EXPI_EXPONENTATION, 2,
;  320	                                                 copy_expression(b),
;  321	                                                 new_literal(1, 2, 1)),
;  322	                                  new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 3,
;  323	                                                 new_literal(-1, 4, 1),
;  324	                                                 copy_expression(a),
;  325	                                                 copy_expression(c)));
	LD	BC,(IX+15)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,4
	PUSH	BC
	LD	BC,16777215
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,3
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,9
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-3),HL
;  326	    
;  327	    simplify(discriminant, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  328	    
;  329	    divisor = new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
;  330	                             new_literal(1, 2, 1),
;  331	                             copy_expression(a));
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-6),HL
;  332	    
;  333	    simplify(discriminant, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  334	    
;  335	    if (discriminant->identifier == EXPI_LITERAL && discriminant->value.numeric.numerator == 0) {
	LD	IY,(IX+-3)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_139
	LD	IY,(IX+-3)
	LD	HL,(IY+14)
	LD	E,(IY+17)
	CALL	__lcmpzero
	JR	NZ,L_139
;  336	        
;  337	        *result = new_expression(EXPT_STRUCTURE, EXPI_LIST, 1,
;  338	                                 new_expression(EXPT_OPERATION, EXPI_DIVISION, 2,
;  339	                                                new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
;  340	                                                               new_literal(-1, 1, 1),
;  341	                                                               copy_expression(b)),
;  342	                                                copy_expression(divisor)));
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,16777215
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,8
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,1
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+6)
	LD	(IY),HL
;  343	        
;  344	        simplify(*result, true);
	LD	BC,1
	PUSH	BC
	LD	HL,(IX+6)
	LD	BC,(HL)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  345	        
;  346	    } else {
	JR	L_140
L_139:
;  347	        
;  348	        discriminant = new_expression(EXPT_OPERATION, EXPI_EXPONENTATION, 2,
;  349	                                      discriminant,
;  350	                                      new_literal(1, 1, 2));
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-3)
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,9
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-3),HL
;  351	        
;  352	        simplify(discriminant, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  353	        
;  354	        (*result) = new_expression(EXPT_STRUCTURE, EXPI_LIST, 2,
;  355	                                   new_expression(EXPT_OPERATION, EXPI_DIVISION, 2,
;  356	                                                  new_expression(EXPT_OPERATION, EXPI_ADDITION, 2,
;  357	                                                                 new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
;  358	                                                                                copy_expression(b),
;  359	                                                                                new_literal(-1, 1, 1)),
;  360	                                                                 copy_expression(discriminant)),
;  361	                                                  copy_expression(divisor)),
;  362	                                   new_expression(EXPT_OPERATION, EXPI_DIVISION, 2,
;  363	                                                  new_expression(EXPT_OPERATION, EXPI_SUBTRACTION, 2,
;  364	                                                                 new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
;  365	                                                                                copy_expression(b),
;  366	                                                                                new_literal(-1, 1, 1)),
;  367	                                                                 copy_expression(discriminant)),
;  368	                                                  copy_expression(divisor)));
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,16777215
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,6
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,8
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,16777215
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,8
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+6)
	LD	(IY),HL
;  369	        
;  370	        simplify(*result, true);
	LD	BC,1
	PUSH	BC
	LD	HL,(IX+6)
	LD	BC,(HL)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  371	        
;  372	    }
;  373	    
;  374	}
L_140:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _quadratic_formula ***************************
;Name                         Addr/Register   Size   Type
;_simplify                           IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;divisor                               IX-6      3   variable
;discriminant                          IX-3      3   variable
;c                                    IX+15      3   parameter
;b                                    IX+12      3   parameter
;a                                     IX+9      3   parameter
;result                                IX+6      3   parameter


; Stack Frame Size: 24 (bytes)
;       Spill Code: -1 (instruction)


;  375	
;  376	return_status polysolve_quadratic(expression* source) {
_polysolve_quadratic:
	LD	HL,-14
	CALL	__frameset
;  377	    
;  378	    uint8_t i;
;  379	    expression* temp_source = copy_expression(source->children[0]);
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-4),HL
;  380	    expression* temp;
;  381	    expression* result;
;  382	    
;  383	    if (temp_source->child_count > 3) {
	LD	IY,(IX+-4)
	LD	A,(IY+10)
	LD	(IX+-11),A
	LD	A,3
	CP	A,(IX+-11)
	JR	NC,L_143
;  384	        return RETS_ERROR;
	LD	HL,1
	JR	L_155
;  385	    }
L_143:
;  386	    
;  387	    if (temp_source->child_count == 2) {
	LD	A,(IX+-11)
	CP	A,2
	JR	NZ,L_144
;  388	        append_child(temp_source, new_expression(EXPT_STRUCTURE, EXPI_LIST, 3,
;  389	                                                 new_literal(1, 0, 1),
;  390	                                                 new_literal(1, 0, 1),
;  391	                                                 copy_expression(temp_source->children[0]->children[2])));
	LD	IY,(IX+-4)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+6
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,3
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  392	    }
L_144:
;  393	    
;  394	    temp = new_expression(EXPT_OPERATION, EXPI_DIVISION, 2,
;  395	                          copy_expression(temp_source->children[0]->children[0]),
;  396	                          copy_expression(temp_source->children[1]->children[0]));
	LD	IY,(IX+-4)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	IY,(HL)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	IY,(IX+-4)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,8
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-7),HL
;  397	    
;  398	    simplify(temp, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  399	    
;  400	    if (temp->sign != 1) return RETS_ERROR;
	LD	IY,(IX+-7)
	LD	A,(IY+6)
	CP	A,1
	JR	Z,L_147
	LD	HL,1
	JR	L_155
L_147:
;  401	    if (literal_to_double(temp) != 2) return RETS_ERROR;
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	BC,0
	LD	A,64
	CALL	__fcmp
	JR	Z,L_148
	LD	HL,1
	JR	L_155
L_148:
;  402	    
;  403	    free_expression(temp, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  404	    
;  405	    quadratic_formula(&result, temp_source->children[0]->children[1], temp_source->children[1]->children[1], temp_source->children[2]->children[1]);
	LD	IY,(IX+-4)
	LD	BC,(IY+11)
	LD	(IX+-14),BC
	LD	IY,(IX+-14)
	LEA	HL,IY+6
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	LD	IY,(IX+-14)
	LEA	HL,IY+3
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	LD	HL,(IX+-14)
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	PEA	IX+-10
	CALL	_quadratic_formula
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  406	    
;  407	    temp = new_expression(EXPT_OPERATION, EXPI_EXPONENTATION, 2,
;  408	                          copy_expression(temp_source->children[1]->children[2]),
;  409	                          copy_expression(temp_source->children[1]->children[0]));
	LD	IY,(IX+-4)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	IY,(HL)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	IY,(IX+-4)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+6
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,9
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-7),HL
;  410	    
;  411	    simplify(temp, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  412	    
;  413	    for (i = 0; i < result->child_count; i++) {
	LD	(IX+-1),0
	JR	L_153
L_151:
;  414	        
;  415	        replace_expression(result->children[i], new_expression(EXPT_OPERATION, EXPI_EQUATION, 2,
;  416	                                                               copy_expression(temp),
;  417	                                                               copy_expression(result->children[i])));
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+-10)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,4
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	IY,(IX+-10)
	LD	BC,(IY+11)
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  418	        
;  419	        if (temp->identifier != EXPI_SYMBOL) {
	LD	IY,(IX+-7)
	LD	HL,(IY+3)
	LD	BC,2
	OR	A,A
	SBC	HL,BC
	JR	Z,L_152
;  420	            solve(result->children[i], NULL);
	LD	BC,0
	PUSH	BC
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	LD	IY,(IX+-10)
	LD	BC,(IY+11)
	ADD	HL,DE
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_solve
	POP	BC
	POP	BC
;  421	        }
;  422	        
;  423	    }
L_152:
	INC	(IX+-1)
L_153:
	LD	A,(IX+-1)
	LD	IY,(IX+-10)
	CP	A,(IY+10)
	JR	C,L_151
;  424	    
;  425	    free_expression(temp_source, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  426	    free_expression(temp, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  427	    replace_expression(source, result);
	LD	BC,(IX+-10)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  428	    
;  429	    return RETS_SUCCESS;
	LD	HL,2
;  430	    
;  431	}
L_155:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _polysolve_quadratic ***************************
;Name                         Addr/Register   Size   Type
;_solve                              IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;_free_expression                    IMPORT  -----   function
;_literal_to_double                  IMPORT  -----   function
;_simplify                           IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;G_26                                 IX-11      1   variable
;result                               IX-10      3   variable
;temp                                  IX-7      3   variable
;temp_source                           IX-4      3   variable
;i                                     IX-1      1   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 23 (bytes)
;       Spill Code: -1 (instruction)


;  432	
;  433	return_status polysolve(expression* source, expression* variable) {
_polysolve:
	LD	HL,-3
	CALL	__frameset
;  434	    
;  435	    expression* temp_source;
;  436	    
;  437	    if (variable == NULL) {
	LD	HL,(IX+9)
	CALL	__icmpzero
	JR	NZ,L_157
;  438	        variable = guess_symbol(source, "", 0);
	LD	BC,0
	PUSH	BC
	LD	BC,L__79
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_guess_symbol
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+9),HL
;  439	    }
L_157:
;  440	    
;  441	    subtract_rhs(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_subtract_rhs
	POP	BC
;  442	    temp_source = copy_expression(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-3),HL
;  443	    
;  444	    if (expression_to_sparse_polynomial(temp_source->children[0], variable) == RETS_ERROR) {
	LD	BC,(IX+9)
	PUSH	BC
	LD	IY,(IX+-3)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expression_to_sparse_polynomial
	POP	BC
	POP	BC
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_160
;  445	        free_expression(temp_source, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  446	        return RETS_ERROR;
	LD	HL,1
	JR	L_162
;  447	    }
L_160:
;  448	    
;  449	    if (polysolve_quadratic(temp_source) == RETS_ERROR) {
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_polysolve_quadratic
	POP	BC
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_161
;  450	        free_expression(temp_source, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  451	        return RETS_ERROR;
	LD	HL,1
	JR	L_162
;  452	    }
L_161:
;  453	    
;  454	    replace_expression(source, temp_source);
	LD	BC,(IX+-3)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  455	    
;  456	    return RETS_ERROR;
	LD	HL,1
;  457	    
;  458	}
L_162:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _polysolve ***************************
;Name                         Addr/Register   Size   Type
;_replace_expression                 IMPORT  -----   function
;_free_expression                    IMPORT  -----   function
;_expression_to_sparse_polynomial      IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_subtract_rhs                       IMPORT  -----   function
;_guess_symbol                       IMPORT  -----   function
;temp_source                           IX-3      3   variable
;variable                              IX+9      3   parameter
;source                                IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: -1 (instruction)


	SEGMENT STRSECT
L__79:
	DB	0
	SEGMENT CODE
;  459	
;  460	uint8_t poly_div(expression** quotient, expression** remainder, expression* poly, expression* divisor) {
_poly_div:
	LD	HL,-37
	CALL	__frameset
;  461	    
;  462	    uint8_t i;
;  463	    expression* symbol;
;  464	    expression* poly_copy;
;  465	    expression* divisor_copy;
;  466	    expression* poly_degree;
;  467	    expression* divisor_degree;
;  468	    expression* power;
;  469	    expression* coefficient;
;  470	    expression* monominal;
;  471	    expression* temp_poly;
;  472	    expression* temp_quotient;
;  473	    expression* temp_remainder;
;  474	    expression* result;
;  475	    
;  476	    if (poly->identifier == EXPI_POLYNOMIAL_SPARSE) {
	LD	IY,(IX+12)
	LD	HL,(IY+3)
	LD	BC,38
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_166
;  477	        symbol = copy_expression(poly->children[0]->children[2]);
	LD	IY,(IX+12)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+6
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-13),HL
;  478	    } else if (divisor->identifier == EXPI_POLYNOMIAL_SPARSE) {
	JR	L_168
L_166:
	LD	IY,(IX+15)
	LD	HL,(IY+3)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_164
;  479	        symbol = copy_expression(divisor->children[0]->children[2]);
	LD	IY,(IX+15)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+6
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-13),HL
;  480	    } else {
	JR	L_168
L_164:
;  481	        symbol = new_symbol(EXPI_SYMBOL, "x");
	LD	BC,L__85
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	LD	(IX+-13),HL
;  482	    }
L_168:
;  483	    
;  484	    ERROR_CHECK(any_expression_to_sparse_polynomial(poly, symbol));
	LD	BC,(IX+-13)
	PUSH	BC
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_any_expression_to_sparse_polynomial
	POP	BC
	POP	BC
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_170
	LD	A,1
	JR	L_187
L_170:
;  485	    ERROR_CHECK(any_expression_to_sparse_polynomial(divisor, symbol));
	LD	BC,(IX+-13)
	PUSH	BC
	LD	BC,(IX+15)
	PUSH	BC
	CALL	_any_expression_to_sparse_polynomial
	POP	BC
	POP	BC
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_171
	LD	A,1
	JR	L_187
L_171:
;  486	    
;  487	    free_expression(symbol, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-13)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  488	    
;  489	    sort_sparse_polynomial(poly);
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_sort_sparse_polynomial
	POP	BC
;  490	    sort_sparse_polynomial(divisor);
	LD	BC,(IX+15)
	PUSH	BC
	CALL	_sort_sparse_polynomial
	POP	BC
;  491	    
;  492	    poly_copy = copy_expression(poly);
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-37),HL
;  493	    divisor_copy = copy_expression(divisor);
	LD	BC,(IX+15)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-16),HL
;  494	    
;  495	    temp_poly = copy_expression(poly_copy);
	LD	BC,(IX+-37)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-28),HL
;  496	    
;  497	    poly_degree = poly->children[0]->children[0];
	LD	IY,(IX+12)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	HL,(IY+11)
	LD	BC,(HL)
	LD	(IX+-25),BC
;  498	    divisor_degree = divisor->children[0]->children[0];
	LD	IY,(IX+15)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	HL,(IY+11)
	LD	BC,(HL)
	LD	(IX+-31),BC
;  499	    
;  500	    if (!expressions_are_identical(poly->children[0]->children[2], divisor->children[0]->children[2], true)) return RETS_UNCHANGED;
	LD	BC,1
	PUSH	BC
	LD	IY,(IX+15)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+6
	LD	BC,(HL)
	PUSH	BC
	LD	IY,(IX+12)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+6
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_identical
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	NZ,L_173
	LD	A,4
	JR	L_187
L_173:
;  501	    
;  502	    result = new_expression(EXPT_STRUCTURE, EXPI_POLYNOMIAL_SPARSE, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,38
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-7),HL
;  503	    
;  504	    if (expression_is_greater_than(divisor_degree, poly_degree, true)) {
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-25)
	PUSH	BC
	LD	BC,(IX+-31)
	PUSH	BC
	CALL	_expression_is_greater_than
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_175
;  505	        *quotient = new_literal(1, 0, 1);
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+6)
	LD	(IY),HL
;  506	        *remainder = copy_expression(temp_poly);
	LD	BC,(IX+-28)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	IY,(IX+9)
	LD	(IY),HL
;  507	        return RETS_ERROR;
	LD	A,1
	JR	L_187
;  508	    }
L_175:
;  509	    
;  510	    power = new_expression(EXPT_OPERATION, EXPI_ADDITION, 2,
;  511	                           copy_expression(poly_degree),
;  512	                           new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
;  513	                                          copy_expression(divisor_degree),
;  514	                                          new_literal(-1, 1, 1)));
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,16777215
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-31)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-25)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-22),HL
;  515	    
;  516	    simplify(power, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-22)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  517	    
;  518	    if (expression_is_numerical(divisor->children[0]->children[1])) {
	LD	IY,(IX+15)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_expression_is_numerical
	POP	BC
	OR	A,A
	JR	Z,L_177
;  519	        coefficient = new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
;  520	                                     copy_expression(poly->children[0]->children[1]),
;  521	                                     new_expression(EXPT_OPERATION, EXPI_DIVISION, 2,
;  522	                                                    new_literal(1, 1, 1),
;  523	                                                    copy_expression(divisor->children[0]->children[1])));
	LD	IY,(IX+15)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,8
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	IY,(IX+12)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-19),HL
;  524	    } else {
	JR	L_178
L_177:
;  525	        coefficient = NULL;
	LD	BC,0
	LD	(IX+-19),BC
;  526	    }
L_178:
;  527	    
;  528	    simplify(coefficient, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-19)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  529	    
;  530	    monominal = new_expression(EXPT_STRUCTURE, EXPI_POLYNOMIAL_SPARSE, 1,
;  531	                               new_expression(EXPT_STRUCTURE, EXPI_LIST, 3,
;  532	                                              copy_expression(power),
;  533	                                              copy_expression(coefficient),
;  534	                                              copy_expression(poly->children[0]->children[2])));
	LD	IY,(IX+12)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+6
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-19)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-22)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,3
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,1
	PUSH	BC
	LD	BC,38
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-4),HL
;  535	    
;  536	    free_expression(power, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-22)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  537	    
;  538	    simplify(monominal, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  539	    simplify(monominal, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  540	    
;  541	    for (i = 0; i < divisor_copy->child_count; i++) {
	LD	(IX+-1),0
	JR	L_182
L_180:
;  542	        replace_expression(divisor_copy->children[i]->children[1], new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
;  543	                                                                                 copy_expression(divisor_copy->children[i]->children[1]),
;  544	                                                                                 new_literal(-1, 1, 1)));
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,16777215
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	IY,(IX+-16)
	LD	BC,(IY+11)
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	ADD	HL,BC
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	IY,(IX+-16)
	LD	BC,(IY+11)
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	ADD	HL,BC
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
	INC	(IX+-1)
;  545	    }
L_182:
	LD	A,(IX+-1)
	LD	IY,(IX+-16)
	CP	A,(IY+10)
	JR	C,L_180
;  546	    
;  547	    result = new_expression(EXPT_OPERATION, EXPI_ADDITION, 2,
;  548	                            temp_poly,
;  549	                            new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 2,
;  550	                                           copy_expression(monominal),
;  551	                                           divisor_copy));
	LD	BC,(IX+-16)
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-28)
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-7),HL
;  552	    
;  553	    simplify(result, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  554	    simplify(result, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  555	    simplify(result, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  556	    
;  557	    if (expressions_are_equivalent(result, new_literal(1, 0, 1), false)) {
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_expressions_are_equivalent
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_185
;  558	        free_expression(monominal, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  559	        *quotient = copy_expression(monominal);
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	IY,(IX+6)
;  560	        *remainder = new_literal(1, 0, 1);
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	(IY),HL
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+9)
	LD	(IY),HL
;  561	    } else {
	JR	L_186
L_185:
;  562	        poly_div(&temp_quotient, &temp_remainder, result, divisor);
	LD	BC,(IX+15)
	PUSH	BC
	LD	BC,(IX+-7)
	PUSH	BC
	PEA	IX+-34
	PEA	IX+-10
	CALL	_poly_div
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  563	        replace_expression(temp_quotient, new_expression(EXPT_OPERATION, EXPI_ADDITION, 2,
;  564	                                                         copy_expression(temp_quotient),
;  565	                                                         monominal));
	LD	BC,(IX+-4)
	PUSH	BC
	LD	BC,(IX+-10)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-10)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  566	        simplify(temp_quotient, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-10)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  567	        any_expression_to_sparse_polynomial(temp_quotient, copy_expression(poly->children[0]->children[2]));
	LD	IY,(IX+12)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+6
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-10)
	PUSH	BC
	CALL	_any_expression_to_sparse_polynomial
	POP	BC
	POP	BC
;  568	        any_expression_to_sparse_polynomial(temp_remainder, copy_expression(poly->children[0]->children[2]));
	LD	IY,(IX+12)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+6
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-34)
	PUSH	BC
	CALL	_any_expression_to_sparse_polynomial
	POP	BC
	POP	BC
;  569	        *quotient = temp_quotient;
	LD	HL,(IX+6)
	LD	BC,(IX+-10)
	LD	(HL),BC
;  570	        *remainder = temp_remainder;
	LD	HL,(IX+9)
	LD	BC,(IX+-34)
	LD	(HL),BC
;  571	    }
L_186:
;  572	    
;  573	    return RETS_SUCCESS;
	LD	A,2
;  574	    
;  575	}
L_187:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _poly_div ***************************
;Name                         Addr/Register   Size   Type
;_expressions_are_equivalent         IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;_expression_is_numerical            IMPORT  -----   function
;_simplify                           IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_expression_is_greater_than         IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;_expressions_are_identical          IMPORT  -----   function
;_sort_sparse_polynomial             IMPORT  -----   function
;_free_expression                    IMPORT  -----   function
;_any_expression_to_sparse_polynomial      IMPORT  -----   function
;_new_symbol                         IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;poly_copy                            IX-37      3   variable
;temp_remainder                       IX-34      3   variable
;divisor_degree                       IX-31      3   variable
;temp_poly                            IX-28      3   variable
;poly_degree                          IX-25      3   variable
;power                                IX-22      3   variable
;coefficient                          IX-19      3   variable
;divisor_copy                         IX-16      3   variable
;symbol                               IX-13      3   variable
;temp_quotient                        IX-10      3   variable
;result                                IX-7      3   variable
;monominal                             IX-4      3   variable
;i                                     IX-1      1   variable
;divisor                              IX+15      3   parameter
;poly                                 IX+12      3   parameter
;remainder                             IX+9      3   parameter
;quotient                              IX+6      3   parameter


; Stack Frame Size: 55 (bytes)
;       Spill Code: -1 (instruction)


	SEGMENT STRSECT
L__85:
	DB	"x"
	DB	0
	SEGMENT CODE
;  576	
;  577	bool poly_is_square_free(expression* source) {
_poly_is_square_free:
	LD	HL,-6
	CALL	__frameset
;  578	    
;  579	    expression* gcd;
;  580	    expression* temp_source = copy_expression(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-3),HL
;  581	    
;  582	    simplify(temp_source, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  583	    any_expression_to_sparse_polynomial(temp_source, NULL);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_any_expression_to_sparse_polynomial
	POP	BC
	POP	BC
;  584	    
;  585	    poly_log_gcd(&gcd, temp_source);
	LD	BC,(IX+-3)
	PUSH	BC
	PEA	IX+-6
	CALL	_poly_log_gcd
	POP	BC
	POP	BC
;  586	    
;  587	    free_expression(temp_source, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  588	    
;  589	    if (expressions_are_equivalent(gcd, new_literal(1, 1, 1), false)) {
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_expressions_are_equivalent
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_189
;  590	        return true;
	LD	A,1
	JR	L_190
;  591	    } else {
L_189:
;  592	        return false;
	XOR	A,A
;  593	    }
;  594	    
;  595	}
L_190:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _poly_is_square_free ***************************
;Name                         Addr/Register   Size   Type
;_new_literal                        IMPORT  -----   function
;_expressions_are_equivalent         IMPORT  -----   function
;_free_expression                    IMPORT  -----   function
;_poly_log_gcd                       IMPORT  -----   function
;_any_expression_to_sparse_polynomial      IMPORT  -----   function
;_simplify                           IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;gcd                                   IX-6      3   variable
;temp_source                           IX-3      3   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: -1 (instruction)


;  596	
;  597	void make_monic(expression* source) {
_make_monic:
	LD	HL,-4
	CALL	__frameset
;  598	    
;  599	    uint8_t i;
;  600	    expression* result;
;  601	    
;  602	    any_expression_to_sparse_polynomial(source, NULL);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_any_expression_to_sparse_polynomial
	POP	BC
	POP	BC
;  603	    
;  604	    result = new_expression(EXPT_STRUCTURE, EXPI_POLYNOMIAL_SPARSE, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,38
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-4),HL
;  605	    
;  606	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_194
L_192:
;  607	        append_child(result, new_expression(EXPT_STRUCTURE, EXPI_LIST, 3,
;  608	                                            copy_expression(source->children[i]->children[0]),
;  609	                                            new_expression(EXPT_OPERATION, EXPI_DIVISION, 2,
;  610	                                                           copy_expression(source->children[i]->children[1]),
;  611	                                                           copy_expression(source->children[0]->children[1])),
;  612	                                            copy_expression(source->children[i]->children[2])));
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+6
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,8
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	ADD	HL,BC
	LD	IY,(HL)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,3
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
	INC	(IX+-1)
;  613	    }
L_194:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_192
;  614	    
;  615	    simplify(result, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  616	    replace_expression(source, result);
	LD	BC,(IX+-4)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  617	    
;  618	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _make_monic ***************************
;Name                         Addr/Register   Size   Type
;_replace_expression                 IMPORT  -----   function
;_simplify                           IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;_any_expression_to_sparse_polynomial      IMPORT  -----   function
;result                                IX-4      3   variable
;i                                     IX-1      1   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 13 (bytes)
;       Spill Code: -1 (instruction)


;  619	
;  620	void poly_GCD(expression** gcd, const expression* a, const expression* b) {
_poly_GCD:
	LD	HL,-15
	CALL	__frameset
;  621	    
;  622	    expression* a_temp;
;  623	    expression* b_temp;
;  624	    expression* temp;
;  625	    expression* quotient;
;  626	    expression* remainder;
;  627	    
;  628	    if (expressions_are_equivalent(a, new_literal(1, 0, 1), false)) {
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_expressions_are_equivalent
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_199
;  629	        *gcd = copy_expression(b);
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	IY,(IX+6)
	LD	(IY),HL
;  630	        return;
	JR	L_206
;  631	    }
L_199:
;  632	    
;  633	    if (expressions_are_equivalent(b, new_literal(1, 0, 1), false)) {
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_expressions_are_equivalent
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_200
;  634	        *gcd = copy_expression(a);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	IY,(IX+6)
	LD	(IY),HL
;  635	        return;
	JR	L_206
;  636	    }
L_200:
;  637	    
;  638	    a_temp = copy_expression(a);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-6),HL
;  639	    b_temp = copy_expression(b);
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-3),HL
;  640	    
;  641	    sort_sparse_polynomial(a_temp);
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_sort_sparse_polynomial
	POP	BC
;  642	    sort_sparse_polynomial(b_temp);
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_sort_sparse_polynomial
	POP	BC
;  643	    
;  644	    if (expression_is_greater_than(b_temp->children[0]->children[0], a_temp->children[0]->children[0], true)) {
	LD	BC,1
	PUSH	BC
	LD	IY,(IX+-6)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	LD	IY,(IX+-3)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_expression_is_greater_than
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_202
;  645	        temp = a_temp;
	LD	BC,(IX+-6)
	LD	(IX+-12),BC
;  646	        a_temp = b_temp;
	LD	BC,(IX+-3)
	LD	(IX+-6),BC
;  647	        b_temp = temp;
	LD	BC,(IX+-12)
	LD	(IX+-3),BC
;  648	    }
L_202:
;  649	    
;  650	    poly_div(&quotient, &remainder, a_temp, b_temp);
	LD	BC,(IX+-3)
	PUSH	BC
	LD	BC,(IX+-6)
	PUSH	BC
	PEA	IX+-9
	PEA	IX+-15
	CALL	_poly_div
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  651	    
;  652	    if (expressions_are_equivalent(remainder, new_literal(1, 0, 1), false)) {
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-9)
	PUSH	BC
	CALL	_expressions_are_equivalent
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_204
;  653	        *gcd = copy_expression(b_temp);
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	IY,(IX+6)
	LD	(IY),HL
;  654	    } else {
	JR	L_205
L_204:
;  655	        poly_GCD(gcd, copy_expression(b_temp), remainder);
	LD	BC,(IX+-9)
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_poly_GCD
	POP	BC
	POP	BC
	POP	BC
;  656	    }
L_205:
;  657	    
;  658	    free_expression(a_temp, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  659	    free_expression(b_temp, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  660	    
;  661	    make_monic(*gcd);
	LD	HL,(IX+6)
	LD	BC,(HL)
	PUSH	BC
	CALL	_make_monic
	POP	BC
;  662	    
;  663	}
L_206:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _poly_GCD ***************************
;Name                         Addr/Register   Size   Type
;_make_monic                         IMPORT  -----   function
;_free_expression                    IMPORT  -----   function
;_poly_div                           IMPORT  -----   function
;_expression_is_greater_than         IMPORT  -----   function
;_sort_sparse_polynomial             IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_expressions_are_equivalent         IMPORT  -----   function
;quotient                             IX-15      3   variable
;temp                                 IX-12      3   variable
;remainder                             IX-9      3   variable
;a_temp                                IX-6      3   variable
;b_temp                                IX-3      3   variable
;b                                    IX+12      3   parameter
;a                                     IX+9      3   parameter
;gcd                                   IX+6      3   parameter


; Stack Frame Size: 30 (bytes)
;       Spill Code: -1 (instruction)


;  664	
;  665	void poly_log_gcd(expression** gcd, const expression* source) {
_poly_log_gcd:
	LD	HL,-9
	CALL	__frameset
;  666	    
;  667	    expression* a = copy_expression(source);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-3),HL
;  668	    expression* b = copy_expression(source);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-6),HL
;  669	    expression* b_derivative;
;  670	    
;  671	    simplify(a, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  672	    simplify(a, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  673	    any_expression_to_sparse_polynomial(a, NULL);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_any_expression_to_sparse_polynomial
	POP	BC
	POP	BC
;  674	    
;  675	    any_expression_to_expression(b);
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_any_expression_to_expression
	POP	BC
;  676	    derivative(&b_derivative, b, NULL, true);
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-6)
	PUSH	BC
	PEA	IX+-9
	CALL	_derivative
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  677	    
;  678	    any_expression_to_sparse_polynomial(b_derivative, copy_expression(a->children[0]->children[2]));
	LD	IY,(IX+-3)
	LD	HL,(IY+11)
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+6
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-9)
	PUSH	BC
	CALL	_any_expression_to_sparse_polynomial
	POP	BC
	POP	BC
;  679	    
;  680	    poly_GCD(gcd, a, b_derivative);
	LD	BC,(IX+-9)
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_poly_GCD
	POP	BC
	POP	BC
	POP	BC
;  681	    
;  682	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _poly_log_gcd ***************************
;Name                         Addr/Register   Size   Type
;_poly_GCD                           IMPORT  -----   function
;_derivative                         IMPORT  -----   function
;_any_expression_to_expression       IMPORT  -----   function
;_any_expression_to_sparse_polynomial      IMPORT  -----   function
;_simplify                           IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;b_derivative                          IX-9      3   variable
;b                                     IX-6      3   variable
;a                                     IX-3      3   variable
;source                                IX+9      3   parameter
;gcd                                   IX+6      3   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: -1 (instruction)


;  683	
;  684	void factor_square_free(expression* source) {
_factor_square_free:
	LD	HL,-43
	CALL	__frameset
;  685	    
;  686	    uint8_t i;
;  687	    expression* gcd;
;  688	    expression* temp_source;
;  689	    expression* rest;
;  690	    expression* quotient;
;  691	    expression* remainder;
;  692	    expression* result = new_expression(EXPT_STRUCTURE, EXPI_LIST, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-13),HL
;  693	    
;  694	    any_expression_to_expression(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_any_expression_to_expression
	POP	BC
;  695	    any_expression_to_sparse_polynomial(source, NULL);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_any_expression_to_sparse_polynomial
	POP	BC
	POP	BC
;  696	    
;  697	    if (poly_is_square_free(source)) {
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_poly_is_square_free
	POP	BC
	OR	A,A
	JR	Z,L_213
;  698	        
;  699	        append_child(result, new_expression(EXPT_STRUCTURE, EXPI_LIST, 2,
;  700	                                            copy_expression(source),
;  701	                                            new_literal(1, 1, 1)));
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-13)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  702	        
;  703	    } else {
	JR	L_214
L_213:
;  704	        
;  705	        temp_source = copy_expression(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-16),HL
;  706	        
;  707	        poly_log_gcd(&gcd, temp_source);
	LD	BC,HL
	PUSH	BC
	PEA	IX+-4
	CALL	_poly_log_gcd
	POP	BC
	POP	BC
;  708	        rest = copy_expression(gcd);
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-7),HL
;  709	        
;  710	        poly_div(&quotient, &remainder, copy_expression(temp_source), gcd);
	LD	BC,(IX+-4)
	PUSH	BC
	LD	BC,(IX+-16)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	PEA	IX+-19
	PEA	IX+-10
	CALL	_poly_div
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  711	        poly_GCD(&gcd, copy_expression(gcd), copy_expression(quotient));
	LD	BC,(IX+-10)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	PEA	IX+-4
	CALL	_poly_GCD
	POP	BC
	POP	BC
	POP	BC
;  712	        poly_div(&quotient, &remainder, copy_expression(quotient), copy_expression(gcd));
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-10)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	PEA	IX+-19
	PEA	IX+-10
	CALL	_poly_div
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  713	        
;  714	        factor_square_free(rest);
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_factor_square_free
	POP	BC
;  715	        
;  716	        append_child(result, new_expression(EXPT_STRUCTURE, EXPI_LIST, 2,
;  717	                                            copy_expression(quotient),
;  718	                                            new_literal(1, 1, 1)));
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-10)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-13)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  719	        
;  720	        for (i = 0; i < rest->child_count; i++) {
	LD	(IX+-1),0
	JR	L_211
L_209:
;  721	            rest->children[i]->children[1]->value.numeric.numerator += rest->children[i]->children[1]->value.numeric.numerator;
	LD	IY,(IX+-7)
	LD	BC,(IY+11)
	LD	(IX+-37),BC
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IX+-37)
	ADD	HL,BC
	LD	(IX+-34),HL
	LD	IY,(HL)
	LD	BC,(IY+11)
	LD	(IX+-31),BC
	LD	IY,(IX+-31)
	LEA	BC,IY+3
	LD	(IX+-28),BC
	LD	HL,BC
	LD	IY,(HL)
	LEA	BC,IY+14
	LD	(IX+-25),BC
	LD	IY,(IX+-25)
	LEA	BC,IY+0
	LD	(IX+-22),BC
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	LD	IY,(IX+-7)
	LD	BC,(IY+11)
	ADD	HL,DE
	ADD	HL,BC
	LD	IY,(HL)
	LD	IY,(IY+11)
	LEA	HL,IY+3
	LD	HL,(HL)
	LD	(IX+-43),HL	; spill
	LD	IY,(IX+-22)
	LD	HL,(IY+0)
	LD	E,(IY+3)
	LD	BC,(IY+0)
	LD	A,(IY+3)
	CALL	__ladd
	LD	(IX+-40),HL	; spill
	LD	IY,(IX+-43)
	LD	HL,(IX+-40)	; unspill
	LD	(IY+14),HL
	LD	(IY+17),E
;  722	            append_child(result, copy_expression(rest->children[i]));
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	LD	IY,(IX+-7)
	LD	BC,(IY+11)
	ADD	HL,DE
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-13)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
	INC	(IX+-1)
;  723	        }
L_211:
	LD	A,(IX+-1)
	LD	IY,(IX+-7)
	CP	A,(IY+10)
	JR	C,L_209
;  724	        
;  725	    }
L_214:
;  726	    
;  727	    replace_expression(source, result);
	LD	BC,(IX+-13)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  728	    
;  729	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _factor_square_free ***************************
;Name                         Addr/Register   Size   Type
;_replace_expression                 IMPORT  -----   function
;_poly_GCD                           IMPORT  -----   function
;_poly_div                           IMPORT  -----   function
;_poly_log_gcd                       IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;_poly_is_square_free                IMPORT  -----   function
;_any_expression_to_sparse_polynomial      IMPORT  -----   function
;_any_expression_to_expression       IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;remainder                            IX-19      3   variable
;temp_source                          IX-16      3   variable
;result                               IX-13      3   variable
;quotient                             IX-10      3   variable
;rest                                  IX-7      3   variable
;gcd                                   IX-4      3   variable
;i                                     IX-1      1   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 52 (bytes)
;       Spill Code: -2 (instruction)


	XREF _derivative:ROM
	XREF _solve:ROM
	XREF _subtract_rhs:ROM
	XREF _simplify:ROM
	XREF _literal_to_double:ROM
	XREF _guess_symbol:ROM
	XREF _count_occurrences:ROM
	XREF _expression_is_numerical:ROM
	XREF _expression_is_greater_than:ROM
	XREF _expressions_are_equivalent:ROM
	XREF _expressions_are_identical:ROM
	XREF _append_child:ROM
	XREF _free_expression:ROM
	XREF _replace_expression:ROM
	XREF _copy_expression:ROM
	XREF _new_symbol:ROM
	XREF _new_literal:ROM
	XREF _new_expression:ROM
	XREF __lcmpu:ROM
	XREF __ladd:ROM
	XREF __lmulu:ROM
	XREF __fcmp:ROM
	XREF __frameset:ROM
	XREF __icmpzero:ROM
	XREF __lcmpzero:ROM
	XREF __ladd_b:ROM
	XDEF _factor_square_free
	XDEF _poly_log_gcd
	XDEF _poly_GCD
	XDEF _make_monic
	XDEF _poly_is_square_free
	XDEF _poly_div
	XDEF _polysolve
	XDEF _polysolve_quadratic
	XDEF _quadratic_formula
	XDEF _dense_polynomial_to_sparse_polynomial
	XDEF _sparse_polynomial_to_dense_polynomial
	XDEF _sparse_polynomial_to_expression
	XDEF _expression_to_sparse_polynomial
	XDEF _expression_to_sparse_polynomial_term
	XDEF _sort_sparse_polynomial
	XDEF _validate_sparse_polynomial
	XDEF _any_expression_to_dense_polynomial
	XDEF _any_expression_to_sparse_polynomial
	XDEF _any_expression_to_expression_recursive
	XDEF _any_expression_to_expression
	END
