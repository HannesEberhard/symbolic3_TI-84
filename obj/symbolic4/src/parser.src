; Zilog eZ80 ANSI C Compiler Release 3.4
; -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"SRC\SYMBOLIC4\SRC\PARSER.C"
	.assume ADL=1
	SEGMENT CODE
;    1	
;    2	/*
;    3	 
;    4	 Copyright (c) 2019 Hannes Eberhard
;    5	 
;    6	 Permission is hereby granted, free of charge, to any person obtaining a copy
;    7	 of this software and associated documentation files (the "Software"), to deal
;    8	 in the Software without restriction, including without limitation the rights
;    9	 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
;   10	 copies of the Software, and to permit persons to whom the Software is
;   11	 furnished to do so, subject to the following conditions:
;   12	 
;   13	 The above copyright notice and this permission notice shall be included in all
;   14	 copies or substantial portions of the Software.
;   15	 
;   16	 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;   17	 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;   18	 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;   19	 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;   20	 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;   21	 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;   22	 SOFTWARE.
;   23	 
;   24	 */
;   25	
;   26	#include "symbolic4.h"
;   27	
;   28	/**
;   29	 
;   30	 @brief Determines the expression type of a character
;   31	 
;   32	 @details
;   33	 It can't distinguish between @c EXPT_VALUE and @c EXPT_FUNCTION.
;   34	 
;   35	 @param[in] source The character to analyze.
;   36	 
;   37	 @return
;   38	 - The expression type or @c EXPT_NULL when an unexpected character
;   39	 was encountered.
;   40	 
;   41	 */
;   42	expression_type get_expression_type(char source) {
_get_expression_type:
	CALL	__frameset0
;   43	    if (isalpha(source) || isdigit(source) || source == '.') {
	LD	A,(IX+6)
	SEXT	HL
	LD	L,(IX+6)
	PUSH	HL
	CALL	_isalpha
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_6
	LD	A,(IX+6)
	SEXT	HL
	LD	L,(IX+6)
	PUSH	HL
	CALL	_isdigit
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_6
	LD	A,(IX+6)
	CP	A,46
	JR	NZ,L_7
L_6:
;   44	        return EXPT_VALUE;
	LD	HL,1
	JR	L_8
;   45	    } else if (strchr("=+-/*^", source)) {
L_7:
	LD	A,(IX+6)
	SEXT	HL
	LD	L,(IX+6)
	PUSH	HL
	LD	BC,L__3
	PUSH	BC
	CALL	_strchr
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	Z,L_5
;   46	        return EXPT_OPERATION;
	LD	HL,2
	JR	L_8
;   47	    } else if (strchr(",()", source)) {
L_5:
	LD	A,(IX+6)
	SEXT	HL
	LD	L,(IX+6)
	PUSH	HL
	LD	BC,L__5
	PUSH	BC
	CALL	_strchr
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	Z,L_3
;   48	        return EXPT_CONTROL;
	LD	HL,5
	JR	L_8
;   49	    } else {
L_3:
	OR	A,A
;   50	        return EXPT_NULL;
	SBC	HL,HL
;   51	    }
;   52	}
L_8:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _get_expression_type ***************************
;Name                         Addr/Register   Size   Type
;_strchr                             IMPORT  -----   function
;_isdigit                            IMPORT  -----   function
;_isalpha                            IMPORT  -----   function
;source                                IX+6      1   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__3:
	DB	"=+-/*^"
	DB	0
L__5:
	DB	",()"
	DB	0
	SEGMENT CODE
;   53	
;   54	/**
;   55	 
;   56	 @brief Determines the expression identifier of a character of the
;   57	 type EXPT_VALUE
;   58	 
;   59	 @param[in] source The character to analyze.
;   60	 
;   61	 @return
;   62	 - The expression type or @c EXPT_NULL when an unexpected character
;   63	 was encountered.
;   64	 
;   65	 */
;   66	expression_identifier get_value_identifier(char source) {
_get_value_identifier:
	CALL	__frameset0
;   67	    if (isalpha(source)) {
	LD	A,(IX+6)
	SEXT	HL
	LD	L,(IX+6)
	PUSH	HL
	CALL	_isalpha
	POP	BC
	CALL	__icmpzero
	JR	Z,L_13
;   68	        return EXPI_SYMBOL;
	LD	HL,2
	JR	L_14
;   69	    } else if (isdigit(source) || source == '.') {
L_13:
	LD	A,(IX+6)
	SEXT	HL
	LD	L,(IX+6)
	PUSH	HL
	CALL	_isdigit
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_10
	LD	A,(IX+6)
	CP	A,46
	JR	NZ,L_11
L_10:
;   70	        return EXPI_LITERAL;
	LD	HL,1
	JR	L_14
;   71	    } else {
L_11:
	OR	A,A
;   72	        return EXPI_NULL;
	SBC	HL,HL
;   73	    }
;   74	}
L_14:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _get_value_identifier ***************************
;Name                         Addr/Register   Size   Type
;_isdigit                            IMPORT  -----   function
;_isalpha                            IMPORT  -----   function
;source                                IX+6      1   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;   75	
;   76	/**
;   77	 
;   78	 @brief Determines the expression identifier of a character of the
;   79	 type EXPT_OPERATION
;   80	 
;   81	 @param[in] source The character to analyze.
;   82	 
;   83	 @return
;   84	 - The expression type or @c EXPT_NULL when an unexpected character
;   85	 was encountered.
;   86	 
;   87	 */
;   88	expression_identifier get_operator_identifier(char source) {
_get_operator_identifier:
	CALL	__frameset0
;   89	    if (source == '=') {
	LD	A,(IX+6)
	CP	A,61
	JR	NZ,L_26
;   90	        return EXPI_EQUATION;
	LD	HL,4
	JR	L_27
;   91	    } else if (source == '+') {
L_26:
	LD	A,(IX+6)
	CP	A,43
	JR	NZ,L_24
;   92	        return EXPI_ADDITION;
	LD	HL,5
	JR	L_27
;   93	    } else if (source == '-') {
L_24:
	LD	A,(IX+6)
	CP	A,45
	JR	NZ,L_22
;   94	        return EXPI_SUBTRACTION;
	LD	HL,6
	JR	L_27
;   95	    } else if (source == '*') {
L_22:
	LD	A,(IX+6)
	CP	A,42
	JR	NZ,L_20
;   96	        return EXPI_MULTIPLICATION;
	LD	HL,7
	JR	L_27
;   97	    } else if (source == '/') {
L_20:
	LD	A,(IX+6)
	CP	A,47
	JR	NZ,L_18
;   98	        return EXPI_DIVISION;
	LD	HL,8
	JR	L_27
;   99	    } else if (source == '^') {
L_18:
	LD	A,(IX+6)
	CP	A,94
	JR	NZ,L_16
;  100	        return EXPI_EXPONENTATION;
	LD	HL,9
	JR	L_27
;  101	    } else {
L_16:
	OR	A,A
;  102	        return EXPI_NULL;
	SBC	HL,HL
;  103	    }
;  104	}
L_27:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _get_operator_identifier ***************************
;Name                         Addr/Register   Size   Type
;source                                IX+6      1   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  105	
;  106	/**
;  107	 
;  108	 @brief Determines the expression identifier of a character of the
;  109	 type EXPT_CONTROL
;  110	 
;  111	 @param[in] source The character to analyze.
;  112	 
;  113	 @return
;  114	 - The expression type or @c EXPT_NULL when an unexpected character
;  115	 was encountered.
;  116	 
;  117	 */
;  118	expression_identifier get_control_identifier(char source) {
_get_control_identifier:
	CALL	__frameset0
;  119	    if (source == ',') {
	LD	A,(IX+6)
	CP	A,44
	JR	NZ,L_33
;  120	        return EXPI_COMMA;
	LD	HL,43
	JR	L_34
;  121	    } else if (source == '(') {
L_33:
	LD	A,(IX+6)
	CP	A,40
	JR	NZ,L_31
;  122	        return EXPI_LEFT_PARENTHESIS;
	LD	HL,44
	JR	L_34
;  123	    } else if (source == ')') {
L_31:
	LD	A,(IX+6)
	CP	A,41
	JR	NZ,L_29
;  124	        return EXPI_RIGHT_PARENTHESIS;
	LD	HL,45
	JR	L_34
;  125	    } else {
L_29:
	OR	A,A
;  126	        return EXPI_NULL;
	SBC	HL,HL
;  127	    }
;  128	}
L_34:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _get_control_identifier ***************************
;Name                         Addr/Register   Size   Type
;source                                IX+6      1   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  129	
;  130	/**
;  131	 
;  132	 @brief Appends a multiplication expression if necessary
;  133	 
;  134	 @details
;  135	 This function appends a multiplication if
;  136	 
;  137	 - the token array is not empty
;  138	 
;  139	 - and the last expression in the token array is either a value or
;  140	 a close parenthesis.
;  141	 
;  142	 @param[in,out] tokens The token array the multiplication should be
;  143	 appended to.
;  144	 
;  145	 */
;  146	void append_multiplication_if_necessary(expression* tokens) {
_append_multiplication_if_necessary:
	LD	HL,-4
	CALL	__frameset
;  147	    if (tokens->child_count > 0 && (tokens->children[tokens->child_count - 1]->type == EXPT_VALUE || tokens->children[tokens->child_count - 1]->identifier == EXPI_RIGHT_PARENTHESIS)) {
	LD	IY,(IX+6)
	LD	A,(IY+10)
	LD	(IX+-1),A
	XOR	A,A
	CP	A,(IX+-1)
	JR	NC,L_38
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	(IX+-4),HL
	LD	IY,(HL)
	LD	HL,(IY+0)
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	Z,L_37
	LD	HL,(IX+-4)
	LD	IY,(HL)
	LD	HL,(IY+3)
	LD	BC,45
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_38
L_37:
;  148	        append_child(tokens, new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 0));
	LD	BC,0
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  149	    }
;  150	}
L_38:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _append_multiplication_if_necessary ***************************
;Name                         Addr/Register   Size   Type
;_new_expression                     IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;G_1                                   IX-4      3   variable
;G_0                                   IX-1      1   variable
;tokens                                IX+6      3   parameter


; Stack Frame Size: 13 (bytes)
;       Spill Code: 0 (instruction)


;  151	
;  152	uint8_t tokenize_buffer(expression* tokens, char* buffer) {
_tokenize_buffer:
	LD	HL,-28
	CALL	__frameset
;  153	    
;  154	    uint8_t i, j;
;  155	    char* lowercase_buffer = string_to_lower(buffer);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_string_to_lower
	POP	BC
	LD	(IX+-3),HL
;  156	    char* lowercase_keyword = NULL;
	LD	BC,0
	LD	(IX+-15),BC
;  157	    char* keyword_occurrence = NULL;
	LD	(IX+-8),BC
;  158	    uint8_t keyword_occurrence_position;
;  159	    
;  160	    /* search for pi */
;  161	    while ((keyword_occurrence = strstr(lowercase_buffer, "pi")) != NULL) {
	JR	L_39
L_40:
;  162	        keyword_occurrence_position = keyword_occurrence - lowercase_buffer;
	LD	BC,(IX+-3)
	LD	HL,(IX+-8)
	OR	A,A
	SBC	HL,BC
	LD	(IX+-12),L
;  163	        append_multiplication_if_necessary(tokens);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_append_multiplication_if_necessary
	POP	BC
;  164	        lowercase_buffer[keyword_occurrence_position] = '~';
	LD	A,(IX+-12)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-3)
	ADD	HL,BC
	LD	(HL),126
;  165	        lowercase_buffer[keyword_occurrence_position + 1] = '~';
	LD	A,(IX+-12)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-3)
;  166	        append_child(tokens, new_symbol(EXPI_SYMBOL, "pi"));
	LD	DE,L__27
	PUSH	DE
	LD	DE,2
	PUSH	DE
	INC	BC
	ADD	HL,BC
	LD	(HL),126
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  167	    }
L_39:
	LD	BC,L__28
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_strstr
	POP	BC
	POP	BC
	LD	(IX+-8),HL
	CALL	__icmpzero
	JR	NZ,L_40
;  168	    
;  169	    /* search for functions */
;  170	    for (i = 0; keyword_strings[i] != NULL; i++) {
	LD	(IX+-5),0
	JR	L_48
L_46:
;  171	        lowercase_keyword = string_to_lower(keyword_strings[i]);
	LD	HL,(IX+-11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_string_to_lower
	POP	BC
	LD	(IX+-15),HL
;  172	        if ((keyword_occurrence = strstr(lowercase_buffer, lowercase_keyword)) != NULL) {
	LD	BC,HL
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_strstr
	POP	BC
	POP	BC
	LD	(IX+-8),HL
	CALL	__icmpzero
	JR	Z,L_45
;  173	            if (strlen(keyword_occurrence) != strlen(keyword_strings[i])) continue;
	LD	BC,_keyword_strings
	LD	HL,(IX+-11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_strlen
	POP	BC
	LD	BC,(IX+-8)
	PUSH	BC
	LD	DE,HL
	LD	(IX+-27),DE
	LD	(IX+-28),D
	CALL	_strlen
	LD	DE,(IX+-27)
	LD	D,(IX+-28)
	POP	BC
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_47
;  174	            smart_free(lowercase_keyword);
	LD	BC,(IX+-15)
	PUSH	BC
	CALL	_smart_free
	POP	BC
;  175	            break;
	JR	L_54
;  176	        }
L_45:
;  177	        smart_free(lowercase_keyword);
	LD	BC,(IX+-15)
	PUSH	BC
	CALL	_smart_free
	POP	BC
;  178	    }
L_47:
	INC	(IX+-5)
L_48:
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	(IX+-11),HL
	LD	BC,_keyword_strings
	ADD	HL,BC
	LD	(IX+-24),HL
	LD	HL,(IX+-11)
	ADD	HL,BC
	LD	HL,(HL)
	CALL	__icmpzero
	JR	NZ,L_46
L_54:
;  179	    
;  180	    keyword_occurrence_position = (keyword_identifiers[i] != EXPI_NULL) ? keyword_occurrence - lowercase_buffer : strlen(lowercase_buffer);
	LD	BC,_keyword_identifiers
	LD	HL,(IX+-11)
	ADD	HL,BC
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_52
	LD	BC,(IX+-3)
	LD	HL,(IX+-8)
	OR	A,A
	SBC	HL,BC
	LD	(IX+-18),HL
	JR	L_53
L_52:
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_strlen
	POP	BC
	LD	(IX+-18),HL
L_53:
	LD	A,(IX+-18)
	LD	(IX+-12),A
;  181	    
;  182	    for (j = 0; j < keyword_occurrence_position; j++) {
	LD	(IX+-4),0
	JR	L_59
L_57:
;  183	        if (lowercase_buffer[j] != '~') {
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-3)
	ADD	HL,BC
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	OR	A,A
	LD	BC,126
	SBC	HL,BC
	JR	Z,L_58
;  184	            append_multiplication_if_necessary(tokens);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_append_multiplication_if_necessary
	POP	BC
;  185	            append_child(tokens, new_symbol(EXPI_SYMBOL, &buffer[j]));
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+9)
	ADD	HL,BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  186	            tokens->children[tokens->child_count - 1]->value.symbolic[1] = '\0';
	LD	IY,(IX+6)
	LD	A,(IY+10)
	LD	DE,(IY+11)
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,DE
	LD	IY,(HL)
	LEA	HL,IY+14
	INC	HL
	LD	(HL),0
;  187	        }
;  188	    }
L_58:
	INC	(IX+-4)
L_59:
	LD	A,(IX+-4)
	CP	A,(IX+-12)
	JR	C,L_57
;  189	    
;  190	    if (keyword_identifiers[i] != EXPI_NULL) {
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_keyword_identifiers
	ADD	HL,BC
	LD	(IX+-21),HL
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_62
;  191	        append_multiplication_if_necessary(tokens);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_append_multiplication_if_necessary
	POP	BC
;  192	        append_child(tokens, new_expression(EXPT_FUNCTION, keyword_identifiers[i], 0));
	LD	BC,0
	PUSH	BC
	LD	HL,(IX+-21)
	LD	BC,(HL)
	PUSH	BC
	LD	BC,3
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  193	    }
L_62:
;  194	    
;  195	    smart_free(lowercase_buffer);
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_smart_free
	POP	BC
;  196	    
;  197	    return RETS_SUCCESS;
	LD	A,2
;  198	    
;  199	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _tokenize_buffer ***************************
;Name                         Addr/Register   Size   Type
;_new_expression                     IMPORT  -----   function
;_keyword_identifiers                IMPORT  unknown variable
;_smart_free                         IMPORT  -----   function
;_strlen                             IMPORT  -----   function
;_keyword_strings                    IMPORT  unknown variable
;_strstr                             IMPORT  -----   function
;_new_symbol                         IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;_string_to_lower                    IMPORT  -----   function
;G_2                                  IX-24      3   variable
;G_5                                  IX-21      3   variable
;temp50                               IX-18      3   variable
;lowercase_keyword                    IX-15      3   variable
;keyword_occurrence_position          IX-12      1   variable
;G_4                                  IX-11      3   variable
;keyword_occurrence                    IX-8      3   variable
;i                                     IX-5      1   variable
;j                                     IX-4      1   variable
;lowercase_buffer                      IX-3      3   variable
;buffer                                IX+9      3   parameter
;tokens                                IX+6      3   parameter


; Stack Frame Size: 40 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__27:
	DB	"pi"
	DB	0
L__28:
	DB	"pi"
	DB	0
	SEGMENT CODE
;  200	
;  201	uint8_t string_to_literal(expression** result, const char* source) {
_string_to_literal:
	LD	HL,-31
	CALL	__frameset
;  202	    
;  203	    uint8_t i = 0;
	LD	(IX+-1),0
;  204	    int8_t sign = 1;
;  205	    uintmax_t a = 0;
	LD	BC,0
	LD	(IX+-14),BC
	XOR	A,A
	LD	(IX+-11),A
;  206	    uintmax_t b = 0;
	LD	(IX+-18),BC
	XOR	A,A
	LD	(IX+-15),A
;  207	    uintmax_t c = 1;
	LD	BC,1
	LD	(IX+-22),BC
	XOR	A,A
	LD	(IX+-19),A
;  208	    expression* literal;
;  209	    
;  210	    if (source[0] == '-') {
	LD	HL,(IX+9)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	OR	A,A
	LD	BC,45
	SBC	HL,BC
	JR	NZ,L_69
;  211	        sign = -1;
;  212	        i++;
	LD	(IX+-1),1
;  213	    }
;  214	    
;  215	    for ( ; isdigit(source[i]); i++) {
	JR	L_69
L_67:
;  216	        a = 10 * a + (source[i] - '0');
	LD	HL,(IX+-14)
	LD	E,(IX+-11)
	LD	BC,10
	XOR	A,A
	CALL	__lmulu
	LD	(IX+-28),HL
	LD	HL,(IX+-7)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	IY,HL
	LD	HL,(IX+-28)
	LEA	BC,IY+-48
	CALL	__itol
	CALL	__ladd
	LD	(IX+-14),HL
	LD	(IX+-11),E
	INC	(IX+-1)
;  217	//        if (a > pow(2, sizeof(uintmax_t) * 8) / 10) return set_error(ERRD_SYSTEM, ERRI_MAX_INT_VALUE_EXCEEDED, "");
;  218	    }
L_69:
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+9)
	ADD	HL,BC
	LD	(IX+-7),HL
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_isdigit
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_67
;  219	    
;  220	    if (source[i] == '.') {
	LD	HL,(IX+-7)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	OR	A,A
	LD	BC,46
	SBC	HL,BC
	JR	NZ,L_79
;  221	        
;  222	        for (i = i + 1; isdigit(source[i]); i++) {
	INC	(IX+-1)
	JR	L_74
L_72:
;  223	            b = 10 * b + (source[i] - '0');
	LD	HL,(IX+-18)
	LD	E,(IX+-15)
	LD	BC,10
	XOR	A,A
	CALL	__lmulu
	LD	(IX+-31),HL
	LD	HL,(IX+-10)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	IY,HL
	LD	HL,(IX+-31)
	LEA	BC,IY+-48
	CALL	__itol
	CALL	__ladd
	LD	(IX+-18),HL
	LD	(IX+-15),E
;  224	            c *= 10;
	LD	HL,(IX+-22)
	LD	E,(IX+-19)
	LD	BC,10
	XOR	A,A
	CALL	__lmulu
	LD	(IX+-22),HL
	LD	(IX+-19),E
	INC	(IX+-1)
;  225	        }
L_74:
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+9)
	ADD	HL,BC
	LD	(IX+-10),HL
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_isdigit
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_72
;  226	        
;  227	        if (source[i] == '.') return set_error(ERRD_PARSER, ERRI_SYNTAX, "");
	LD	HL,(IX+-10)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	OR	A,A
	LD	BC,46
	SBC	HL,BC
	JR	NZ,L_79
	LD	BC,L__43
	PUSH	BC
	LD	BC,5
	PUSH	BC
	PUSH	BC
	CALL	_set_error
	POP	BC
	POP	BC
	POP	BC
	JR	L_80
;  228	        
;  229	    }
L_79:
;  230	    
;  231	    literal = new_literal(1, b, c);
	LD	C,(IX+-19)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-22)
	PUSH	BC
	LD	C,(IX+-15)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-18)
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-4),HL
;  232	    simplify(literal, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  233	    literal->value.numeric.numerator += a * literal->value.numeric.denominator;
	LD	IY,(IX+-4)
	LEA	BC,IY+14
	LD	(IX+-25),BC
	LD	IY,(IX+-25)
	LD	HL,(IY+4)
	LD	E,(IY+7)
	LD	BC,(IX+-14)
	LD	A,(IX+-11)
	CALL	__lmulu
	LD	BC,(IY+0)
	LD	A,(IY+3)
	CALL	__ladd
	LD	IY,(IX+-4)
	LD	(IY+14),HL
	LD	(IY+17),E
;  234	    
;  235	    *result = literal;
	LD	HL,(IX+6)
	LD	BC,(IX+-4)
	LD	(HL),BC
;  236	    
;  237	    return RETS_SUCCESS;
	LD	A,2
;  238	    
;  239	}
L_80:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _string_to_literal ***************************
;Name                         Addr/Register   Size   Type
;_simplify                           IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_set_error                          IMPORT  -----   function
;_isdigit                            IMPORT  -----   function
;c                                    IX-22      4   variable
;b                                    IX-18      4   variable
;a                                    IX-14      4   variable
;G_8                                  IX-10      3   variable
;G_6                                   IX-7      3   variable
;literal                               IX-4      3   variable
;i                                     IX-1      1   variable
;source                                IX+9      3   parameter
;result                                IX+6      3   parameter


; Stack Frame Size: 43 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__43:
	DB	0
	SEGMENT CODE
;  240	
;  241	uint8_t tokenize_value_expression(expression* tokens, uint8_t* index, const char* source) {
_tokenize_value_expression:
	LD	HL,-107
	CALL	__frameset
;  242	    
;  243	    expression_identifier identifier = get_value_identifier(source[*index]);
	LD	HL,(IX+9)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+12)
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	PUSH	BC
	CALL	_get_value_identifier
	POP	BC
	LD	(IX+-4),HL
;  244	    expression* literal;
;  245	    char buffer[100];
;  246	    uint8_t buffer_position = 0;
	LD	(IX+-1),0
;  247	    
;  248	    while (get_value_identifier(source[*index]) == identifier) {
	JR	L_83
L_84:
;  249	        buffer[buffer_position++] = source[(*index)++];
	LD	HL,(IX+9)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,(IX+-1)
	LD	BC,(IX+12)
	ADD	HL,BC
	LD	IY,HL
	UEXT	HL
	LD	L,A
	LD	A,(IY)
	LD	BC,HL
	LEA	HL,IX+-107
	ADD	HL,BC
	LD	(HL),A
	LD	HL,(IX+9)
	LD	A,(HL)
	INC	A
	LD	HL,(IX+9)
	LD	(HL),A
	INC	(IX+-1)
;  250	    }
L_83:
	LD	HL,(IX+9)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+12)
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	PUSH	BC
	CALL	_get_value_identifier
	POP	BC
	LD	BC,(IX+-4)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_84
;  251	    
;  252	    buffer[buffer_position] = '\0';
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LEA	HL,IX+-107
	ADD	HL,BC
	LD	(HL),0
;  253	    
;  254	    if (identifier == EXPI_SYMBOL) {
	LD	HL,(IX+-4)
	OR	A,A
	LD	BC,2
	SBC	HL,BC
	JR	NZ,L_90
;  255	        ERROR_CHECK(tokenize_buffer(tokens, buffer));
	PEA	IX+-107
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_tokenize_buffer
	POP	BC
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	NZ,L_92
	LD	A,1
	JR	L_93
;  256	    } else {
L_90:
;  257	        ERROR_CHECK(string_to_literal(&literal, buffer));
	PEA	IX+-107
	PEA	IX+-7
	CALL	_string_to_literal
	POP	BC
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	NZ,L_88
	LD	A,1
	JR	L_93
L_88:
;  258	        append_multiplication_if_necessary(tokens);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_append_multiplication_if_necessary
	POP	BC
;  259	        append_child(tokens, literal);
	LD	BC,(IX+-7)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  260	    }
L_92:
;  261	    
;  262	    (*index)--;
	LD	HL,(IX+9)
	LD	A,(HL)
	DEC	A
	LD	HL,(IX+9)
	LD	(HL),A
;  263	    
;  264	    return RETS_SUCCESS;
	LD	A,2
;  265	    
;  266	}
L_93:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _tokenize_value_expression ***************************
;Name                         Addr/Register   Size   Type
;_append_child                       IMPORT  -----   function
;_string_to_literal                  IMPORT  -----   function
;buffer                              IX-107    100   variable
;literal                               IX-7      3   variable
;identifier                            IX-4      3   variable
;buffer_position                       IX-1      1   variable
;source                               IX+12      3   parameter
;index                                 IX+9      3   parameter
;tokens                                IX+6      3   parameter


; Stack Frame Size: 122 (bytes)
;       Spill Code: 0 (instruction)


;  267	
;  268	void tokenize_operator_expression(expression* tokens, char source) {
_tokenize_operator_expression:
	LD	HL,-10
	CALL	__frameset
;  269	    
;  270	    expression_identifier identifier = get_operator_identifier(source);
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	CALL	_get_operator_identifier
	POP	BC
	LD	(IX+-10),HL
;  271	    
;  272	    if (identifier == EXPI_SUBTRACTION && (tokens->child_count == 0 || tokens->children[tokens->child_count - 1]->type == EXPT_OPERATION || (tokens->children[tokens->child_count - 1]->type == EXPT_CONTROL && tokens->children[tokens->child_count - 1]->identifier != EXPI_RIGHT_PARENTHESIS))) {
	LD	BC,6
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_99
	LD	IY,(IX+6)
	LD	A,(IY+10)
	LD	(IX+-1),A
	OR	A,A
	JR	Z,L_98
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	(IX+-4),HL
	LD	IY,(HL)
	LD	BC,(IY+0)
	LD	(IX+-7),BC
	LD	HL,BC
	OR	A,A
	LD	BC,2
	SBC	HL,BC
	JR	Z,L_98
	LD	BC,5
	LD	HL,(IX+-7)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_99
	LD	HL,(IX+-4)
	LD	IY,(HL)
	LD	HL,(IY+3)
	LD	BC,45
	OR	A,A
	SBC	HL,BC
	JR	Z,L_99
L_98:
;  273	        append_child(tokens, new_literal(-1, 1, 1));
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,16777215
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  274	        append_child(tokens, new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 0));
	LD	BC,0
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  275	    } else {
	JR	L_100
L_99:
;  276	        append_child(tokens, new_expression(EXPT_OPERATION, identifier, 0));
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-10)
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  277	    }
L_100:
;  278	    
;  279	    return;
;  280	    
;  281	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _tokenize_operator_expression ***************************
;Name                         Addr/Register   Size   Type
;_new_expression                     IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;identifier                           IX-10      3   variable
;G_11                                  IX-7      3   variable
;G_12                                  IX-4      3   variable
;G_10                                  IX-1      1   variable
;source                                IX+9      1   parameter
;tokens                                IX+6      3   parameter


; Stack Frame Size: 22 (bytes)
;       Spill Code: 0 (instruction)


;  282	
;  283	void tokenize_control_expression(expression* tokens, char source) {
_tokenize_control_expression:
	LD	HL,-3
	CALL	__frameset
;  284	    
;  285	    expression_identifier identifier = get_control_identifier(source);
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	CALL	_get_control_identifier
	POP	BC
	LD	(IX+-3),HL
;  286	    
;  287	    if (identifier == EXPI_LEFT_PARENTHESIS) {
	LD	BC,44
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_103
;  288	        append_multiplication_if_necessary(tokens);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_append_multiplication_if_necessary
	POP	BC
;  289	    }
L_103:
;  290	    
;  291	    append_child(tokens, new_expression(EXPT_CONTROL, identifier, 0));
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	LD	BC,5
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  292	    
;  293	    return;
;  294	    
;  295	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _tokenize_control_expression ***************************
;Name                         Addr/Register   Size   Type
;_new_expression                     IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;identifier                            IX-3      3   variable
;source                                IX+9      1   parameter
;tokens                                IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


;  296	
;  297	uint8_t tokenize(expression* tokens, const char* query) {
_tokenize:
	LD	HL,-1
	CALL	__frameset
;  298	    
;  299	    uint8_t i;
;  300	    
;  301	    for (i = 0; query[i] != '\0'; i++) {
	LD	(IX+-1),0
	JR	L_116
L_114:
;  302	        
;  303	        if (query[i] == ' ') continue;
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+9)
	ADD	HL,BC
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	OR	A,A
	LD	BC,32
	SBC	HL,BC
	JR	Z,L_115
;  304	        
;  305	        switch (get_expression_type(query[i])) {
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+9)
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	PUSH	BC
	CALL	_get_expression_type
	POP	BC
	CALL	__case8
L__59:
	DW	3
	DB	1
	DW24	L_107	

	DB	2
	DW24	L_110	

	DB	5
	DW24	L_111	

	DW24	L_112	

;  306	            case EXPT_VALUE:
L_107:
;  307	                ERROR_CHECK(tokenize_value_expression(tokens, &i, query));
	LD	BC,(IX+9)
	PUSH	BC
	PEA	IX+-1
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_tokenize_value_expression
	POP	BC
	POP	BC
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	NZ,L_115
	LD	A,1
	JR	L_118
;  308	                break;
;  309	            case EXPT_OPERATION:
L_110:
;  310	                tokenize_operator_expression(tokens, query[i]);
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+9)
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_tokenize_operator_expression
	POP	BC
	POP	BC
;  311	                break;
	JR	L_115
;  312	            case EXPT_CONTROL:
L_111:
;  313	                tokenize_control_expression(tokens, query[i]);
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+9)
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_tokenize_control_expression
	POP	BC
	POP	BC
;  314	                break;
	JR	L_115
;  315	            default:
L_112:
;  316	                return set_error(ERRD_PARSER, ERRI_UNEXPECTED_CHARACTER, "");
	LD	BC,L__61
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,5
	PUSH	BC
	CALL	_set_error
	POP	BC
	POP	BC
	POP	BC
	JR	L_118
;  317	        }
;  318	        
;  319	    }
L_115:
	INC	(IX+-1)
L_116:
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+9)
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_114
;  320	    
;  321	    return RETS_SUCCESS;
	LD	A,2
;  322	    
;  323	}
L_118:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _tokenize ***************************
;Name                         Addr/Register   Size   Type
;_set_error                          IMPORT  -----   function
;i                                     IX-1      1   variable
;query                                 IX+9      3   parameter
;tokens                                IX+6      3   parameter


; Stack Frame Size: 13 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__61:
	DB	0
	SEGMENT CODE
;  324	
;  325	uint8_t validate(expression* tokens) {
_validate:
	LD	HL,-41
	CALL	__frameset
;  326	    
;  327	    uint8_t i;
;  328	    int8_t open_parentheses = 0;
	LD	(IX+-1),0
;  329	    expression* tuple[2];
;  330	    
;  331	    tuple[1] = tokens->children[0];
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-17),BC
	LD	HL,BC
	LEA	IY,IX+-7
	LD	BC,(HL)
	LD	(IY+3),BC
;  332	    
;  333	    for (i = 0; i < tokens->child_count; i++) {
	LD	(IX+-8),0
	JR	L_148
L_146:
;  334	        
;  335	        tuple[0] = tuple[1];
	LEA	HL,IX+-4
	LD	BC,(HL)
	LD	(IX+-7),BC
;  336	        tuple[1] = tokens->children[i];
	LD	BC,(IX+-17)
	LD	(IX+-11),BC
	LD	A,(IX+-8)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	(IX+-20),HL
	LD	BC,(IX+-11)
	ADD	HL,BC
	LD	(IX+-35),HL
	LD	IY,(IX+-35)
	LD	(IX+-41),IY	; spill
	LEA	HL,IX+-4
	LD	IY,(IX+-41)	; unspill
	LD	BC,(IY)
	LD	(HL),BC
;  337	        
;  338	        if (tokens->children[i]->identifier == EXPI_LEFT_PARENTHESIS) open_parentheses++;
	LD	HL,(IX+-35)
	OR	A,A
	LD	IY,(HL)
	LD	HL,(IY+3)
	LD	BC,44
	SBC	HL,BC
	JR	NZ,L_124
	INC	(IX+-1)
L_124:
;  339	        if (tokens->children[i]->identifier == EXPI_RIGHT_PARENTHESIS) open_parentheses--;
	LD	BC,(IX+-11)
	LD	(IX+-17),BC
	LD	BC,(IX+-20)
	LD	HL,(IX+-11)
	ADD	HL,BC
	LD	IY,(HL)
	LD	HL,(IY+3)
	OR	A,A
	LD	BC,45
	SBC	HL,BC
	JR	NZ,L_145
	DEC	(IX+-1)
L_145:
;  340	        
;  341	        if (tuple[0]->type == EXPT_VALUE) {
	LD	IY,(IX+-7)
	LD	HL,(IY+0)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_144
;  342	            
;  343	            if (tuple[0] == tuple[1]) continue;
	LEA	IY,IX+-4
	LD	(IX+-14),IY
	LD	HL,(IX+-14)
	LD	BC,(HL)
	LD	HL,(IX+-7)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_147
;  344	            
;  345	            if (tuple[1]->type == EXPT_VALUE) {
	LD	HL,(IX+-14)
	LD	IY,(HL)
	LD	BC,(IY+0)
	LD	(IX+-29),BC
	LD	HL,BC
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_130
;  346	                return set_error(ERRD_PARSER, ERRI_SYNTAX, "");
	LD	BC,L__69
	PUSH	BC
	LD	BC,5
	PUSH	BC
	PUSH	BC
	CALL	_set_error
	POP	BC
	POP	BC
	POP	BC
	JR	L_152
;  347	            } else if (tuple[1]->type == EXPT_FUNCTION) {
L_130:
	LD	BC,3
	LD	HL,(IX+-29)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_128
;  348	                return set_error(ERRD_PARSER, ERRI_SYNTAX, "");
	LD	BC,L__71
	PUSH	BC
	LD	BC,5
	PUSH	BC
	PUSH	BC
	CALL	_set_error
	POP	BC
	POP	BC
	POP	BC
	JR	L_152
;  349	            } else if (tuple[1]->identifier == EXPI_LEFT_PARENTHESIS) {
L_128:
	LD	HL,(IX+-14)
	LD	IY,(HL)
	LD	HL,(IY+3)
	LD	BC,44
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_147
;  350	                return set_error(ERRD_PARSER, ERRI_SYNTAX, "");
	LD	BC,L__73
	PUSH	BC
	LD	BC,5
	PUSH	BC
	PUSH	BC
	CALL	_set_error
	POP	BC
	POP	BC
	POP	BC
	JR	L_152
;  351	            }
;  352	            
;  353	        } else if (tuple[0]->type == EXPT_OPERATION) {
L_144:
	LD	IY,(IX+-7)
	LD	HL,(IY+0)
	LD	BC,2
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_142
;  354	            
;  355	            if (tuple[1]->type == EXPT_OPERATION) {
	LEA	BC,IX+-4
	LD	(IX+-32),BC
	LD	HL,BC
	LD	IY,(HL)
	LD	BC,(IY+0)
	LD	(IX+-23),BC
	LD	HL,BC
	LD	BC,2
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_135
;  356	                return set_error(ERRD_PARSER, ERRI_SYNTAX, "");
	LD	BC,L__76
	PUSH	BC
	LD	BC,5
	PUSH	BC
	PUSH	BC
	CALL	_set_error
	POP	BC
	POP	BC
	POP	BC
	JR	L_152
;  357	            } else if (tuple[1]->type == EXPT_CONTROL && tuple[1]->identifier != EXPI_LEFT_PARENTHESIS) {
L_135:
	LD	BC,5
	LD	HL,(IX+-23)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_147
	LD	HL,(IX+-32)
	LD	IY,(HL)
	LD	HL,(IY+3)
	LD	BC,44
	OR	A,A
	SBC	HL,BC
	JR	Z,L_147
;  358	                return set_error(ERRD_PARSER, ERRI_SYNTAX, "");
	LD	BC,L__79
	PUSH	BC
	LD	BC,5
	PUSH	BC
	PUSH	BC
	CALL	_set_error
	POP	BC
	POP	BC
	POP	BC
	JR	L_152
;  359	            }
;  360	            
;  361	        } else if (tuple[0]->type == EXPT_FUNCTION) {
L_142:
	LD	IY,(IX+-7)
	LD	HL,(IY+0)
	LD	BC,3
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_147
;  362	            
;  363	            if (tuple[0] == tuple[1] && i == 0) continue;
	LEA	IY,IX+-4
	LD	(IX+-26),IY
	LD	HL,(IX+-26)
	LD	BC,(HL)
	LD	HL,(IX+-7)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_139
	LD	A,(IX+-8)
	OR	A,A
	JR	Z,L_147
L_139:
;  364	            
;  365	            if (tuple[1]->identifier != EXPI_LEFT_PARENTHESIS) {
	LD	HL,(IX+-26)
	LD	IY,(HL)
	LD	HL,(IY+3)
	LD	BC,44
	OR	A,A
	SBC	HL,BC
	JR	Z,L_147
;  366	                return set_error(ERRD_PARSER, ERRI_SYNTAX, "");
	LD	BC,L__84
	PUSH	BC
	LD	BC,5
	PUSH	BC
	PUSH	BC
	CALL	_set_error
	POP	BC
	POP	BC
	POP	BC
	JR	L_152
;  367	            }
;  368	            
;  369	        }
;  370	        
;  371	    }
L_147:
	INC	(IX+-8)
L_148:
	LD	A,(IX+-8)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_146
;  372	    
;  373	    if (open_parentheses < 0) return set_error(ERRD_PARSER, ERRI_PARENTHESIS_MISMATCH, "");
	LD	A,(IX+-1)
	OR	A,A
	JP	P,L_151
	LD	BC,L__87
	PUSH	BC
	LD	BC,6
	PUSH	BC
	LD	BC,5
	PUSH	BC
	CALL	_set_error
	POP	BC
	POP	BC
	POP	BC
	JR	L_152
L_151:
;  374	    
;  375	    return RETS_SUCCESS;
	LD	A,2
;  376	    
;  377	}
L_152:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _validate ***************************
;Name                         Addr/Register   Size   Type
;_set_error                          IMPORT  -----   function
;G_20                                 IX-32      3   variable
;G_17                                 IX-29      3   variable
;G_21                                 IX-26      3   variable
;G_19                                 IX-23      3   variable
;G_15                                 IX-20      3   variable
;G_13                                 IX-17      3   variable
;G_16                                 IX-14      3   variable
;G_14                                 IX-11      3   variable
;i                                     IX-8      1   variable
;tuple                                 IX-7      6   variable
;open_parentheses                      IX-1      1   variable
;tokens                                IX+6      3   parameter


; Stack Frame Size: 50 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__69:
	DB	0
L__71:
	DB	0
L__73:
	DB	0
L__76:
	DB	0
L__79:
	DB	0
L__84:
	DB	0
L__87:
	DB	0
	SEGMENT CODE
;  378	
;  379	void merge_expressions_with_operator(expression* output_stack, expression* operator_stack) {
_merge_expressions_with_operator:
	LD	HL,-11
	CALL	__frameset
;  380	    
;  381	    uint8_t i;
;  382	    uint8_t child_count = 0;
	LD	(IX+-1),0
;  383	    
;  384	    switch (operator_stack->children[operator_stack->child_count - 1]->type) {
	LD	IY,(IX+9)
	LD	A,(IY+10)
	LD	BC,(IY+11)
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	ADD	HL,BC
	LD	(IX+-5),HL
	LD	IY,(HL)
	LD	HL,(IY+0)
	CALL	__case8
L__89:
	DW	3
	DB	2
	DW24	L_153	

	DB	3
	DW24	L_156	

	DB	5
	DW24	L_159	

	DW24	L_166	

;  385	        case EXPT_OPERATION:
L_153:
;  386	            child_count = 2;
	LD	(IX+-1),2
;  387	            break;
	JR	L_166
;  388	        case EXPT_FUNCTION:
;  389	            while (output_stack->children[output_stack->child_count - child_count - 1]->identifier != EXPI_LEFT_PARENTHESIS) {
L_157:
;  390	                child_count++;
	INC	(IX+-1)
;  391	            }
L_156:
	LD	IY,(IX+6)
	LD	A,(IY+10)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	DE,HL
	LD	HL,BC
	SBC	HL,DE
	DEC	HL
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IY+11)
	ADD	HL,BC
	LD	IY,(HL)
	LD	HL,(IY+3)
	OR	A,A
	LD	BC,44
	SBC	HL,BC
	JR	NZ,L_157
;  392	            break;
	JR	L_166
;  393	        case EXPT_CONTROL:
L_159:
;  394	            free_expression(operator_stack->children[operator_stack->child_count - 1], false);
	LD	BC,0
	PUSH	BC
	LD	HL,(IX+-5)
	LD	BC,(HL)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  395	            operator_stack->child_count--;
	LD	IY,(IX+9)
	LD	A,(IY+10)
	DEC	A
	LD	(IY+10),A
;  396	            return;
	JR	L_172
;  397	        default:
;  398	            break;
;  399	    }
L_166:
;  400	    
;  401	    for (i = 0; i < child_count; i++) {
	LD	(IX+-2),0
	JR	L_165
L_163:
;  402	        append_child(operator_stack->children[operator_stack->child_count - 1], output_stack->children[output_stack->child_count - child_count + i]);
	LD	IY,(IX+6)
	LD	A,(IY+10)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	A,(IX+-2)
	OR	A,A
	LD	DE,HL
	LD	HL,BC
	SBC	HL,DE
	LD	BC,HL
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IY+11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	IY,(IX+9)
	LD	A,(IY+10)
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IY+11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
	INC	(IX+-2)
;  403	    }
L_165:
	LD	A,(IX+-2)
	CP	A,(IX+-1)
	JR	C,L_163
;  404	    
;  405	    if (operator_stack->children[operator_stack->child_count - 1]->type == EXPT_FUNCTION) {
	LD	IY,(IX+9)
	LD	A,(IY+10)
	LD	BC,(IY+11)
	LD	DE,3
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	(IX+-8),DE	; spill
	LD	(IX+-11),HL	; spill
	LD	DE,(IX+-8)	; unspill
	ADD	HL,HL
	LD	(IX+-8),DE	; spill
	LD	DE,(IX+-11)	; unspill
	ADD	HL,DE
	LD	DE,(IX+-8)	; unspill
	ADD	HL,BC
	LD	IY,(HL)
	LD	HL,(IY+0)
	OR	A,A
	SBC	HL,DE
	JR	NZ,L_170
;  406	        output_stack->child_count--;
	LD	IY,(IX+6)
	LD	A,(IY+10)
	DEC	A
	LD	(IY+10),A
;  407	    }
L_170:
;  408	    
;  409	    output_stack->child_count -= child_count;
	LD	IY,(IX+6)
	LD	A,(IY+10)
	SUB	A,(IX+-1)
	LD	(IY+10),A
;  410	    append_child(output_stack, operator_stack->children[operator_stack->child_count - 1]);
	LD	IY,(IX+9)
	LD	A,(IY+10)
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	BC,HL
	ADD	HL,HL
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  411	    operator_stack->child_count--;
	LD	IY,(IX+9)
	LD	A,(IY+10)
	DEC	A
	LD	(IY+10),A
;  412	    
;  413	    return;
;  414	    
;  415	}
L_172:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _merge_expressions_with_operator ***************************
;Name                         Addr/Register   Size   Type
;_append_child                       IMPORT  -----   function
;_free_expression                    IMPORT  -----   function
;G_22                                  IX-5      3   variable
;i                                     IX-2      1   variable
;child_count                           IX-1      1   variable
;operator_stack                        IX+9      3   parameter
;output_stack                          IX+6      3   parameter


; Stack Frame Size: 23 (bytes)
;       Spill Code: 0 (instruction)


;  416	
;  417	void parse_control_expression(expression* tokens, uint8_t* index, expression* output_stack, expression* operator_stack) {
_parse_control_expression:
	LD	HL,-19
	CALL	__frameset
;  418	    
;  419	    switch (tokens->children[*index]->identifier) {
	LD	HL,(IX+9)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	(IX+-7),HL
	LD	IY,(HL)
	LD	HL,(IY+3)
	CALL	__seqcase
L__94:
	DW	3
	DW	43
	DB	0
	DW24	L_174	

	DW24	L_177	

	DW24	L_179	

	DW24	L_187	

;  420	            
;  421	        case EXPI_COMMA:
;  422	            
;  423	            while (operator_stack->children[operator_stack->child_count - 1]->identifier != EXPI_LEFT_PARENTHESIS) {
L_175:
;  424	                merge_expressions_with_operator(output_stack, operator_stack);
	LD	BC,(IX+15)
	PUSH	BC
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_merge_expressions_with_operator
	POP	BC
	POP	BC
;  425	            }
L_174:
	LD	IY,(IX+15)
	LD	A,(IY+10)
	LD	BC,(IY+11)
	LD	DE,44
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	(IX+-16),DE	; spill
	LD	(IX+-19),HL	; spill
	LD	DE,(IX+-16)	; unspill
	ADD	HL,HL
	LD	(IX+-16),DE	; spill
	LD	DE,(IX+-19)	; unspill
	ADD	HL,DE
	LD	DE,(IX+-16)	; unspill
	ADD	HL,BC
	LD	IY,(HL)
	LD	HL,(IY+3)
	OR	A,A
	SBC	HL,DE
	JR	NZ,L_175
;  426	            
;  427	            break;
	JR	L_187
;  428	            
;  429	        case EXPI_LEFT_PARENTHESIS:
L_177:
;  430	            append_child(operator_stack, tokens->children[*index]);
	LD	HL,(IX+-7)
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+15)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  431	            break;
	JR	L_187
;  432	            
;  433	        case EXPI_RIGHT_PARENTHESIS:
;  434	            
;  435	            while (operator_stack->children[operator_stack->child_count - 1]->identifier != EXPI_LEFT_PARENTHESIS) {
L_180:
;  436	                merge_expressions_with_operator(output_stack, operator_stack);
	LD	BC,(IX+15)
	PUSH	BC
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_merge_expressions_with_operator
	POP	BC
	POP	BC
;  437	            }
L_179:
	LD	IY,(IX+15)
	LD	A,(IY+10)
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	BC,HL
	ADD	HL,HL
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	(IX+-4),HL
	LD	IY,(HL)
	LD	HL,(IY+3)
	OR	A,A
	LD	BC,44
	SBC	HL,BC
	JR	NZ,L_180
;  438	            
;  439	            free_expression(operator_stack->children[operator_stack->child_count - 1], false);
	LD	BC,0
	PUSH	BC
	LD	HL,(IX+-4)
	LD	BC,(HL)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  440	            operator_stack->child_count--;
	LD	IY,(IX+15)
	LD	A,(IY+10)
	DEC	A
	LD	(IY+10),A
;  441	            
;  442	            if (operator_stack->child_count > 0) {
	LD	A,(IY+10)
	LD	(IX+-1),A
	XOR	A,A
	CP	A,(IX+-1)
	JR	NC,L_187
;  443	                if (operator_stack->children[operator_stack->child_count - 1]->type == EXPT_FUNCTION) {
	LD	A,(IX+-1)
	LD	IY,(IX+15)
	LD	BC,(IY+11)
	LD	(IX+-13),BC	; spill
	LD	DE,3
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IX+-13)	; unspill
	ADD	HL,BC
	LD	IY,(HL)
	LD	HL,(IY+0)
	OR	A,A
	SBC	HL,DE
	JR	NZ,L_187
;  444	                    merge_expressions_with_operator(output_stack, operator_stack);
	LD	BC,(IX+15)
	PUSH	BC
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_merge_expressions_with_operator
	POP	BC
	POP	BC
;  445	                }
;  446	            }
;  447	            
;  448	            break;
;  449	            
;  450	        default:
;  451	            break;
;  452	            
;  453	    }
L_187:
;  454	    
;  455	    return;
;  456	    
;  457	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _parse_control_expression ***************************
;Name                         Addr/Register   Size   Type
;_free_expression                    IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;G_23                                  IX-7      3   variable
;G_24                                  IX-4      3   variable
;G_25                                  IX-1      1   variable
;operator_stack                       IX+15      3   parameter
;output_stack                         IX+12      3   parameter
;index                                 IX+9      3   parameter
;tokens                                IX+6      3   parameter


; Stack Frame Size: 37 (bytes)
;       Spill Code: 0 (instruction)


;  458	
;  459	void parse(expression* tokens) {
_parse:
	LD	HL,-29
	CALL	__frameset
;  460	    
;  461	    uint8_t i;
;  462	    expression* output_stack = new_expression(EXPT_STRUCTURE, EXPI_LIST, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-7),HL
;  463	    expression* operator_stack = new_expression(EXPT_STRUCTURE, EXPI_LIST, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-4),HL
;  464	    
;  465	    for (i = 0; i < tokens->child_count; i++) {
	LD	(IX+-1),0
	JR	L_203
L_201:
;  466	        
;  467	        switch (tokens->children[i]->type) {
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-14),BC
	LD	A,(IX+-1)
	LD	BC,(IX+-14)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	ADD	HL,BC
	LD	IY,(HL)
	LD	HL,(IY+0)
	CALL	__case8
L__100:
	DW	4
	DB	1
	DW24	L_190	

	DB	2
	DW24	L_195	

	DB	3
	DW24	L_198	

	DB	5
	DW24	L_199	

	DW24	L_202	

;  468	                
;  469	            case EXPT_VALUE:
L_190:
;  470	                append_child(output_stack, tokens->children[i]);
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IX+-14)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  471	                break;
	JR	L_202
;  472	                
;  473	            case EXPT_OPERATION:
;  474	                while (operator_stack->child_count > 0 &&
L_196:
;  475	                       tokens->children[i]->identifier <= operator_stack->children[operator_stack->child_count - 1]->identifier &&
;  476	                       tokens->children[i]->identifier != EXPI_EXPONENTATION &&
;  477	                       operator_stack->children[operator_stack->child_count - 1]->identifier != EXPI_LEFT_PARENTHESIS) {
;  478	                    merge_expressions_with_operator(output_stack, operator_stack);
	LD	BC,(IX+-4)
	PUSH	BC
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_merge_expressions_with_operator
	POP	BC
	POP	BC
;  479	                }
L_195:
	LD	IY,(IX+-4)
	LD	A,(IY+10)
	LD	(IX+-8),A
	XOR	A,A
	CP	A,(IX+-8)
	JR	NC,L_197
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-11),BC
	LD	A,(IX+-8)
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	DE,HL
	ADD	HL,HL
	LD	IY,(IX+-4)
	LD	BC,(IY+11)
	ADD	HL,DE
	ADD	HL,BC
	LD	IY,(HL)
	LD	BC,(IY+3)
	LD	(IX+-17),BC
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IX+-11)
	ADD	HL,BC
	LD	IY,(HL)
	LD	BC,(IY+3)
	OR	A,A
	LD	HL,(IX+-17)
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_197
	LD	A,(IX+-1)
	LD	BC,(IX+-11)
	LD	(IX+-23),BC	; spill
	LD	DE,9
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IX+-23)	; unspill
	ADD	HL,BC
	LD	IY,(HL)
	OR	A,A
	LD	HL,(IY+3)
	SBC	HL,DE
	JR	Z,L_197
	LD	BC,44
	LD	HL,(IX+-17)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_196
L_197:
;  480	                append_child(operator_stack, tokens->children[i]);
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	ADD	HL,DE
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  481	                break;
	JR	L_202
;  482	                
;  483	            case EXPT_FUNCTION:
L_198:
;  484	                append_child(output_stack, new_expression(EXPT_CONTROL, EXPI_LEFT_PARENTHESIS, 0));
	LD	BC,0
	PUSH	BC
	LD	BC,44
	PUSH	BC
	LD	BC,5
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  485	                append_child(operator_stack, tokens->children[i]);
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  486	                break;
	JR	L_202
;  487	                
;  488	            case EXPT_CONTROL:
L_199:
;  489	                parse_control_expression(tokens, &i, output_stack, operator_stack);
	LD	BC,(IX+-4)
	PUSH	BC
	LD	BC,(IX+-7)
	PUSH	BC
	PEA	IX+-1
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_parse_control_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  490	                break;
;  491	                
;  492	            default:
;  493	                break;
;  494	                
;  495	        }
;  496	        
;  497	    }
L_202:
	INC	(IX+-1)
L_203:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_201
;  498	    
;  499	    while (operator_stack->child_count > 0) {
	JR	L_204
L_205:
;  500	        merge_expressions_with_operator(output_stack, operator_stack);
	LD	BC,(IX+-4)
	PUSH	BC
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_merge_expressions_with_operator
	POP	BC
	POP	BC
;  501	    }
L_204:
	XOR	A,A
	LD	IY,(IX+-4)
	CP	A,(IY+10)
	JR	C,L_205
;  502	    
;  503	    *tokens = *copy_expression(output_stack->children[0]);
	LD	IY,(IX+-7)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	DE,(IX+6)
	LD	BC,24
;  504	    
;  505	    free_expression(output_stack, false);
	LD	(IX+-26),HL	; spill
	OR	A,A
	SBC	HL,HL
	LD	(IX+-29),HL	; spill
	LD	HL,(IX+-26)	; unspill
	LD	(IX+-26),HL	; spill
	LD	HL,(IX+-29)	; unspill
	PUSH	HL
	LD	HL,(IX+-26)	; unspill
	LDIR	
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  506	    free_expression(operator_stack, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  507	    
;  508	    return;
;  509	    
;  510	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _parse ***************************
;Name                         Addr/Register   Size   Type
;_free_expression                    IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;G_29                                 IX-17      3   variable
;G_26                                 IX-14      3   variable
;G_28                                 IX-11      3   variable
;G_27                                  IX-8      1   variable
;output_stack                          IX-7      3   variable
;operator_stack                        IX-4      3   variable
;i                                     IX-1      1   variable
;tokens                                IX+6      3   parameter


; Stack Frame Size: 38 (bytes)
;       Spill Code: 0 (instruction)


	XREF _simplify:ROM
	XREF _append_child:ROM
	XREF _free_expression:ROM
	XREF _copy_expression:ROM
	XREF _new_symbol:ROM
	XREF _new_literal:ROM
	XREF _new_expression:ROM
	XREF _keyword_identifiers:ROM
	XREF _keyword_strings:ROM
	XREF _string_to_lower:ROM
	XREF _set_error:ROM
	XREF _smart_free:ROM
	XREF _isdigit:ROM
	XREF _isalpha:ROM
	XREF _strlen:ROM
	XREF _strstr:ROM
	XREF _strchr:ROM
	XREF __ladd:ROM
	XREF __lmulu:ROM
	XREF __itol:ROM
	XREF __frameset0:ROM
	XREF __frameset:ROM
	XREF __setflag:ROM
	XREF __icmpzero:ROM
	XREF __case8:ROM
	XREF __seqcase:ROM
	XDEF _parse
	XDEF _parse_control_expression
	XDEF _merge_expressions_with_operator
	XDEF _validate
	XDEF _tokenize
	XDEF _tokenize_control_expression
	XDEF _tokenize_operator_expression
	XDEF _tokenize_value_expression
	XDEF _string_to_literal
	XDEF _tokenize_buffer
	XDEF _append_multiplication_if_necessary
	XDEF _get_control_identifier
	XDEF _get_operator_identifier
	XDEF _get_value_identifier
	XDEF _get_expression_type
	END
