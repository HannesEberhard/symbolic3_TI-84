; Zilog eZ80 ANSI C Compiler Release 3.4
; -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"SRC\SYMBOLIC4\SRC\EXPRESSION.C"
	.assume ADL=1
	SEGMENT STRSECT
L__0:
	DB	"="
	DB	0
L__1:
	DB	"+"
	DB	0
L__2:
	DB	"-"
	DB	0
L__3:
	DB	"*"
	DB	0
L__4:
	DB	"/"
	DB	0
L__5:
	DB	"^"
	DB	0
L__6:
	DB	"abs"
	DB	0
L__7:
	DB	"ln"
	DB	0
L__8:
	DB	"log"
	DB	0
L__9:
	DB	"arcsin"
	DB	0
L__10:
	DB	"arccos"
	DB	0
L__11:
	DB	"arctan"
	DB	0
L__12:
	DB	"sin"
	DB	0
L__13:
	DB	"cos"
	DB	0
L__14:
	DB	"tan"
	DB	0
L__15:
	DB	"simplify"
	DB	0
L__16:
	DB	"simp"
	DB	0
L__17:
	DB	"solve"
	DB	0
L__18:
	DB	"Factors"
	DB	0
L__19:
	DB	"Fac"
	DB	0
L__20:
	DB	"Value"
	DB	0
L__21:
	DB	"Val"
	DB	0
L__22:
	DB	"Derivative"
	DB	0
L__23:
	DB	"Deriv"
	DB	0
L__24:
	DB	"Integral"
	DB	0
L__25:
	DB	"Int"
	DB	0
L__26:
	DB	"Area"
	DB	0
L__27:
	DB	"StationaryPoints"
	DB	0
L__28:
	DB	"StatPts"
	DB	0
L__29:
	DB	"InflectionPoints"
	DB	0
L__30:
	DB	"InflPts"
	DB	0
L__31:
	DB	"Tangent"
	DB	0
L__32:
	DB	"Tang"
	DB	0
L__33:
	DB	"VectorMagnitude"
	DB	0
L__34:
	DB	"VMag"
	DB	0
L__35:
	DB	"VectorNormalized"
	DB	0
L__36:
	DB	"VNormed"
	DB	0
L__37:
	DB	"Normal"
	DB	0
L__38:
	DB	"Norm"
	DB	0
L__39:
	DB	"VectorAngle"
	DB	0
L__40:
	DB	"VAng"
	DB	0
L__41:
	DB	"Angle"
	DB	0
L__42:
	DB	"Ang"
	DB	0
L__43:
	DB	"VectorDotProduct"
	DB	0
L__44:
	DB	"VDotP"
	DB	0
L__45:
	DB	"VectorCrossProduct"
	DB	0
L__46:
	DB	"VCrossP"
	DB	0
L__47:
	DB	"VectorTripleProduct"
	DB	0
L__48:
	DB	"VTripleP"
	DB	0
L__49:
	DB	"approximate"
	DB	0
L__50:
	DB	"approx"
	DB	0
L__51:
	DB	"List"
	DB	0
L__52:
	DB	"Ls"
	DB	0
L__53:
	DB	"Vector"
	DB	0
L__54:
	DB	"Vec"
	DB	0
L__55:
	DB	","
	DB	0
L__56:
	DB	"("
	DB	0
L__57:
	DB	")"
	DB	0
L__58:
	DB	"parse"
	DB	0
	SEGMENT DATA
_keyword_strings:
	DW24	L__0
	DW24	L__1
	DW24	L__2
	DW24	L__3
	DW24	L__4
	DW24	L__5
	DW24	L__6
	DW24	L__7
	DW24	L__8
	DW24	L__9
	DW24	L__10
	DW24	L__11
	DW24	L__12
	DW24	L__13
	DW24	L__14
	DW24	L__15
	DW24	L__16
	DW24	L__17
	DW24	L__18
	DW24	L__19
	DW24	L__20
	DW24	L__21
	DW24	L__22
	DW24	L__23
	DW24	L__24
	DW24	L__25
	DW24	L__26
	DW24	L__27
	DW24	L__28
	DW24	L__29
	DW24	L__30
	DW24	L__31
	DW24	L__32
	DW24	L__33
	DW24	L__34
	DW24	L__35
	DW24	L__36
	DW24	L__37
	DW24	L__38
	DW24	L__39
	DW24	L__40
	DW24	L__41
	DW24	L__42
	DW24	L__43
	DW24	L__44
	DW24	L__45
	DW24	L__46
	DW24	L__47
	DW24	L__48
	DW24	L__49
	DW24	L__50
	DW24	L__51
	DW24	L__52
	DW24	L__53
	DW24	L__54
	DW24	L__55
	DW24	L__56
	DW24	L__57
	DW24	L__58
	DW24	0
_keyword_identifiers:
	DW	4
	DB	0
	DW	5
	DB	0
	DW	6
	DB	0
	DW	7
	DB	0
	DW	8
	DB	0
	DW	9
	DB	0
	DW	10
	DB	0
	DW	11
	DB	0
	DW	12
	DB	0
	DW	16
	DB	0
	DW	17
	DB	0
	DW	18
	DB	0
	DW	13
	DB	0
	DW	14
	DB	0
	DW	15
	DB	0
	DW	19
	DB	0
	DW	19
	DB	0
	DW	20
	DB	0
	DW	21
	DB	0
	DW	21
	DB	0
	DW	22
	DB	0
	DW	22
	DB	0
	DW	23
	DB	0
	DW	23
	DB	0
	DW	24
	DB	0
	DW	24
	DB	0
	DW	25
	DB	0
	DW	26
	DB	0
	DW	26
	DB	0
	DW	27
	DB	0
	DW	27
	DB	0
	DW	28
	DB	0
	DW	28
	DB	0
	DW	31
	DB	0
	DW	31
	DB	0
	DW	32
	DB	0
	DW	32
	DB	0
	DW	29
	DB	0
	DW	29
	DB	0
	DW	33
	DB	0
	DW	33
	DB	0
	DW	30
	DB	0
	DW	30
	DB	0
	DW	34
	DB	0
	DW	34
	DB	0
	DW	35
	DB	0
	DW	35
	DB	0
	DW	36
	DB	0
	DW	36
	DB	0
	DW	37
	DB	0
	DW	37
	DB	0
	DW	40
	DB	0
	DW	40
	DB	0
	DW	40
	DB	0
	DW	40
	DB	0
	DW	43
	DB	0
	DW	44
	DB	0
	DW	45
	DB	0
	DW	46
	DB	0
	DW	0
	DB	0
;    1	
;    2	/*
;    3	 
;    4	 Copyright (c) 2019 Hannes Eberhard
;    5	 
;    6	 Permission is hereby granted, free of charge, to any person obtaining a copy
;    7	 of this software and associated documentation files (the "Software"), to deal
;    8	 in the Software without restriction, including without limitation the rights
;    9	 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
;   10	 copies of the Software, and to permit persons to whom the Software is
;   11	 furnished to do so, subject to the following conditions:
;   12	 
;   13	 The above copyright notice and this permission notice shall be included in all
;   14	 copies or substantial portions of the Software.
;   15	 
;   16	 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;   17	 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;   18	 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;   19	 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;   20	 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;   21	 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;   22	 SOFTWARE.
;   23	 
;   24	 */
;   25	
;   26	#include "symbolic4.h"
;   27	
;   28	char* keyword_strings[] = {
;   29	    "=",
;   30	    "+",
;   31	    "-",
;   32	    "*",
;   33	    "/",
;   34	    "^",
;   35	    "abs",
;   36	    "ln",
;   37	    "log",
;   38	    "arcsin",
;   39	    "arccos",
;   40	    "arctan",
;   41	    "sin",
;   42	    "cos",
;   43	    "tan",
;   44	    "simplify",
;   45	    "simp",
;   46	    "solve",
;   47	    "Factors",
;   48	    "Fac",
;   49	    "Value",
;   50	    "Val",
;   51	    "Derivative",
;   52	    "Deriv",
;   53	    "Integral",
;   54	    "Int",
;   55	    "Area",
;   56	    "StationaryPoints",
;   57	    "StatPts",
;   58	    "InflectionPoints",
;   59	    "InflPts",
;   60	    "Tangent",
;   61	    "Tang",
;   62	    "VectorMagnitude",
;   63	    "VMag",
;   64	    "VectorNormalized",
;   65	    "VNormed",
;   66	    "Normal",
;   67	    "Norm",
;   68	    "VectorAngle",
;   69	    "VAng",
;   70	    "Angle",
;   71	    "Ang",
;   72	    "VectorDotProduct",
;   73	    "VDotP",
;   74	    "VectorCrossProduct",
;   75	    "VCrossP",
;   76	    "VectorTripleProduct",
;   77	    "VTripleP",
;   78	    "approximate",
;   79	    "approx",
;   80	    "List",
;   81	    "Ls",
;   82	    "Vector",
;   83	    "Vec",
;   84	    ",",
;   85	    "(",
;   86	    ")",
;   87	    "parse",
;   88	    NULL
;   89	};
;   90	
;   91	expression_identifier keyword_identifiers[] = {
	SEGMENT CODE
;   92	    EXPI_EQUATION,
;   93	    EXPI_ADDITION,
;   94	    EXPI_SUBTRACTION,
;   95	    EXPI_MULTIPLICATION,
;   96	    EXPI_DIVISION,
;   97	    EXPI_EXPONENTATION,
;   98	    EXPI_ABS,
;   99	    EXPI_LN,
;  100	    EXPI_LOG,
;  101	    EXPI_ARCSIN,
;  102	    EXPI_ARCCOS,
;  103	    EXPI_ARCTAN,
;  104	    EXPI_SIN,
;  105	    EXPI_COS,
;  106	    EXPI_TAN,
;  107	    EXPI_SIMPLIFY,
;  108	    EXPI_SIMPLIFY,
;  109	    EXPI_SOLVE,
;  110	    EXPI_FACTORS,
;  111	    EXPI_FACTORS,
;  112	    EXPI_VALUE,
;  113	    EXPI_VALUE,
;  114	    EXPI_DERIVATIVE,
;  115	    EXPI_DERIVATIVE,
;  116	    EXPI_INTEGRAL,
;  117	    EXPI_INTEGRAL,
;  118	    EXPI_AREA,
;  119	    EXPI_STATIONARY_POINTS,
;  120	    EXPI_STATIONARY_POINTS,
;  121	    EXPI_INFLECTION_POINTS,
;  122	    EXPI_INFLECTION_POINTS,
;  123	    EXPI_TANGENT,
;  124	    EXPI_TANGENT,
;  125	    EXPI_V_MAG,
;  126	    EXPI_V_MAG,
;  127	    EXPI_V_NORMALIZED,
;  128	    EXPI_V_NORMALIZED,
;  129	    EXPI_NORMAL,
;  130	    EXPI_NORMAL,
;  131	    EXPI_V_ANGLE,
;  132	    EXPI_V_ANGLE,
;  133	    EXPI_ANGLE,
;  134	    EXPI_ANGLE,
;  135	    EXPI_V_DOT_PRODUCT,
;  136	    EXPI_V_DOT_PRODUCT,
;  137	    EXPI_V_CROSS_PRODUCT,
;  138	    EXPI_V_CROSS_PRODUCT,
;  139	    EXPI_V_TRIPLE_PRODUCT,
;  140	    EXPI_V_TRIPLE_PRODUCT,
;  141	    EXPI_APPROXIMATE,
;  142	    EXPI_APPROXIMATE,
;  143	    EXPI_LIST,
;  144	    EXPI_LIST,
;  145	    EXPI_LIST,
;  146	    EXPI_LIST,
;  147	    EXPI_COMMA,
;  148	    EXPI_LEFT_PARENTHESIS,
;  149	    EXPI_RIGHT_PARENTHESIS,
;  150	    EXPI_PARSE,
;  151	    EXPI_NULL
;  152	};
;  153	
;  154	void expression_to_infix(char* buffer, const expression* souce);
;  155	void expression_to_tikz(char* buffer, const expression* source);
;  156	
;  157	/**
;  158	 
;  159	 @brief Allocates and initializes a new expression with the arguments
;  160	 provided
;  161	 
;  162	 @details
;  163	 This function returns a new expression which is initialized with
;  164	 the arguments provided and in sign = 1. This function is especially
;  165	 useful when being nested to build up more complex expressions in one
;  166	 line. Children are not copied.
;  167	 
;  168	 @param[in] type The expression type.
;  169	 @param[in] identifier The expression identifier.
;  170	 @param[in] child_count The number of children. It must match the
;  171	 actual number of children provided.
;  172	 @param[in] ... The child expressions. They may be calls to
;  173	 @c new_expression().
;  174	 
;  175	 @return
;  176	 - The initialized expression.
;  177	 
;  178	 @see
;  179	 - new_literal()
;  180	 - new_symbol()
;  181	 
;  182	 */
;  183	expression* new_expression(expression_type type, expression_identifier identifier, uint8_t child_count, ...) {
_new_expression:
	LD	HL,-7
	CALL	__frameset
;  184	    
;  185	    uint8_t i;
;  186	    va_list arguments;
;  187	    expression* result = smart_alloc(1, sizeof(expression));
	LD	BC,24
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_smart_alloc
	POP	BC
	POP	BC
	LD	(IX+-4),HL
;  188	    
;  189	    result->type = type;
	LD	BC,(IX+6)
	LD	IY,(IX+-4)
	LD	(IY+0),BC
;  190	    result->identifier = identifier;
	LD	BC,(IX+9)
	LD	(IY+3),BC
;  191	    result->sign = 1;
	LD	(IY+6),1
;  192	    
;  193	    va_start(arguments, child_count);
	LEA	IY,IX+15
	LD	(IX+-7),IY
;  194	    
;  195	    for (i = 0; i < child_count; i++) {
	LD	(IX+-1),0
	JR	L_3
L_1:
;  196	        append_child(result, va_arg(arguments, expression*));
	LD	IY,(IX+-7)
	LEA	BC,IY+3
	LD	(IX+-7),BC
	LD	IY,(IX+-7)
	LEA	HL,IY+-3
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
	INC	(IX+-1)
;  197	    }
L_3:
	LD	A,(IX+-1)
	CP	A,(IX+12)
	JR	C,L_1
;  198	    
;  199	    va_end(arguments);
;  200	    
;  201	    return result;
	LD	HL,(IX+-4)
;  202	    
;  203	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _new_expression ***************************
;Name                         Addr/Register   Size   Type
;_append_child                       IMPORT  -----   function
;_smart_alloc                        IMPORT  -----   function
;arguments                             IX-7      3   variable
;result                                IX-4      3   variable
;i                                     IX-1      1   variable
;child_count                          IX+12      1   parameter
;identifier                            IX+9      3   parameter
;type                                  IX+6      3   parameter


; Stack Frame Size: 22 (bytes)
;       Spill Code: 0 (instruction)


;  204	
;  205	/**
;  206	 
;  207	 @brief Allocates and initializes a new literal expression
;  208	 
;  209	 @details
;  210	 This function returns a new literal which is initialized with the
;  211	 arguments provided. The result is automatically reduced.
;  212	 
;  213	 @param[in] sign (either 1 or -1)
;  214	 @param[in] numerator The numeric numerator.
;  215	 @param[in] denominator The numeric denominator.
;  216	 
;  217	 @return
;  218	 - The initialized literal.
;  219	 
;  220	 @see
;  221	 - new_expression()
;  222	 - new_symbol()
;  223	 
;  224	 */
;  225	expression* new_literal(int8_t sign, uintmax_t numerator, uintmax_t denominator) {
_new_literal:
	LD	HL,-3
	CALL	__frameset
;  226	    expression* result = new_expression(EXPT_VALUE, EXPI_LITERAL, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-3),HL
;  227	    result->sign = sign;
	LD	A,(IX+6)
	LD	IY,(IX+-3)
	LD	(IY+6),A
;  228	    result->value.numeric.numerator = numerator;
	LD	BC,(IX+9)
	LD	A,(IX+12)
	LD	(IY+14),BC
	LD	(IY+17),A
;  229	    result->value.numeric.denominator = denominator;
	LD	BC,(IX+15)
	LD	A,(IX+18)
	LD	(IY+18),BC
	LD	(IY+21),A
;  230	    return result;
	LD	HL,(IX+-3)
;  231	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _new_literal ***************************
;Name                         Addr/Register   Size   Type
;_new_expression                     IMPORT  -----   function
;result                                IX-3      3   variable
;denominator                          IX+15      4   parameter
;numerator                             IX+9      4   parameter
;sign                                  IX+6      1   parameter


; Stack Frame Size: 24 (bytes)
;       Spill Code: 0 (instruction)


;  232	
;  233	/**
;  234	 
;  235	 @brief Allocates and initializes a new symbol/variable expression
;  236	 
;  237	 @details
;  238	 This function returns a new literal which is initialized with the
;  239	 argument provided.
;  240	 
;  241	 @param[in] identifier (either @c EXPI_SYMBOL or @c EXPI_VARIABLE)
;  242	 @param[in] value The symbolic value.
;  243	 
;  244	 @return
;  245	 - The initialized symbol.
;  246	 
;  247	 @see
;  248	 - new_expression()
;  249	 - new_literal()
;  250	 
;  251	 */
;  252	expression* new_symbol(expression_identifier identifier, const char* value) {
_new_symbol:
	LD	HL,-6
	CALL	__frameset
;  253	    expression* result = new_expression(EXPT_VALUE, (identifier == EXPI_VARIABLE) ? EXPI_VARIABLE : EXPI_SYMBOL, 0);
	LD	BC,3
	LD	HL,(IX+6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_9
	LD	(IX+-3),BC
	JR	L_10
L_9:
	LD	BC,2
	LD	(IX+-3),BC
L_10:
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-6),HL
;  254	    strcpy(result->value.symbolic, value);
	LD	BC,(IX+9)
	PUSH	BC
	LD	IY,(IX+-6)
	PEA	IY+14
	CALL	_strcpy
	POP	BC
	POP	BC
;  255	    return result;
	LD	HL,(IX+-6)
;  256	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _new_symbol ***************************
;Name                         Addr/Register   Size   Type
;_strcpy                             IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;result                                IX-6      3   variable
;temp7                                 IX-3      3   variable
;value                                 IX+9      3   parameter
;identifier                            IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: 0 (instruction)


;  257	
;  258	expression* new_trigonometic_periodicity(uint8_t period) {
_new_trigonometic_periodicity:
	LD	HL,-4
	CALL	__frameset
;  259	    
;  260	    expression* result = new_expression(EXPT_OPERATION, EXPI_MULTIPLICATION, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,7
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	(IX+-4),A
	CALL	_new_expression
	LD	A,(IX+-4)
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-3),HL
;  261	    
;  262	    append_child(result, new_literal(1, period, 1));
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	UEXT	HL
	LD	C,H
	LD	B,0
	LD	L,(IX+6)
	PUSH	BC
	PUSH	HL
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  263	    append_child(result, new_symbol(EXPI_SYMBOL, "n"));
	LD	BC,L__64
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  264	    append_child(result, new_symbol(EXPI_SYMBOL, "pi"));
	LD	BC,L__65
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  265	    
;  266	    return result;
	LD	HL,(IX+-3)
;  267	    
;  268	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _new_trigonometic_periodicity ***************************
;Name                         Addr/Register   Size   Type
;_new_symbol                         IMPORT  -----   function
;_new_literal                        IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;result                                IX-3      3   variable
;period                                IX+6      1   parameter


; Stack Frame Size: 13 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__64:
	DB	"n"
	DB	0
L__65:
	DB	"pi"
	DB	0
	SEGMENT CODE
;  269	
;  270	/**
;  271	 
;  272	 @brief Returns a deep copy of an expression
;  273	 
;  274	 @details
;  275	 This function recursively (post-order traversal) copies an expression
;  276	 and all its children. The copied expression is returned.
;  277	 
;  278	 @note
;  279	 - Null-children are not included in the copy.
;  280	 
;  281	 @param[in] source The expression to copy.
;  282	 
;  283	 @return
;  284	 - Pointer to the copy.
;  285	 
;  286	 */
;  287	expression* copy_expression(const expression* source) {
_copy_expression:
	LD	HL,-7
	CALL	__frameset
;  288	    
;  289	    uint8_t i;
;  290	    expression* result = new_expression(EXPT_NULL, EXPI_NULL, 0);
	LD	BC,0
	PUSH	BC
	PUSH	BC
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-3),HL
;  291	    
;  292	    if (source == NULL) return NULL;
	LD	HL,(IX+6)
	CALL	__icmpzero
	JR	NZ,L_20
	OR	A,A
	SBC	HL,HL
	JR	L_22
L_20:
;  293	    
;  294	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-4),0
	JR	L_19
L_17:
;  295	        if (source->children[i] == NULL) continue;
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	ADD	HL,DE
	ADD	HL,BC
	LD	(IX+-7),HL
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_18
;  296	        append_child(result, copy_expression(source->children[i]));
	LD	HL,(IX+-7)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  297	    }
L_18:
	INC	(IX+-4)
L_19:
	LD	A,(IX+-4)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_17
;  298	    
;  299	    result->parent = source->parent;
	LD	IY,(IX+6)
	LD	BC,(IY+7)
	LD	IY,(IX+-3)
	LD	(IY+7),BC
;  300	    result->type = source->type;
	LD	IY,(IX+6)
	LD	BC,(IY+0)
	LD	IY,(IX+-3)
	LD	(IY+0),BC
;  301	    result->identifier = source->identifier;
	LD	IY,(IX+6)
	LD	BC,(IY+3)
	LD	IY,(IX+-3)
	LD	(IY+3),BC
;  302	    result->child_count = source->child_count;
	LD	IY,(IX+6)
	LD	A,(IY+10)
	LD	IY,(IX+-3)
	LD	(IY+10),A
;  303	    result->sign = source->sign;
	LD	IY,(IX+6)
	LD	A,(IY+6)
	LD	IY,(IX+-3)
	LD	(IY+6),A
;  304	    result->value = source->value;
	LEA	DE,IY+14
	LD	IY,(IX+6)
	LEA	HL,IY+14
	LD	BC,10
	LDIR	
;  305	    
;  306	    return result;
	LD	HL,(IX+-3)
;  307	    
;  308	}
L_22:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _copy_expression ***************************
;Name                         Addr/Register   Size   Type
;_append_child                       IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;G_0                                   IX-7      3   variable
;i                                     IX-4      1   variable
;result                                IX-3      3   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 16 (bytes)
;       Spill Code: 0 (instruction)


;  309	
;  310	void replace_expression(expression* a, expression* b) {
_replace_expression:
	CALL	__frameset0
;  311	    free_expression(a, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  312	    *a = *b;
	LD	DE,(IX+6)
	LD	HL,(IX+9)
	LD	BC,24
	LDIR	
;  313	    smart_free(b);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_smart_free
	POP	BC
;  314	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _replace_expression ***************************
;Name                         Addr/Register   Size   Type
;_smart_free                         IMPORT  -----   function
;_free_expression                    IMPORT  -----   function
;b                                     IX+9      3   parameter
;a                                     IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


;  315	
;  316	void free_expression(expression* source, bool persistent) {
_free_expression:
	LD	HL,-4
	CALL	__frameset
;  317	    
;  318	    uint8_t i;
;  319	    
;  320	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_29
L_27:
;  321	        if (source->children[i] == NULL) continue;
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	ADD	HL,DE
	ADD	HL,BC
	LD	(IX+-4),HL
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_28
;  322	        free_expression(source->children[i], false);
	LD	BC,0
	PUSH	BC
	LD	HL,(IX+-4)
	LD	BC,(HL)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  323	    }
L_28:
	INC	(IX+-1)
L_29:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_27
;  324	    
;  325	    if (!persistent) smart_free(source);
	LD	A,(IX+9)
	OR	A,A
	JR	NZ,L_32
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_smart_free
	POP	BC
L_32:
;  326	    
;  327	    return;
;  328	    
;  329	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _free_expression ***************************
;Name                         Addr/Register   Size   Type
;_smart_free                         IMPORT  -----   function
;G_1                                   IX-4      3   variable
;i                                     IX-1      1   variable
;persistent                            IX+9      1   parameter
;source                                IX+6      3   parameter


; Stack Frame Size: 16 (bytes)
;       Spill Code: 0 (instruction)


;  330	
;  331	void free_all_except(expression* source) {
_free_all_except:
	LD	HL,-14
	CALL	__frameset
;  332	    
;  333	    uint16_t i;
;  334	    expression* temp;
;  335	    
;  336	    for (i = 0; allocated_pointers[i] != source && i < ALLOCATED_POINTERS_LENGTH; i++);
	LD	(IX+-2),0
	LD	(IX+-1),0
	JR	L_38
L_36:
	LD	HL,(IX+-2)
	INC	HL
	LD	(IX+-2),L
	LD	(IX+-1),H
L_38:
	LD	BC,(IX+-2)
	CALL	__stoiu
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(_allocated_pointers)
	ADD	HL,BC
	OR	A,A
	LD	(IX+-5),HL
	LD	HL,(HL)
	LD	BC,(IX+6)
	SBC	HL,BC
	JR	Z,L_39
	LD.LIS	BC,2000
	LD	HL,(IX+-2)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_36
L_39:
;  337	    allocated_pointers[i] = NULL;
	LD	HL,(IX+-5)
	LD	BC,0
	LD	(HL),BC
;  338	    
;  339	    smart_alloc_is_recording = false;
	XOR	A,A
	LD	(_smart_alloc_is_recording),A
;  340	    temp = copy_expression(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-8),HL
;  341	    smart_free_all();
	CALL	_smart_free_all
;  342	    
;  343	    smart_alloc_is_recording = true;
	LD	A,1
	LD	(_smart_alloc_is_recording),A
;  344	    *source = *copy_expression(temp);
	LD	BC,(IX+-8)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	DE,(IX+6)
	LD	BC,24
;  345	    free_expression(temp, false);
	LD	(IX+-11),HL	; spill
	OR	A,A
	SBC	HL,HL
	LD	(IX+-14),HL	; spill
	LD	HL,(IX+-11)	; unspill
	LD	(IX+-11),HL	; spill
	LD	HL,(IX+-14)	; unspill
	PUSH	HL
	LD	HL,(IX+-11)	; unspill
	LDIR	
	LD	BC,(IX+-8)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  346	    
;  347	    return;
;  348	    
;  349	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _free_all_except ***************************
;Name                         Addr/Register   Size   Type
;_free_expression                    IMPORT  -----   function
;_smart_free_all                     IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_smart_alloc_is_recording           IMPORT      1   variable
;_allocated_pointers                 IMPORT      3   variable
;temp                                  IX-8      3   variable
;G_2                                   IX-5      3   variable
;i                                     IX-2      2   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 23 (bytes)
;       Spill Code: 0 (instruction)


;  350	
;  351	/**
;  352	 
;  353	 @brief Appends a child to an expression
;  354	 
;  355	 @details
;  356	 When @c DEBUG_EXPRESSION_CHILDREN is set to 0 (production mode),
;  357	 the children pointer is resized to hold the new child.
;  358	 
;  359	 @param[in,out] parent The destination parent.
;  360	 @param[in] child The child to be appended.
;  361	 
;  362	 */
;  363	void append_child(expression* parent, expression* child) {
_append_child:
	LD	HL,-6
	CALL	__frameset
;  364	    uint16_t i;
;  365	#ifdef DEBUG_EXPRESSION_CHILDREN
;  366	    parent->children[parent->child_count] = child;
;  367	    parent->child_count++;
;  368	#else
;  369	    for (i = 0; allocated_pointers[i] != parent->children && i < ALLOCATED_POINTERS_LENGTH; i++);
	LD	(IX+-2),0
	LD	(IX+-1),0
	JR	L_45
L_43:
	LD	HL,(IX+-2)
	INC	HL
	LD	(IX+-2),L
	LD	(IX+-1),H
L_45:
	LD	BC,(IX+-2)
	CALL	__stoiu
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(_allocated_pointers)
	ADD	HL,BC
	LD	(IX+-6),HL
	LD	BC,(HL)
	LD	IY,(IX+6)
	OR	A,A
	LD	HL,(IY+11)
	SBC	HL,BC
	JR	Z,L_46
	LD.LIS	BC,2000
	LD	HL,(IX+-2)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_43
L_46:
;  370	    allocated_pointers[i] = NULL;
	LD	HL,(IX+-6)
	LD	BC,0
	LD	(HL),BC
;  371	    parent->children = smart_realloc(parent->children, parent->child_count + 1, sizeof(expression));
	LD	BC,24
	PUSH	BC
	LD	IY,(IX+6)
	LD	C,(IY+10)
	INC	C
	LD	B,0
	PUSH	BC
	LD	BC,(IY+11)
	PUSH	BC
	CALL	_smart_realloc
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+6)
	LD	(IY+11),HL
;  372	    parent->children[parent->child_count] = child;
	LD	A,(IY+10)
	LD	(IX+-3),A
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,3
	LD	DE,(IY+11)
	CALL	__imulu
	ADD	HL,DE
	LD	BC,(IX+9)
	LD	(HL),BC
;  373	    parent->child_count++;
	LD	A,(IX+-3)
	INC	A
	LD	(IY+10),A
;  374	#endif
;  375	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _append_child ***************************
;Name                         Addr/Register   Size   Type
;_smart_realloc                      IMPORT  -----   function
;_allocated_pointers                 IMPORT      3   variable
;G_3                                   IX-6      3   variable
;O_2                                   IX-3      1   variable
;i                                     IX-2      2   variable
;child                                 IX+9      3   parameter
;parent                                IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: 0 (instruction)


;  376	
;  377	void remove_child_at_index(expression* source, uint8_t index) {
_remove_child_at_index:
	CALL	__frameset0
;  378	    free_expression(source->children[index], false);
	LD	BC,0
	PUSH	BC
	LD	A,(IX+9)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	ADD	HL,DE
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  379	    source->children[index] = NULL;
	LD	A,(IX+9)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	ADD	HL,DE
	ADD	HL,BC
	LD	BC,0
	LD	(HL),BC
;  380	    remove_null_children(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_remove_null_children
	POP	BC
;  381	    return;
;  382	    
;  383	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _remove_child_at_index ***************************
;Name                         Addr/Register   Size   Type
;_remove_null_children               IMPORT  -----   function
;_free_expression                    IMPORT  -----   function
;index                                 IX+9      1   parameter
;source                                IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


;  384	
;  385	void remove_null_children(expression* source) {
_remove_null_children:
	LD	HL,-7
	CALL	__frameset
;  386	    
;  387	    uint8_t i;
;  388	    expression* result = new_expression(source->type, source->identifier, 0);
	LD	BC,0
	PUSH	BC
	LD	IY,(IX+6)
	LD	BC,(IY+3)
	PUSH	BC
	LD	BC,(IY+0)
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-7),HL
;  389	    
;  390	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_55
L_53:
;  391	        if (source->children[i] == NULL) continue;
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	ADD	HL,DE
	ADD	HL,BC
	LD	(IX+-4),HL
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_54
;  392	        append_child(result, copy_expression(source->children[i]));
	LD	HL,(IX+-4)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  393	    }
L_54:
	INC	(IX+-1)
L_55:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_53
;  394	    
;  395	    replace_expression(source, result);
	LD	BC,(IX+-7)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  396	    
;  397	    return;
;  398	    
;  399	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _remove_null_children ***************************
;Name                         Addr/Register   Size   Type
;_replace_expression                 IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;result                                IX-7      3   variable
;G_4                                   IX-4      3   variable
;i                                     IX-1      1   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 16 (bytes)
;       Spill Code: 0 (instruction)


;  400	
;  401	void embed_in_list_if_necessary(expression* source) {
_embed_in_list_if_necessary:
	CALL	__frameset0
;  402	    
;  403	    if (source->identifier != EXPI_LIST) {
	LD	IY,(IX+6)
	LD	HL,(IY+3)
	LD	BC,40
	OR	A,A
	SBC	HL,BC
	JR	Z,L_59
;  404	        replace_expression(source, new_expression(EXPT_STRUCTURE, EXPI_LIST, 1,
;  405	                                                  copy_expression(source)));
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,1
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  406	    }
L_59:
;  407	    
;  408	    return;
;  409	    
;  410	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _embed_in_list_if_necessary ***************************
;Name                         Addr/Register   Size   Type
;_copy_expression                    IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;source                                IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  411	
;  412	void merge_nested_lists(expression* source, bool recursive) {
_merge_nested_lists:
	LD	HL,-14
	CALL	__frameset
;  413	    
;  414	    uint8_t i, j;
;  415	    expression* result;
;  416	    
;  417	    for (i = 0; i < source->child_count && recursive; i++) {
	LD	(IX+-1),0
	JR	L_65
L_63:
;  418	        merge_nested_lists(source->children[i], true);
	LD	BC,1
	PUSH	BC
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	BC,(HL)
	PUSH	BC
	CALL	_merge_nested_lists
	POP	BC
	POP	BC
	INC	(IX+-1)
;  419	    }
L_65:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	NC,L_67
	LD	A,(IX+9)
	OR	A,A
	JR	NZ,L_63
L_67:
;  420	    
;  421	    if (source->identifier != EXPI_LIST) return;
	LD	IY,(IX+6)
	LD	HL,(IY+3)
	LD	BC,40
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_82
;  422	    
;  423	    result = new_expression(EXPT_STRUCTURE, EXPI_LIST, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-5),HL
;  424	    
;  425	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_78
L_76:
;  426	        if (source->children[i]->identifier == EXPI_LIST) {
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	(IX+-11),HL
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	ADD	HL,BC
	LD	(IX+-8),HL
	LD	IY,(HL)
	LD	HL,(IY+3)
	OR	A,A
	LD	BC,40
	SBC	HL,BC
	JR	NZ,L_75
;  427	            for (j = 0; j < source->children[i]->child_count; j++) {
	LD	(IX+-2),0
	JR	L_73
L_71:
;  428	                append_child(result, copy_expression(source->children[i]->children[j]));
	LD	A,(IX+-2)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	IY,(IX+-14)
	LD	IY,(IY)
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IY+11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-5)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
	INC	(IX+-2)
;  429	            }
L_73:
	LD	BC,(IX+-11)
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	(IX+-14),HL
	LD	IY,(HL)
	LD	A,(IX+-2)
	CP	A,(IY+10)
	JR	C,L_71
	JR	L_77
;  430	        } else {
L_75:
;  431	            append_child(result, copy_expression(source->children[i]));
	LD	HL,(IX+-8)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-5)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  432	        }
;  433	    }
L_77:
	INC	(IX+-1)
L_78:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_76
;  434	    
;  435	    if (result->child_count == 1) {
	LD	IY,(IX+-5)
	LD	A,(IY+10)
	CP	A,1
	JR	NZ,L_81
;  436	        replace_expression(result, copy_expression(result->children[0]));
	LD	IY,(IX+-5)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-5)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  437	    }
L_81:
;  438	    
;  439	    replace_expression(source, result);
	LD	BC,(IX+-5)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  440	    
;  441	}
L_82:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _merge_nested_lists ***************************
;Name                         Addr/Register   Size   Type
;_replace_expression                 IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;G_5                                  IX-14      3   variable
;G_6                                  IX-11      3   variable
;G_7                                   IX-8      3   variable
;result                                IX-5      3   variable
;j                                     IX-2      1   variable
;i                                     IX-1      1   variable
;recursive                             IX+9      1   parameter
;source                                IX+6      3   parameter


; Stack Frame Size: 26 (bytes)
;       Spill Code: 0 (instruction)


;  442	
;  443	void set_parents(expression* source) {
_set_parents:
	LD	HL,-7
	CALL	__frameset
;  444	    
;  445	    uint8_t i;
;  446	    
;  447	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_88
L_86:
;  448	        if (source->children[i] == NULL) continue;
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	(IX+-7),HL
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	ADD	HL,BC
	LD	(IX+-4),HL
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_87
;  449	        source->children[i]->parent = source;
	LD	HL,(IX+-4)
	LD	IY,(HL)
	LD	BC,(IX+6)
	LD	(IY+7),BC
;  450	        set_parents(source->children[i]);
	LD	BC,(IX+-7)
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_set_parents
	POP	BC
;  451	    }
L_87:
	INC	(IX+-1)
L_88:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_86
;  452	    
;  453	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _set_parents ***************************
;Name                         Addr/Register   Size   Type
;G_9                                   IX-7      3   variable
;G_8                                   IX-4      3   variable
;i                                     IX-1      1   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 16 (bytes)
;       Spill Code: 0 (instruction)


;  454	
;  455	bool expressions_are_identical(const expression* a, expression* b, bool persistent) {
_expressions_are_identical:
	LD	HL,-25
	CALL	__frameset
;  456	    
;  457	    uint8_t i;
;  458	    
;  459	    if (a == NULL || b == NULL) {
	LD	HL,(IX+6)
	CALL	__icmpzero
	JR	Z,L_91
	LD	HL,(IX+9)
	CALL	__icmpzero
	JR	NZ,L_95
L_91:
;  460	        return false;
	XOR	A,A
	JR	L_137
;  461	    }
L_95:
;  462	    
;  463	    if (a->identifier != b->identifier) {
	LD	IY,(IX+6)
	LD	BC,(IY+3)
	LD	(IX+-13),BC
	LD	IY,(IX+9)
	LD	HL,(IY+3)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_99
;  464	        if (!persistent) free_expression(b, false);
	LD	A,(IX+12)
	OR	A,A
	JR	NZ,L_93
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
L_93:
;  465	        return false;
	XOR	A,A
	JR	L_137
;  466	    }
L_99:
;  467	    
;  468	    if (a->sign != b->sign) {
	LD	IY,(IX+6)
	LD	A,(IY+6)
	LD	IY,(IX+9)
	CP	A,(IY+6)
	JR	Z,L_105
;  469	        if (!persistent) free_expression(b, false);
	LD	A,(IX+12)
	OR	A,A
	JR	NZ,L_97
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
L_97:
;  470	        return false;
	XOR	A,A
	JR	L_137
;  471	    }
L_105:
;  472	    
;  473	    if (a->identifier == EXPI_LITERAL && (a->value.numeric.numerator != b->value.numeric.numerator || a->value.numeric.denominator != b->value.numeric.denominator)) {
	LD	BC,1
	LD	HL,(IX+-13)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_110
	LD	IY,(IX+6)
	LD	HL,(IY+14)
	LD	E,(IY+17)
	LD	IY,(IX+9)
	LD	BC,(IY+14)
	LD	A,(IY+17)
	CALL	__lcmpu
	JR	NZ,L_104
	LD	IY,(IX+6)
	LD	HL,(IY+18)
	LD	E,(IY+21)
	LD	IY,(IX+9)
	LD	BC,(IY+18)
	LD	A,(IY+21)
	CALL	__lcmpu
	JR	Z,L_110
L_104:
;  474	        if (!persistent) free_expression(b, false);
	LD	A,(IX+12)
	OR	A,A
	JR	NZ,L_103
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
L_103:
;  475	        return false;
	XOR	A,A
	JR	L_137
;  476	    }
L_110:
;  477	    
;  478	    if (a->identifier == EXPI_SYMBOL && strcmp(a->value.symbolic, b->value.symbolic) != 0) {
	LD	BC,2
	LD	HL,(IX+-13)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_133
	LD	IY,(IX+9)
	PEA	IY+14
	LD	IY,(IX+6)
	PEA	IY+14
	CALL	_strcmp
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	Z,L_133
;  479	        if (!persistent) free_expression(b, false);
	LD	A,(IX+12)
	OR	A,A
	JR	NZ,L_108
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
L_108:
;  480	        return false;
	XOR	A,A
	JR	L_137
;  481	    }
L_133:
;  482	    
;  483	    if (a->type == EXPT_OPERATION || a->type == EXPT_FUNCTION || a->type == EXPT_STRUCTURE) {
	LD	IY,(IX+6)
	LD	BC,(IY+0)
	LD	(IX+-4),BC
	LD	HL,BC
	LD	BC,2
	OR	A,A
	SBC	HL,BC
	JR	Z,L_132
	LD	BC,3
	LD	HL,(IX+-4)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_132
	LD	BC,4
	LD	HL,(IX+-4)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_135
L_132:
;  484	        
;  485	        if (a->child_count != b->child_count) {
	LD	IY,(IX+6)
	LD	A,(IY+10)
	LD	IY,(IX+9)
	CP	A,(IY+10)
	JR	Z,L_131
;  486	            if (!persistent) free_expression(b, false);
	LD	A,(IX+12)
	OR	A,A
	JR	NZ,L_114
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
L_114:
;  487	            return false;
	XOR	A,A
	JR	L_137
;  488	        }
L_131:
;  489	        
;  490	        for (i = 0; i < a->child_count; i++) {
	LD	(IX+-1),0
	JR	L_130
L_128:
;  491	            
;  492	            if (a->children[i] == NULL && b->children[i] == NULL) continue;
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	(IX+-7),HL
	LD	(IX+-22),HL
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	LD	(IX+-16),BC
	LD	BC,(IX+-7)
	LD	HL,(IX+-16)
	ADD	HL,BC
	LD	(IX+-25),HL
	LD	HL,(HL)
	CALL	__icmpzero
	JR	NZ,L_123
	LD	BC,(IX+-7)
	LD	(IX+-22),BC
	LD	BC,(IX+-7)
	LD	IY,(IX+9)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_129
L_123:
;  493	            
;  494	            if (a->children[i] == NULL || b->children[i] == NULL) {
	LD	HL,(IX+-25)
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_122
	LD	BC,(IX+-22)
	LD	(IX+-10),BC
	LD	IY,(IX+9)
	LD	BC,(IY+11)
	LD	(IX+-19),BC
	LD	BC,(IX+-10)
	LD	HL,(IX+-19)
	ADD	HL,BC
	LD	HL,(HL)
	CALL	__icmpzero
	JR	NZ,L_127
L_122:
;  495	                if (!persistent) free_expression(b, false);
	LD	A,(IX+12)
	OR	A,A
	JR	NZ,L_121
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
L_121:
;  496	                return false;
	XOR	A,A
	JR	L_137
;  497	            }
L_127:
;  498	            
;  499	            if (expressions_are_identical(a->children[i], b->children[i], true) == false) {
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-10)
	LD	HL,(IX+-19)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+-10)
	LD	HL,(IX+-16)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_expressions_are_identical
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	NZ,L_129
;  500	                if (!persistent) free_expression(b, false);
	LD	A,(IX+12)
	OR	A,A
	JR	NZ,L_125
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
L_125:
;  501	                return false;
	XOR	A,A
	JR	L_137
;  502	            }
;  503	            
;  504	        }
L_129:
	INC	(IX+-1)
L_130:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_128
;  505	        
;  506	    }
L_135:
;  507	    
;  508	    if (!persistent) free_expression(b, false);
	LD	A,(IX+12)
	OR	A,A
	JR	NZ,L_136
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
L_136:
;  509	    return true;
	LD	A,1
;  510	    
;  511	}
L_137:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _expressions_are_identical ***************************
;Name                         Addr/Register   Size   Type
;_strcmp                             IMPORT  -----   function
;_free_expression                    IMPORT  -----   function
;G_17                                 IX-25      3   variable
;G_18                                 IX-22      3   variable
;G_20                                 IX-19      3   variable
;G_21                                 IX-16      3   variable
;G_10                                 IX-13      3   variable
;G_19                                 IX-10      3   variable
;G_16                                  IX-7      3   variable
;G_14                                  IX-4      3   variable
;i                                     IX-1      1   variable
;persistent                           IX+12      1   parameter
;b                                     IX+9      3   parameter
;a                                     IX+6      3   parameter


; Stack Frame Size: 40 (bytes)
;       Spill Code: 0 (instruction)


;  512	
;  513	bool expressions_are_equivalent(const expression* a, expression* b, bool persistent) {
_expressions_are_equivalent:
	LD	HL,-3
	CALL	__frameset
;  514	    
;  515	    expression* temp = new_expression(EXPT_OPERATION, EXPI_SUBTRACTION, 2,
;  516	                                      copy_expression(a),
;  517	                                      copy_expression(b));
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,2
	PUSH	BC
	LD	BC,6
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-3),HL
;  518	    
;  519	    simplify(temp, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  520	    temp->sign = 1;
	LD	IY,(IX+-3)
	LD	(IY+6),1
;  521	    
;  522	    if (!persistent) free_expression(b, false);
	LD	A,(IX+12)
	OR	A,A
	JR	NZ,L_141
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
L_141:
;  523	    
;  524	    if (expressions_are_identical(temp, new_literal(1, 0, 1), false)) {
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_expressions_are_identical
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_140
;  525	        free_expression(temp, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  526	        return true;
	LD	A,1
	JR	L_142
;  527	    } else {
L_140:
;  528	        free_expression(temp, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  529	        return false;
	XOR	A,A
;  530	    }
;  531	    
;  532	}
L_142:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _expressions_are_equivalent ***************************
;Name                         Addr/Register   Size   Type
;_new_literal                        IMPORT  -----   function
;_expressions_are_identical          IMPORT  -----   function
;_free_expression                    IMPORT  -----   function
;_simplify                           IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;temp                                  IX-3      3   variable
;persistent                           IX+12      1   parameter
;b                                     IX+9      3   parameter
;a                                     IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: 0 (instruction)


;  533	
;  534	bool expression_is_greater_than(const expression* a, expression* b, bool persistent) {
_expression_is_greater_than:
	LD	HL,-9
	CALL	__frameset
;  535	    
;  536	    expression* temp_a = copy_expression(a);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-6),HL
;  537	    expression* temp_b = copy_expression(b);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-9),HL
;  538	    
;  539	    expression* test = new_expression(EXPT_OPERATION, EXPI_SUBTRACTION, 2,
;  540	                                      temp_a,
;  541	                                      temp_b);
	LD	BC,HL
	PUSH	BC
	LD	BC,(IX+-6)
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,6
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-3),HL
;  542	    
;  543	    simplify(test, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  544	    
;  545	    if (!persistent) free_expression(b, false);
	LD	A,(IX+12)
	OR	A,A
	JR	NZ,L_148
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
L_148:
;  546	    
;  547	    if (test->identifier == EXPI_LITERAL && test->sign == 1 && literal_to_double(test) != 0) {
	LD	IY,(IX+-3)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_147
	LD	IY,(IX+-3)
	LD	A,(IY+6)
	CP	A,1
	JR	NZ,L_147
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	BC,0
	XOR	A,A
	CALL	__fcmp
	JR	Z,L_147
;  548	        free_expression(test, false);
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  549	        return true;
	LD	A,1
	JR	L_149
;  550	    } else {
L_147:
;  551	        free_expression(test, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  552	        return false;
	XOR	A,A
;  553	    }
;  554	    
;  555	}
L_149:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _expression_is_greater_than ***************************
;Name                         Addr/Register   Size   Type
;_literal_to_double                  IMPORT  -----   function
;_free_expression                    IMPORT  -----   function
;_simplify                           IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;temp_b                                IX-9      3   variable
;temp_a                                IX-6      3   variable
;test                                  IX-3      3   variable
;persistent                           IX+12      1   parameter
;b                                     IX+9      3   parameter
;a                                     IX+6      3   parameter


; Stack Frame Size: 24 (bytes)
;       Spill Code: 0 (instruction)


;  556	
;  557	bool expression_is_smaller_than(const expression* a, expression* b, bool persistent) {
_expression_is_smaller_than:
	LD	HL,-9
	CALL	__frameset
;  558	    
;  559	    expression* temp_a = copy_expression(a);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-6),HL
;  560	    expression* temp_b = copy_expression(b);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-9),HL
;  561	    
;  562	    expression* test = new_expression(EXPT_OPERATION, EXPI_SUBTRACTION, 2,
;  563	                                      temp_a,
;  564	                                      temp_b);
	LD	BC,HL
	PUSH	BC
	LD	BC,(IX+-6)
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,6
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-3),HL
;  565	    
;  566	    simplify(test, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_simplify
	POP	BC
	POP	BC
;  567	    
;  568	    if (!persistent) free_expression(b, false);
	LD	A,(IX+12)
	OR	A,A
	JR	NZ,L_154
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
L_154:
;  569	    
;  570	    if (test->identifier == EXPI_LITERAL && test->sign == -1) {
	LD	IY,(IX+-3)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_153
	LD	IY,(IX+-3)
	LD	A,(IY+6)
	CP	A,-1
	JR	NZ,L_153
;  571	        free_expression(test, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  572	        return true;
	LD	A,1
	JR	L_155
;  573	    } else {
L_153:
;  574	        free_expression(test, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  575	        return false;
	XOR	A,A
;  576	    }
;  577	    
;  578	}
L_155:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _expression_is_smaller_than ***************************
;Name                         Addr/Register   Size   Type
;_free_expression                    IMPORT  -----   function
;_simplify                           IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;temp_b                                IX-9      3   variable
;temp_a                                IX-6      3   variable
;test                                  IX-3      3   variable
;persistent                           IX+12      1   parameter
;b                                     IX+9      3   parameter
;a                                     IX+6      3   parameter


; Stack Frame Size: 24 (bytes)
;       Spill Code: 0 (instruction)


;  579	
;  580	bool expression_is_constant(const expression* source) {
_expression_is_constant:
	LD	HL,-1
	CALL	__frameset
;  581	    
;  582	    uint8_t i;
;  583	    
;  584	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_160
L_158:
;  585	        if (!expression_is_constant(source->children[i])) {
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	ADD	HL,DE
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_expression_is_constant
	POP	BC
	OR	A,A
	JR	NZ,L_159
;  586	            return false;
	XOR	A,A
	JR	L_165
;  587	        }
;  588	    }
L_159:
	INC	(IX+-1)
L_160:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_158
;  589	    
;  590	    if (source->identifier == EXPI_SYMBOL && !symbol_is_constant(source)) {
	LD	IY,(IX+6)
	LD	HL,(IY+3)
	LD	BC,2
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_163
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_symbol_is_constant
	POP	BC
	OR	A,A
	JR	NZ,L_163
;  591	        return false;
	XOR	A,A
	JR	L_165
;  592	    } else {
L_163:
;  593	        return true;
	LD	A,1
;  594	    }
;  595	    
;  596	}
L_165:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _expression_is_constant ***************************
;Name                         Addr/Register   Size   Type
;_symbol_is_constant                 IMPORT  -----   function
;i                                     IX-1      1   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 10 (bytes)
;       Spill Code: 0 (instruction)


;  597	
;  598	bool symbol_is_constant(const expression* source) {
_symbol_is_constant:
	CALL	__frameset0
;  599	    if (expressions_are_identical(source, new_symbol(EXPI_SYMBOL, "pi"), false) ||
	LD	BC,0
	PUSH	BC
	LD	BC,L__144
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_expressions_are_identical
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	NZ,L_168
;  600	        expressions_are_identical(source, new_symbol(EXPI_SYMBOL, "e"), false) ||
	LD	BC,0
	PUSH	BC
	LD	BC,L__146
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_expressions_are_identical
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	NZ,L_168
;  601	        expressions_are_identical(source, new_symbol(EXPI_SYMBOL, "i"), false)) {
	LD	BC,0
	PUSH	BC
	LD	BC,L__148
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_expressions_are_identical
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_169
L_168:
;  602	        return true;
	LD	A,1
	JR	L_170
;  603	    } else {
L_169:
;  604	        return false;
	XOR	A,A
;  605	    }
;  606	}
L_170:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _symbol_is_constant ***************************
;Name                         Addr/Register   Size   Type
;_new_symbol                         IMPORT  -----   function
;_expressions_are_identical          IMPORT  -----   function
;source                                IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__144:
	DB	"pi"
	DB	0
L__146:
	DB	"e"
	DB	0
L__148:
	DB	"i"
	DB	0
	SEGMENT CODE
;  607	
;  608	int8_t expression_contains_division(expression* source) {
_expression_contains_division:
	LD	HL,-4
	CALL	__frameset
;  609	    
;  610	    uint8_t i;
;  611	    
;  612	    for (i = 0; i < source->child_count && source->identifier == EXPI_MULTIPLICATION; i++) {
	LD	(IX+-1),0
	JR	L_177
L_175:
;  613	        if (source->children[i]->identifier == EXPI_EXPONENTATION && source->children[i]->children[1]->sign == -1) {
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	ADD	HL,DE
	ADD	HL,BC
	LD	(IX+-4),HL
	LD	IY,(HL)
	LD	HL,(IY+3)
	OR	A,A
	LD	BC,9
	SBC	HL,BC
	JR	NZ,L_176
	LD	HL,(IX+-4)
	LD	IY,(HL)
	LD	IY,(IY+11)
	LD	IY,(IY+3)
	LD	A,(IY+6)
	CP	A,-1
	JR	NZ,L_176
;  614	            return i;
	LD	A,(IX+-1)
	JR	L_179
;  615	        }
;  616	    }
L_176:
	INC	(IX+-1)
L_177:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	NC,L_178
	LD	IY,(IX+6)
	LD	HL,(IY+3)
	LD	BC,7
	OR	A,A
	SBC	HL,BC
	JR	Z,L_175
L_178:
;  617	    
;  618	    return -1;
	LD	A,255
;  619	    
;  620	}
L_179:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _expression_contains_division ***************************
;Name                         Addr/Register   Size   Type
;G_22                                  IX-4      3   variable
;i                                     IX-1      1   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 13 (bytes)
;       Spill Code: 0 (instruction)


;  621	
;  622	bool expression_is_reziprocal(expression* source) {
_expression_is_reziprocal:
	CALL	__frameset0
;  623	    
;  624	    if (source->identifier == EXPI_EXPONENTATION) {
	LD	IY,(IX+6)
	LD	HL,(IY+3)
	LD	BC,9
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_182
;  625	        if (source->children[1]->sign == -1) return true;
	LD	IY,(IX+6)
	LD	IY,(IY+11)
	LD	IY,(IY+3)
	LD	A,(IY+6)
	CP	A,-1
	JR	NZ,L_182
	LD	A,1
	JR	L_183
;  626	    }
L_182:
;  627	    
;  628	    return false;
	XOR	A,A
;  629	    
;  630	}
L_183:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _expression_is_reziprocal ***************************
;Name                         Addr/Register   Size   Type
;source                                IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  631	
;  632	bool expression_is_numerical(expression* source) {
_expression_is_numerical:
	LD	HL,-1
	CALL	__frameset
;  633	    
;  634	    uint8_t i;
;  635	    
;  636	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_188
L_186:
;  637	        if (!expression_is_numerical(source->children[i])) {
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	ADD	HL,DE
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_expression_is_numerical
	POP	BC
	OR	A,A
	JR	NZ,L_187
;  638	            return false;
	XOR	A,A
	JR	L_192
;  639	        }
;  640	    }
L_187:
	INC	(IX+-1)
L_188:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_186
;  641	    
;  642	    if (source->identifier == EXPI_SYMBOL) {
	LD	IY,(IX+6)
	LD	HL,(IY+3)
	LD	BC,2
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_190
;  643	        return false;
	XOR	A,A
	JR	L_192
;  644	    } else {
L_190:
;  645	        return true;
	LD	A,1
;  646	    }
;  647	    
;  648	}
L_192:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _expression_is_numerical ***************************
;Name                         Addr/Register   Size   Type
;i                                     IX-1      1   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 10 (bytes)
;       Spill Code: 0 (instruction)


;  649	
;  650	uint8_t count_occurrences(const expression* haystack, expression* needle, bool persistent) {
_count_occurrences:
	LD	HL,-5
	CALL	__frameset
;  651	    
;  652	    uint8_t i;
;  653	    uint8_t count = 0;
	LD	(IX+-2),0
;  654	    
;  655	    if (expressions_are_identical(haystack, needle, true)) {
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_expressions_are_identical
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_205
;  656	        
;  657	        if (!persistent) free_expression(needle, false);
	LD	A,(IX+12)
	OR	A,A
	JR	NZ,L_194
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
L_194:
;  658	        return 1;
	LD	A,1
	JR	L_206
;  659	        
;  660	    } else {
L_205:
;  661	        
;  662	        for (i = 0; i < haystack->child_count; i++) {
	LD	(IX+-1),0
	JR	L_200
L_198:
;  663	            if (haystack->children[i] == NULL) continue;
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	(IX+-5),HL
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_199
;  664	            count += count_occurrences(haystack->children[i], needle, true);
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	LD	HL,(IX+-5)
	LD	BC,(HL)
	PUSH	BC
	CALL	_count_occurrences
	POP	BC
	POP	BC
	POP	BC
	ADD	A,(IX+-2)
	LD	(IX+-2),A
;  665	        }
L_199:
	INC	(IX+-1)
L_200:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_198
;  666	        
;  667	        if (!persistent) free_expression(needle, false);
	LD	A,(IX+12)
	OR	A,A
	JR	NZ,L_203
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
L_203:
;  668	        return count;
	LD	A,(IX+-2)
;  669	        
;  670	    }
;  671	    
;  672	}
L_206:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _count_occurrences ***************************
;Name                         Addr/Register   Size   Type
;_free_expression                    IMPORT  -----   function
;_expressions_are_identical          IMPORT  -----   function
;G_23                                  IX-5      3   variable
;count                                 IX-2      1   variable
;i                                     IX-1      1   variable
;persistent                           IX+12      1   parameter
;needle                                IX+9      3   parameter
;haystack                              IX+6      3   parameter


; Stack Frame Size: 20 (bytes)
;       Spill Code: 0 (instruction)


;  673	
;  674	void replace_occurences(expression* source, const expression* child, const expression* replacement) {
_replace_occurences:
	LD	HL,-4
	CALL	__frameset
;  675	    
;  676	    uint8_t i;
;  677	    
;  678	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_212
L_210:
;  679	        if (source->children[i] == NULL) continue;
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	(IX+-4),HL
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_211
;  680	        replace_occurences(source->children[i], child, replacement);
	LD	BC,(IX+12)
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	LD	HL,(IX+-4)
	LD	BC,(HL)
	PUSH	BC
	CALL	_replace_occurences
	POP	BC
	POP	BC
	POP	BC
;  681	    }
L_211:
	INC	(IX+-1)
L_212:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_210
;  682	    
;  683	    if (expressions_are_identical(source, copy_expression(child), false)) {
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_expressions_are_identical
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_215
;  684	        replace_expression(source, copy_expression(replacement));
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  685	    }
L_215:
;  686	    
;  687	    return;
;  688	    
;  689	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _replace_occurences ***************************
;Name                         Addr/Register   Size   Type
;_replace_expression                 IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_expressions_are_identical          IMPORT  -----   function
;G_24                                  IX-4      3   variable
;i                                     IX-1      1   variable
;replacement                          IX+12      3   parameter
;child                                 IX+9      3   parameter
;source                                IX+6      3   parameter


; Stack Frame Size: 19 (bytes)
;       Spill Code: 0 (instruction)


;  690	
;  691	void replace_null_with_zero(expression* source) {
_replace_null_with_zero:
	LD	HL,-10
	CALL	__frameset
;  692	    
;  693	    uint8_t i;
;  694	    
;  695	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-4),0
	JR	L_224
L_222:
;  696	        
;  697	        if (source->children[i] == NULL ||
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	(IX+-3),HL
	LD	(IX+-10),HL
	LD	HL,(IX+-3)
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_220
;  698	            (source->children[i]->type == EXPT_STRUCTURE && source->children[i]->child_count == 0)) {
	LD	BC,(IX+-3)
	LD	(IX+-7),BC
	LD	HL,(IX+-3)
	LD	IY,(HL)
	LD	HL,(IY+0)
	LD	BC,4
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_221
	LD	BC,(IX+-3)
	LD	(IX+-10),BC
	LD	BC,(IX+-3)
	LD	(IX+-7),BC
	LD	HL,(IX+-3)
	LD	IY,(HL)
	LD	A,(IY+10)
	OR	A,A
	JR	NZ,L_221
L_220:
;  699	            source->children[i] = new_literal(1, 0, 1);
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_new_literal
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+-10)
	LD	(IY),HL
;  700	        } else {
	JR	L_223
L_221:
;  701	            replace_null_with_zero(source->children[i]);
	LD	HL,(IX+-7)
	LD	BC,(HL)
	PUSH	BC
	CALL	_replace_null_with_zero
	POP	BC
;  702	        }
;  703	        
;  704	    }
L_223:
	INC	(IX+-4)
L_224:
	LD	A,(IX+-4)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_222
;  705	    
;  706	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _replace_null_with_zero ***************************
;Name                         Addr/Register   Size   Type
;_new_literal                        IMPORT  -----   function
;G_27                                 IX-10      3   variable
;G_28                                  IX-7      3   variable
;i                                     IX-4      1   variable
;G_25                                  IX-3      3   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 19 (bytes)
;       Spill Code: 0 (instruction)


;  707	
;  708	uint8_t swap_expressions(expression* a, expression* b) {
_swap_expressions:
	CALL	__frameset0
;  709	    
;  710	    expression* temp;
;  711	    
;  712	    if (a == NULL || b == NULL) return RETS_ERROR;
	LD	HL,(IX+6)
	CALL	__icmpzero
	JR	Z,L_227
	LD	HL,(IX+9)
	CALL	__icmpzero
	JR	NZ,L_228
L_227:
	LD	A,1
	JR	L_229
L_228:
;  713	    
;  714	    temp = a;
;  715	    b = a;
;  716	    b = temp;
	LD	BC,(IX+6)
	LD	(IX+9),BC
;  717	    
;  718	    return RETS_SUCCESS;
	LD	A,2
;  719	    
;  720	}
L_229:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _swap_expressions ***************************
;Name                         Addr/Register   Size   Type
;b                                     IX+9      3   parameter
;a                                     IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


;  721	
;  722	uint8_t get_symbol_order_score(const expression* source) {
_get_symbol_order_score:
	LD	HL,-3
	CALL	__frameset
;  723	    
;  724	    char* occurance;
;  725	    
;  726	    if (source->identifier != EXPI_SYMBOL || strlen(source->value.symbolic) != 1) return 100;
	LD	IY,(IX+6)
	LD	HL,(IY+3)
	LD	BC,2
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_231
	LD	IY,(IX+6)
	PEA	IY+14
	CALL	_strlen
	POP	BC
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	Z,L_234
L_231:
	LD	A,100
	JR	L_235
L_234:
;  727	    
;  728	    if ((occurance = strstr(default_priorities, source->value.symbolic))) {
	LD	IY,(IX+6)
	PEA	IY+14
	LD	BC,(_default_priorities)
	PUSH	BC
	CALL	_strstr
	POP	BC
	POP	BC
	LD	(IX+-3),HL
	CALL	__icmpzero
	JR	Z,L_233
;  729	        return (uint8_t) (occurance - default_priorities);
	LD	BC,(_default_priorities)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	LD	A,L
	JR	L_235
;  730	    } else {
L_233:
;  731	        return 100;
	LD	A,100
;  732	    }
;  733	    
;  734	}
L_235:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _get_symbol_order_score ***************************
;Name                         Addr/Register   Size   Type
;_default_priorities                 IMPORT      3   variable
;_strstr                             IMPORT  -----   function
;_strlen                             IMPORT  -----   function
;occurance                             IX-3      3   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


;  735	
;  736	double get_order_score(const expression* source) {
_get_order_score:
	LD	HL,-8
	CALL	__frameset
;  737	    
;  738	    uint8_t i;
;  739	    double score;
;  740	    
;  741	    if (source->identifier == EXPI_LITERAL) {
	LD	IY,(IX+6)
	LD	BC,(IY+3)
	LD	(IX+-4),BC
	LD	HL,BC
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_252
;  742	        score = 1;
	LD	BC,8388608
	LD	(IX+-8),BC
	LD	A,63
	LD	(IX+-5),A
;  743	    } else if (source->identifier == EXPI_SYMBOL) {
	JR	L_253
L_252:
	LD	BC,2
	LD	HL,(IX+-4)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_250
;  744	        score = 2 + get_symbol_order_score(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_get_symbol_order_score
	POP	BC
	UEXT	HL
	LD	L,A
	INC	HL
	INC	HL
	LD	BC,HL
	CALL	__itol
	CALL	__ltof
	LD	(IX+-8),BC
	LD	(IX+-5),A
;  745	    } else if (source->identifier == EXPI_ADDITION || source->identifier == EXPI_MULTIPLICATION) {
	JR	L_253
L_250:
	LD	BC,5
	LD	HL,(IX+-4)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_247
	LD	BC,7
	LD	HL,(IX+-4)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_248
L_247:
;  746	        score = 1000;
	LD	BC,7995392
	LD	(IX+-8),BC
	LD	A,68
	LD	(IX+-5),A
;  747	        for (i = 0; i < source->child_count; i++) score += get_order_score(source->children[i]) / 2;
	LD	(IX+-1),0
	JR	L_240
L_238:
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	ADD	HL,DE
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_get_order_score
	LD	BC,HL
	OR	A,A
	SBC	HL,HL
	POP	IY
	LD	A,E
	LD	E,64
	CALL	__fdiv
	LD	HL,(IX+-8)
	LD	E,(IX+-5)
	CALL	__fadd
	LD	(IX+-8),BC
	LD	(IX+-5),A
	INC	(IX+-1)
L_240:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_238
	JR	L_253
;  748	    } else if (source->identifier == EXPI_EXPONENTATION) {
L_248:
	LD	BC,9
	LD	HL,(IX+-4)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_246
;  749	        score = 20000 + get_order_score(source->children[0]) / 2;
	LD	IY,(IX+6)
	LD	HL,(IY+11)
	LD	BC,(HL)
	PUSH	BC
	CALL	_get_order_score
	POP	BC
	LD	A,E
	LD	BC,HL
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fdiv
	LD	HL,10240000
	LD	E,70
	CALL	__fadd
	LD	(IX+-8),BC
	LD	(IX+-5),A
;  750	    } else {
	JR	L_253
L_246:
;  751	        score = 30000;
	LD	BC,15360000
	LD	(IX+-8),BC
	LD	A,70
	LD	(IX+-5),A
;  752	        for (i = 0; i < source->child_count; i++) score += get_order_score(source->children[i]) / 2;
	LD	(IX+-1),0
	JR	L_244
L_242:
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	ADD	HL,DE
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_get_order_score
	LD	BC,HL
	OR	A,A
	SBC	HL,HL
	POP	IY
	LD	A,E
	LD	E,64
	CALL	__fdiv
	LD	HL,(IX+-8)
	LD	E,(IX+-5)
	CALL	__fadd
	LD	(IX+-8),BC
	LD	(IX+-5),A
	INC	(IX+-1)
L_244:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_242
;  753	    }
L_253:
;  754	    
;  755	    return score;
	LD	HL,(IX+-8)
	LD	E,(IX+-5)
;  756	    
;  757	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _get_order_score ***************************
;Name                         Addr/Register   Size   Type
;score                                 IX-8      4   variable
;G_30                                  IX-4      3   variable
;i                                     IX-1      1   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 17 (bytes)
;       Spill Code: 0 (instruction)


;  758	
;  759	void order_children(expression* source) {
_order_children:
	LD	HL,-33
	CALL	__frameset
;  760	    
;  761	    uint8_t i;
;  762	    expression** expressions;
;  763	    double* scores;
;  764	    uint8_t min_index;
;  765	    double min_score;
;  766	    expression* result;
;  767	    
;  768	    if (source->identifier != EXPI_ADDITION && source->identifier != EXPI_MULTIPLICATION) return;
	LD	IY,(IX+6)
	LD	BC,(IY+3)
	LD	(IX+-17),BC
	LD	HL,BC
	LD	BC,5
	OR	A,A
	SBC	HL,BC
	JR	Z,L_257
	LD	BC,7
	LD	HL,(IX+-17)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_273
L_257:
;  769	    
;  770	    expressions = smart_alloc(source->child_count, sizeof(expression));
	LD	BC,24
	PUSH	BC
	LD	IY,(IX+6)
	LD	C,(IY+10)
	LD	B,0
	PUSH	BC
	CALL	_smart_alloc
	POP	BC
	POP	BC
	LD	(IX+-11),HL
;  771	    scores = smart_alloc(source->child_count, sizeof(double));
	LD	BC,4
	PUSH	BC
	LD	IY,(IX+6)
	LD	C,(IY+10)
	LD	B,0
	PUSH	BC
	CALL	_smart_alloc
	POP	BC
	POP	BC
	LD	(IX+-5),HL
;  772	    
;  773	    result = new_expression(source->type, source->identifier, 0);
	LD	BC,0
	PUSH	BC
	LD	IY,(IX+6)
	LD	BC,(IY+3)
	PUSH	BC
	LD	BC,(IY+0)
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-14),HL
;  774	    
;  775	    remove_null_children(source);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_remove_null_children
	POP	BC
;  776	    
;  777	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_261
L_259:
;  778	        expressions[i] = source->children[i];
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	IY,HL
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IX+-11)
	ADD	HL,BC
	LD	BC,(IY)
	LD	(HL),BC
;  779	        scores[i] = get_order_score(source->children[i]);
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	BC,(HL)
	PUSH	BC
	CALL	_get_order_score
	LD	BC,HL
	POP	HL
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	LD	(IX+-30),BC	; spill
	LD	BC,(IX+-5)
	LD	(IX+-33),BC	; spill
	LD	BC,(IX+-30)	; unspill
	LD	(IX+-30),BC	; spill
	LD	BC,(IX+-33)	; unspill
	ADD	HL,BC
	LD	BC,(IX+-30)	; unspill
	LD	IY,HL
	LD	(IY),BC
	LD	(IY+3),E
	INC	(IX+-1)
;  780	    }
L_261:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_259
;  781	
;  782	    while (result->child_count != source->child_count) {
	JR	L_269
L_270:
;  783	
;  784	        min_index = 0;
	LD	(IX+-2),0
;  785	        min_score = uintmax_max_value();
	CALL	_uintmax_max_value
	LD	(IX+-21),HL
	LD	(IX+-18),E
;  786	
;  787	        for (i = 0; i < source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_267
L_265:
;  788	            if (scores[i] < min_score && scores[i] != 0) {
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(IX+-5)
	ADD	HL,BC
	LD	(IX+-8),HL
	LD	IY,(IX+-8)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	BC,(IX+-21)
	LD	A,(IX+-18)
	CALL	__fcmp
	JP	P,L_266
	LD	IY,(IX+-8)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	BC,0
	XOR	A,A
	CALL	__fcmp
	JR	Z,L_266
;  789	                min_index = i;
	LD	A,(IX+-1)
	LD	(IX+-2),A
;  790	                min_score = scores[i];
	LD	HL,(IX+-8)
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	(IX+-21),BC
	LD	(IX+-18),A
;  791	            }
;  792	        }
L_266:
	INC	(IX+-1)
L_267:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_265
;  793	
;  794	        append_child(result, copy_expression(expressions[min_index]));
	LD	A,(IX+-2)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IX+-11)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+-14)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  795	        scores[min_index] = 0;
	LD	A,(IX+-2)
	LD	DE,(IX+-5)
	LD	(IX+-27),DE	; spill
	LD	DE,0
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	LD	(IX+-24),DE	; spill
	LD	DE,(IX+-27)	; unspill
	ADD	HL,DE
	LD	DE,(IX+-24)	; unspill
	LD	(HL),DE
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),0
;  796	
;  797	    }
L_269:
	LD	IY,(IX+-14)
	LD	A,(IY+10)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	NZ,L_270
;  798	    
;  799	    smart_free(expressions);
	LD	BC,(IX+-11)
	PUSH	BC
	CALL	_smart_free
	POP	BC
;  800	    smart_free(scores);
	LD	BC,(IX+-5)
	PUSH	BC
	CALL	_smart_free
	POP	BC
;  801	    replace_expression(source, result);
	LD	BC,(IX+-14)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  802	    
;  803	    return;
;  804	    
;  805	}
L_273:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _order_children ***************************
;Name                         Addr/Register   Size   Type
;_replace_expression                 IMPORT  -----   function
;_smart_free                         IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;_uintmax_max_value                  IMPORT  -----   function
;_remove_null_children               IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;_smart_alloc                        IMPORT  -----   function
;min_score                            IX-21      4   variable
;G_34                                 IX-17      3   variable
;result                               IX-14      3   variable
;expressions                          IX-11      3   variable
;G_35                                  IX-8      3   variable
;scores                                IX-5      3   variable
;min_index                             IX-2      1   variable
;i                                     IX-1      1   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 42 (bytes)
;       Spill Code: 0 (instruction)


;  806	
;  807	void collect_symbols(expression* symbols, const expression* source) {
_collect_symbols:
	LD	HL,-7
	CALL	__frameset
;  808	    
;  809	    uint8_t i;
;  810	    
;  811	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_279
L_277:
;  812	        if (source->children[i] == NULL) continue;
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	LD	IY,(IX+9)
	LD	BC,(IY+11)
	ADD	HL,DE
	ADD	HL,BC
	LD	(IX+-7),HL
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_278
;  813	        collect_symbols(symbols, source->children[i]);
	LD	HL,(IX+-7)
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_collect_symbols
	POP	BC
	POP	BC
;  814	    }
L_278:
	INC	(IX+-1)
L_279:
	LD	A,(IX+-1)
	LD	IY,(IX+9)
	CP	A,(IY+10)
	JR	C,L_277
;  815	    
;  816	    if (source->identifier == EXPI_SYMBOL || source->identifier == EXPI_VARIABLE) {
	LD	IY,(IX+9)
	LD	BC,(IY+3)
	LD	(IX+-4),BC
	LD	HL,BC
	LD	BC,2
	OR	A,A
	SBC	HL,BC
	JR	Z,L_281
	LD	BC,3
	LD	HL,(IX+-4)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_283
L_281:
;  817	        append_child(symbols, copy_expression(source));
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_append_child
	POP	BC
	POP	BC
;  818	    }
L_283:
;  819	    
;  820	    return;
;  821	    
;  822	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _collect_symbols ***************************
;Name                         Addr/Register   Size   Type
;_copy_expression                    IMPORT  -----   function
;_append_child                       IMPORT  -----   function
;G_37                                  IX-7      3   variable
;G_38                                  IX-4      3   variable
;i                                     IX-1      1   variable
;source                                IX+9      3   parameter
;symbols                               IX+6      3   parameter


; Stack Frame Size: 19 (bytes)
;       Spill Code: 0 (instruction)


;  823	
;  824	expression* guess_symbol(const expression* source, const char* custom_priorities, uint8_t rank) {
_guess_symbol:
	LD	HL,-20
	CALL	__frameset
;  825	    
;  826	    uint8_t i, j;
;  827	    expression* symbols = new_expression(EXPT_STRUCTURE, EXPI_LIST, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_new_expression
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-5),HL
;  828	    expression* symbol;
;  829	    
;  830	    collect_symbols(symbols, source);
	LD	BC,(IX+6)
	PUSH	BC
	LD	BC,(IX+-5)
	PUSH	BC
	CALL	_collect_symbols
	POP	BC
	POP	BC
;  831	    
;  832	    for (i = 0; custom_priorities[i] != '\0'; i++) {
	LD	(IX+-1),0
	JR	L_297
L_295:
;  833	        for (j = 0; j < symbols->child_count; j++) {
	LD	(IX+-2),0
	JR	L_294
L_292:
;  834	            if (strlen(symbols->children[j]->value.symbolic) == 1 && symbols->children[j]->value.symbolic[0] == custom_priorities[i]) {
	LD	A,(IX+-2)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	(IX+-17),HL
	LD	IY,(IX+-5)
	LD	BC,(IY+11)
	ADD	HL,BC
	LD	IY,(HL)
	PEA	IY+14
	CALL	_strlen
	POP	BC
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_293
	LD	BC,(IX+-17)
	LD	IY,(IX+-5)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	(IX+-20),HL
	LD	A,(IX+-1)
	UEXT	HL
	LD	IY,(IX+-20)
	LD	IY,(IY)
	LD	L,A
	LD	BC,(IX+9)
	ADD	HL,BC
	LD	A,(IY+14)
	CP	A,(HL)
	JR	NZ,L_293
;  835	                if (rank == 0) {
	LD	A,(IX+12)
	OR	A,A
	JR	NZ,L_290
;  836	                    symbol = copy_expression(symbols->children[j]);
	LD	HL,(IX+-20)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-8),HL
;  837	                    free_expression(symbols, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-5)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  838	                    return symbol;
	LD	HL,(IX+-8)
	JR	L_315
;  839	                } else {
L_290:
;  840	                    rank--;
	DEC	(IX+12)
;  841	                }
;  842	            }
;  843	        }
L_293:
	INC	(IX+-2)
L_294:
	LD	A,(IX+-2)
	LD	IY,(IX+-5)
	CP	A,(IY+10)
	JR	C,L_292
	INC	(IX+-1)
;  844	    }
L_297:
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+9)
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_295
;  845	    
;  846	    for (i = 0; default_priorities[i] != '\0'; i++) {
	LD	(IX+-1),0
	JR	L_310
L_308:
;  847	        for (j = 0; j < symbols->child_count; j++) {
	LD	(IX+-2),0
	JR	L_307
L_305:
;  848	            if (strlen(symbols->children[j]->value.symbolic) == 1 && symbols->children[j]->value.symbolic[0] == default_priorities[i]) {
	LD	A,(IX+-2)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	(IX+-11),HL
	LD	IY,(IX+-5)
	LD	BC,(IY+11)
	ADD	HL,BC
	LD	IY,(HL)
	PEA	IY+14
	CALL	_strlen
	POP	BC
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_306
	LD	BC,(IX+-11)
	LD	IY,(IX+-5)
	LD	HL,(IY+11)
	ADD	HL,BC
	LD	(IX+-14),HL
	LD	A,(IX+-1)
	UEXT	HL
	LD	IY,(IX+-14)
	LD	IY,(IY)
	LD	L,A
	LD	BC,(_default_priorities)
	ADD	HL,BC
	LD	A,(IY+14)
	CP	A,(HL)
	JR	NZ,L_306
;  849	                if (rank == 0) {
	LD	A,(IX+12)
	OR	A,A
	JR	NZ,L_303
;  850	                    symbol = copy_expression(symbols->children[j]);
	LD	HL,(IX+-14)
	LD	BC,(HL)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-8),HL
;  851	                    free_expression(symbols, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-5)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
;  852	                    return symbol;
	LD	HL,(IX+-8)
	JR	L_315
;  853	                } else {
L_303:
;  854	                    rank--;
	DEC	(IX+12)
;  855	                }
;  856	            }
;  857	        }
L_306:
	INC	(IX+-2)
L_307:
	LD	A,(IX+-2)
	LD	IY,(IX+-5)
	CP	A,(IY+10)
	JR	C,L_305
	INC	(IX+-1)
;  858	    }
L_310:
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,(_default_priorities)
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_308
;  859	    
;  860	    if (symbols->child_count != 0) {
	LD	IY,(IX+-5)
	LD	A,(IY+10)
	OR	A,A
	JR	Z,L_314
;  861	        return symbols->children[0];
	LD	IY,(IX+-5)
	LD	HL,(IY+11)
	LD	HL,(HL)
	JR	L_315
;  862	    }
L_314:
	OR	A,A
;  863	    
;  864	    return NULL;
	SBC	HL,HL
;  865	    
;  866	}
L_315:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _guess_symbol ***************************
;Name                         Addr/Register   Size   Type
;_default_priorities                 IMPORT      3   variable
;_free_expression                    IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;_strlen                             IMPORT  -----   function
;_collect_symbols                    IMPORT  -----   function
;_new_expression                     IMPORT  -----   function
;G_40                                 IX-20      3   variable
;G_39                                 IX-17      3   variable
;G_42                                 IX-14      3   variable
;G_41                                 IX-11      3   variable
;symbol                                IX-8      3   variable
;symbols                               IX-5      3   variable
;j                                     IX-2      1   variable
;i                                     IX-1      1   variable
;rank                                 IX+12      1   parameter
;custom_priorities                     IX+9      3   parameter
;source                                IX+6      3   parameter


; Stack Frame Size: 35 (bytes)
;       Spill Code: 0 (instruction)


;  867	
;  868	expression* double_to_literal(double source) {
_double_to_literal:
	LD	HL,-6
	CALL	__frameset
;  869	    
;  870	    char* buffer = smart_alloc(10, sizeof(char));
	LD	BC,1
	PUSH	BC
	LD	BC,10
	PUSH	BC
	CALL	_smart_alloc
	POP	BC
	POP	BC
	LD	(IX+-3),HL
;  871	    expression* result;
;  872	    
;  873	    dtoa(buffer, 10, source);
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	LD	BC,10
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_dtoa
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  874	    string_to_literal(&result, buffer);
	LD	BC,(IX+-3)
	PUSH	BC
	PEA	IX+-6
	CALL	_string_to_literal
	POP	BC
	POP	BC
;  875	    
;  876	    return result;
	LD	HL,(IX+-6)
;  877	    
;  878	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _double_to_literal ***************************
;Name                         Addr/Register   Size   Type
;_string_to_literal                  IMPORT  -----   function
;_dtoa                               IMPORT  -----   function
;_smart_alloc                        IMPORT  -----   function
;result                                IX-6      3   variable
;buffer                                IX-3      3   variable
;source                                IX+6      4   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: 0 (instruction)


;  879	
;  880	double literal_to_double(expression* source) {
_literal_to_double:
	LD	HL,-10
	CALL	__frameset
;  881	    return source->sign * ((double) source->value.numeric.numerator) / ((double) source->value.numeric.denominator);
	LD	IY,(IX+6)
	LEA	BC,IY+14
	LD	(IX+-3),BC
	LD	IY,(IX+-3)
	LD	BC,(IY+0)
	LD	A,(IY+3)
	CALL	__ultof
	LD	(IX+-10),A
	LD	IY,(IX+6)
	LD	A,(IY+6)
	LD	IY,(IX+-3)
	LD	D,A
	SEXT	HL
	LD	L,D
	LD	A,H
	LD	(IX+-9),BC
	LD	BC,HL
	CALL	__ltof
	LD	E,A
	LD	A,(IX+-10)
	LD	HL,BC
	LD	BC,(IX+-9)
	CALL	__fmul
	LD	(IX+-6),BC
	LD	BC,(IY+4)
	LD	H,A
	LD	A,(IY+7)
	CALL	__ultof
	LD	E,A
	LD	A,H
	LD	HL,BC
	LD	BC,(IX+-6)
	CALL	__fdiv
	LD	E,A
	LD	HL,BC
;  882	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _literal_to_double ***************************
;Name                         Addr/Register   Size   Type
;source                                IX+6      3   parameter


; Stack Frame Size: 19 (bytes)
;       Spill Code: 0 (instruction)


;  883	
;  884	void literal_to_double_symbol(expression* source) {
_literal_to_double_symbol:
	LD	HL,-7
	CALL	__frameset
;  885	    
;  886	    uint8_t i;
;  887	    char* buffer;
;  888	    
;  889	    for (i = 0; i < source->child_count; i++) {
	LD	(IX+-1),0
	JR	L_323
L_321:
;  890	        if (source->children[i] == 0) continue;
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LD	BC,(IY+11)
	ADD	HL,DE
	ADD	HL,BC
	LD	(IX+-4),HL
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_322
;  891	        literal_to_double_symbol(source->children[i]);
	LD	HL,(IX+-4)
	LD	BC,(HL)
	PUSH	BC
	CALL	_literal_to_double_symbol
	POP	BC
;  892	    }
L_322:
	INC	(IX+-1)
L_323:
	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+10)
	JR	C,L_321
;  893	    
;  894	    if (source->identifier == EXPI_LITERAL) {
	LD	IY,(IX+6)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_326
;  895	        buffer = smart_alloc(10, sizeof(char));
	PUSH	BC
	LD	BC,10
	PUSH	BC
	CALL	_smart_alloc
	POP	BC
	POP	BC
	LD	(IX+-7),HL
;  896	        dtoa(buffer, 10, literal_to_double(source));
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_literal_to_double
	POP	BC
	LD	C,E
	LD	B,0
	PUSH	BC
	PUSH	HL
	LD	BC,10
	PUSH	BC
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_dtoa
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  897	        replace_expression(source, new_symbol(EXPI_SYMBOL, buffer));
	LD	BC,(IX+-7)
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_new_symbol
	POP	BC
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_replace_expression
	POP	BC
	POP	BC
;  898	    }
L_326:
;  899	    
;  900	    return;
;  901	    
;  902	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _literal_to_double_symbol ***************************
;Name                         Addr/Register   Size   Type
;_new_symbol                         IMPORT  -----   function
;_replace_expression                 IMPORT  -----   function
;_literal_to_double                  IMPORT  -----   function
;_dtoa                               IMPORT  -----   function
;_smart_alloc                        IMPORT  -----   function
;buffer                                IX-7      3   variable
;G_43                                  IX-4      3   variable
;i                                     IX-1      1   variable
;source                                IX+6      3   parameter


; Stack Frame Size: 16 (bytes)
;       Spill Code: 0 (instruction)


;  903	
;  904	/**
;  905	 
;  906	 @brief Returns the keyword string corresponding to the identifier
;  907	 
;  908	 @details
;  909	 The @c keyword_identifiers array is searched for the first occurrence
;  910	 of the given identifier. When found, the string from
;  911	 @c keyword_strings with the same index is returned. If
;  912	 @c use_abbrevations is set to true, the abbrevation (the next string,
;  913	 if existent) is returned.
;  914	 
;  915	 @param[in] identifier The expression identifier.
;  916	 
;  917	 @return
;  918	 - The string corresponding to the identifier.
;  919	 
;  920	 @see
;  921	 - get_expression_identifier()
;  922	 
;  923	 */
;  924	const char* get_expression_string(expression_identifier identifier) {
_get_expression_string:
	LD	HL,-7
	CALL	__frameset
;  925	    
;  926	    uint8_t i;
;  927	    
;  928	    for (i = 0; keyword_identifiers[i] != EXPI_NULL; i++) {
	LD	(IX+-1),0
	JR	L_335
L_333:
;  929	        if (keyword_identifiers[i] == identifier) {
	LD	HL,(IX+-4)
	ADD	HL,BC
	LD	HL,(HL)
	OR	A,A
	LD	BC,(IX+6)
	SBC	HL,BC
	JR	NZ,L_334
;  930	            if (use_abbrevations && keyword_identifiers[i + 1] == identifier) {
	LD	A,(_use_abbrevations)
	OR	A,A
	JR	Z,L_331
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	INC	HL
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	(IX+-7),HL
	LD	BC,_keyword_identifiers
	ADD	HL,BC
	LD	HL,(HL)
	OR	A,A
	LD	BC,(IX+6)
	SBC	HL,BC
	JR	NZ,L_331
;  931	                return keyword_strings[i + 1];
	LD	BC,_keyword_strings
	LD	HL,(IX+-7)
	ADD	HL,BC
	LD	HL,(HL)
	JR	L_337
;  932	            } else {
L_331:
;  933	                return keyword_strings[i];
	LD	BC,_keyword_strings
	LD	HL,(IX+-4)
	ADD	HL,BC
	LD	HL,(HL)
	JR	L_337
;  934	            }
;  935	        }
;  936	    }
L_334:
	INC	(IX+-1)
L_335:
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	(IX+-4),HL
	LD	BC,_keyword_identifiers
	ADD	HL,BC
	LD	HL,(HL)
	CALL	__icmpzero
	JR	NZ,L_333
;  937	    
;  938	    return "NULL";
	LD	HL,L__228
;  939	    
;  940	}
L_337:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _get_expression_string ***************************
;Name                         Addr/Register   Size   Type
;_keyword_strings                    STATIC    180   variable
;_use_abbrevations                   IMPORT      1   variable
;_keyword_identifiers                STATIC    180   variable
;G_45                                  IX-7      3   variable
;G_46                                  IX-4      3   variable
;i                                     IX-1      1   variable
;identifier                            IX+6      3   parameter


; Stack Frame Size: 16 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__228:
	DB	"NULL"
	DB	0
	SEGMENT CODE
;  941	
;  942	/**
;  943	 
;  944	 @brief Returns the identifier corresponding to the keyword string
;  945	 
;  946	 @details
;  947	 The @c keyword_strings array is searched for the first occurrence
;  948	 of the given string. When found, the identifier from
;  949	 @c keyword_identifiers with the same index is returned. This function
;  950	 is case insensitive and handles abbrevations.
;  951	 
;  952	 @param[in] string The keyword string.
;  953	 
;  954	 @return
;  955	 - The identifier corresponding to the string.
;  956	 
;  957	 @see
;  958	 - get_expression_string()
;  959	 
;  960	 */
;  961	expression_identifier get_expression_identifier(const char* string) {
_get_expression_identifier:
	LD	HL,-10
	CALL	__frameset
;  962	    
;  963	    uint8_t i;
;  964	    char* lowercase_string = string_to_lower(string);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_string_to_lower
	POP	BC
	LD	(IX+-10),HL
;  965	    char* lowercase_keyword;
;  966	    
;  967	    for (i = 0; keyword_strings[i] != NULL; i++) {
	LD	(IX+-1),0
	JR	L_343
L_341:
;  968	        lowercase_keyword = string_to_lower(keyword_strings[i]);
	LD	HL,(IX+-4)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_string_to_lower
	POP	BC
	LD	(IX+-7),HL
;  969	        if (strcmp(string, lowercase_keyword) == 0) {
	LD	BC,HL
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcmp
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_340
;  970	            smart_free(lowercase_string);
	LD	BC,(IX+-10)
	PUSH	BC
	CALL	_smart_free
	POP	BC
;  971	            smart_free(lowercase_keyword);
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_smart_free
	POP	BC
;  972	            return keyword_identifiers[i];
	LD	HL,(IX+-4)
	LD	BC,_keyword_identifiers
	ADD	HL,BC
	LD	HL,(HL)
	JR	L_345
;  973	        }
L_340:
;  974	        smart_free(lowercase_keyword);
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_smart_free
	POP	BC
	INC	(IX+-1)
;  975	    }
L_343:
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	(IX+-4),HL
	LD	BC,_keyword_strings
	ADD	HL,BC
	LD	HL,(HL)
	CALL	__icmpzero
	JR	NZ,L_341
;  976	    
;  977	    smart_free(lowercase_string);
	LD	BC,(IX+-10)
	PUSH	BC
	CALL	_smart_free
	POP	BC
	OR	A,A
;  978	    
;  979	    return EXPI_NULL;
	SBC	HL,HL
;  980	    
;  981	}
L_345:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _get_expression_identifier ***************************
;Name                         Addr/Register   Size   Type
;_keyword_identifiers                STATIC    180   variable
;_smart_free                         IMPORT  -----   function
;_strcmp                             IMPORT  -----   function
;_keyword_strings                    STATIC    180   variable
;_string_to_lower                    IMPORT  -----   function
;lowercase_string                     IX-10      3   variable
;lowercase_keyword                     IX-7      3   variable
;G_48                                  IX-4      3   variable
;i                                     IX-1      1   variable
;string                                IX+6      3   parameter


; Stack Frame Size: 19 (bytes)
;       Spill Code: 0 (instruction)


;  982	
;  983	/**
;  984	 
;  985	 @brief Serializes an expression into a specified format
;  986	 
;  987	 @details
;  988	 This function calls @c expression_to_infix() or
;  989	 @c expression_to_tkiz(), depending on the specified format. It
;  990	 automatically converts all polynomials to expressions and sets
;  991	 parents. No further simplification is applied. The result can be
;  992	 tweaked by changing the bools @c use_abbrevations and @c use_spaces,
;  993	 defined in symbolic4.c.
;  994	 
;  995	 @param[in,out] buffer The buffer where the resulting string shall be
;  996	 written into.
;  997	 @param[in] source The expression to be serialized.
;  998	 @param[in] format The serialization format.
;  999	 
; 1000	 @see
; 1001	 - expression_to_infix()
; 1002	 - expression_to_tkiz()
; 1003	 
; 1004	 */
; 1005	void expression_to_string(char* buffer, const expression* source, expression_to_string_format format) {
_expression_to_string:
	LD	HL,-3
	CALL	__frameset
; 1006	    
; 1007	    expression* temp_source = copy_expression(source);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-3),HL
; 1008	    
; 1009	    any_expression_to_expression_recursive(temp_source);
	LD	BC,HL
	PUSH	BC
	CALL	_any_expression_to_expression_recursive
	POP	BC
; 1010	    set_parents(temp_source);
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_set_parents
	POP	BC
; 1011	    
; 1012	    switch (format) {
	LD	HL,(IX+12)
	CALL	__case8
L__233:
	DW	2
	DB	1
	DW24	L_346	

	DB	2
	DW24	L_347	

	DW24	L_348	

; 1013	        case ETSF_INFIX: expression_to_infix(buffer, temp_source); break;
L_346:
	LD	BC,(IX+-3)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_expression_to_infix
	POP	BC
	POP	BC
	JR	L_349
; 1014	        case ETSF_TIKZ: strcat(buffer, "\\begin{tikzpicture}"); expression_to_tikz(buffer, temp_source); strcat(buffer, ";\\end{tikzpicture}"); break;
L_347:
	LD	BC,L__234
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
	LD	BC,(IX+-3)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_expression_to_tikz
	POP	BC
	POP	BC
	LD	BC,L__235
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
	JR	L_349
; 1015	        default: expression_to_infix(buffer, temp_source); break;
L_348:
	LD	BC,(IX+-3)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_expression_to_infix
	POP	BC
	POP	BC
; 1016	    }
L_349:
; 1017	    
; 1018	    free_expression(temp_source, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
; 1019	    
; 1020	    return;
; 1021	    
; 1022	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _expression_to_string ***************************
;Name                         Addr/Register   Size   Type
;_free_expression                    IMPORT  -----   function
;_expression_to_tikz                 IMPORT  -----   function
;_strcat                             IMPORT  -----   function
;_expression_to_infix                IMPORT  -----   function
;_set_parents                        IMPORT  -----   function
;_any_expression_to_expression_recursive      IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;temp_source                           IX-3      3   variable
;format                               IX+12      3   parameter
;source                                IX+9      3   parameter
;buffer                                IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__234:
	DB	"\\begin{tikzpicture}"
	DB	0
L__235:
	DB	";\\end{tikzpicture}"
	DB	0
	SEGMENT CODE
; 1023	
; 1024	void expression_to_infix(char* buffer, const expression* source) {
_expression_to_infix:
	LD	HL,-49
	CALL	__frameset
; 1025	    
; 1026	    uint8_t i;
; 1027	    char temp_buffer[30];
; 1028	    expression* temp_source = copy_expression(source);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-3),HL
; 1029	    
; 1030	    if (temp_source->identifier == EXPI_LITERAL) {
	LD	IY,(IX+-3)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_365
; 1031	        if (temp_source->value.numeric.denominator == 1) {
	LD	IY,(IX+-3)
	LD	HL,(IY+18)
	LD	E,(IY+21)
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_361
; 1032	            if (temp_source->sign == -1) strcat(buffer, "(-");
	LD	IY,(IX+-3)
	LD	A,(IY+6)
	CP	A,-1
	JR	NZ,L_352
	LD	BC,L__240
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
L_352:
; 1033	            itoa(temp_buffer, temp_source->value.numeric.numerator);
	LD	IY,(IX+-3)
	LD	BC,(IY+14)
	LD	A,(IY+17)
	LD	H,0
	LD	L,A
	PUSH	HL
	PUSH	BC
	PEA	IX+-49
	CALL	_itoa
	POP	BC
	POP	BC
	POP	BC
; 1034	            strcat(buffer, temp_buffer);
	PEA	IX+-49
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1035	            if (temp_source->sign == -1) strcat(buffer, ")");
	LD	IY,(IX+-3)
	LD	A,(IY+6)
	CP	A,-1
	JR	NZ,L_365
	LD	BC,L__242
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1036	        } else {
	JR	L_365
L_361:
; 1037	            strcat(buffer, "(");
	LD	BC,L__243
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1038	            if (temp_source->sign == -1) strcat(buffer, "-");
	LD	IY,(IX+-3)
	LD	A,(IY+6)
	CP	A,-1
	JR	NZ,L_355
	LD	BC,L__245
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
L_355:
; 1039	            itoa(temp_buffer, temp_source->value.numeric.numerator);
	LD	IY,(IX+-3)
	LD	BC,(IY+14)
	LD	A,(IY+17)
	LD	H,0
	LD	L,A
	PUSH	HL
	PUSH	BC
	PEA	IX+-49
	CALL	_itoa
	POP	BC
	POP	BC
	POP	BC
; 1040	            strcat(buffer, temp_buffer);
	PEA	IX+-49
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1041	            strcat(buffer, (use_spaces) ? " / " : "/");
	LD	A,(_use_spaces)
	OR	A,A
	JR	Z,L_358
	LD	BC,L__247
	LD	(IX+-13),BC
	JR	L_359
L_358:
	LD	BC,L__248
	LD	(IX+-13),BC
L_359:
	LD	BC,(IX+-13)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1042	            itoa(temp_buffer, temp_source->value.numeric.denominator);
	LD	IY,(IX+-3)
	LD	BC,(IY+18)
	LD	A,(IY+21)
	LD	H,0
	LD	L,A
	PUSH	HL
	PUSH	BC
	PEA	IX+-49
	CALL	_itoa
	POP	BC
	POP	BC
	POP	BC
; 1043	            strcat(buffer, temp_buffer);
	PEA	IX+-49
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1044	            strcat(buffer, ")");
	LD	BC,L__249
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1045	        }
; 1046	    }
L_365:
; 1047	    
; 1048	    if (temp_source->identifier == EXPI_SYMBOL || temp_source->identifier == EXPI_VARIABLE) {
	LD	IY,(IX+-3)
	LD	BC,(IY+3)
	LD	(IX+-10),BC
	LD	HL,BC
	LD	BC,2
	OR	A,A
	SBC	HL,BC
	JR	Z,L_364
	LD	BC,3
	LD	HL,(IX+-10)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_394
L_364:
; 1049	        strcat(buffer, temp_source->value.symbolic);
	LD	IY,(IX+-3)
	PEA	IY+14
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1050	    }
L_394:
; 1051	    
; 1052	    if (temp_source->type == EXPT_OPERATION) {
	LD	IY,(IX+-3)
	LD	HL,(IY+0)
	LD	BC,2
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_407
; 1053	        if (temp_source->parent == NULL || (temp_source->identifier >= temp_source->parent->identifier || temp_source->parent->type != EXPT_OPERATION)) {
	LD	IY,(IX+-3)
	LD	BC,(IY+7)
	LD	(IX+-7),BC
	LD	HL,BC
	CALL	__icmpzero
	JR	Z,L_391
	LD	IY,(IX+-7)
	LD	BC,(IY+3)
	LD	IY,(IX+-3)
	LD	HL,(IY+3)
	OR	A,A
	SBC	HL,BC
	JP	P,L_391
	LD	IY,(IX+-7)
	LD	HL,(IY+0)
	LD	BC,2
	OR	A,A
	SBC	HL,BC
	JR	Z,L_392
L_391:
; 1054	            for (i = 0; i < temp_source->child_count; i++) {
	LD	(IX+-4),0
	JR	L_378
L_376:
; 1055	                expression_to_infix(buffer, temp_source->children[i]);
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+-3)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_expression_to_infix
	POP	BC
	POP	BC
; 1056	                if (use_spaces && i != temp_source->child_count - 1) strcat(buffer, " ");
	LD	A,(_use_spaces)
	OR	A,A
	JR	Z,L_372
	LD	IY,(IX+-3)
	LD	A,(IY+10)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	DEC	BC
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	JR	Z,L_372
	LD	BC,L__258
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
L_372:
; 1057	                if (i != temp_source->child_count - 1) strcat(buffer, get_expression_string(temp_source->identifier));
	LD	IY,(IX+-3)
	LD	A,(IY+10)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	DEC	BC
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	JR	Z,L_375
	LD	IY,(IX+-3)
	LD	BC,(IY+3)
	PUSH	BC
	CALL	_get_expression_string
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
L_375:
; 1058	                if (use_spaces && i != temp_source->child_count - 1) strcat(buffer, " ");
	LD	A,(_use_spaces)
	OR	A,A
	JR	Z,L_377
	LD	IY,(IX+-3)
	LD	A,(IY+10)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	DEC	BC
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	JR	Z,L_377
	LD	BC,L__262
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1059	            }
L_377:
	INC	(IX+-4)
L_378:
	LD	A,(IX+-4)
	LD	IY,(IX+-3)
	CP	A,(IY+10)
	JR	C,L_376
	JR	L_407
; 1060	        } else {
L_392:
; 1061	            strcat(buffer, "(");
	LD	BC,L__264
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1062	            for (i = 0; i < temp_source->child_count; i++) {
	LD	(IX+-4),0
	JR	L_389
L_387:
; 1063	                expression_to_infix(buffer, temp_source->children[i]);
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+-3)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_expression_to_infix
	POP	BC
	POP	BC
; 1064	                if (use_spaces && i != temp_source->child_count - 1) strcat(buffer, " ");
	LD	A,(_use_spaces)
	OR	A,A
	JR	Z,L_383
	LD	IY,(IX+-3)
	LD	A,(IY+10)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	DEC	BC
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	JR	Z,L_383
	LD	BC,L__267
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
L_383:
; 1065	                if (i != temp_source->child_count - 1) strcat(buffer, get_expression_string(temp_source->identifier));
	LD	IY,(IX+-3)
	LD	A,(IY+10)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	DEC	BC
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	JR	Z,L_386
	LD	IY,(IX+-3)
	LD	BC,(IY+3)
	PUSH	BC
	CALL	_get_expression_string
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
L_386:
; 1066	                if (use_spaces && i != temp_source->child_count - 1) strcat(buffer, " ");
	LD	A,(_use_spaces)
	OR	A,A
	JR	Z,L_388
	LD	IY,(IX+-3)
	LD	A,(IY+10)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	DEC	BC
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	JR	Z,L_388
	LD	BC,L__271
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1067	            }
L_388:
	INC	(IX+-4)
L_389:
	LD	A,(IX+-4)
	LD	IY,(IX+-3)
	CP	A,(IY+10)
	JR	C,L_387
; 1068	            strcat(buffer, ")");
	LD	BC,L__273
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1069	        }
; 1070	    }
L_407:
; 1071	    
; 1072	    if (temp_source->type == EXPT_FUNCTION || temp_source->type == EXPT_STRUCTURE) {
	LD	IY,(IX+-3)
	LD	BC,(IY+0)
	LD	(IX+-16),BC
	LD	HL,BC
	LD	BC,3
	OR	A,A
	SBC	HL,BC
	JR	Z,L_406
	LD	BC,4
	LD	HL,(IX+-16)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_408
L_406:
; 1073	        strcat(buffer, get_expression_string(temp_source->identifier));
	LD	IY,(IX+-3)
	LD	BC,(IY+3)
	PUSH	BC
	CALL	_get_expression_string
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1074	        strcat(buffer, "(");
	LD	BC,L__276
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1075	        for (i = 0; i < temp_source->child_count; i++) {
	LD	(IX+-4),0
	JR	L_404
L_402:
; 1076	            expression_to_infix(buffer, temp_source->children[i]);
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+-3)
	LD	DE,(IY+11)
	ADD	HL,BC
	ADD	HL,DE
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_expression_to_infix
	POP	BC
	POP	BC
; 1077	            if (i != temp_source->child_count - 1) strcat(buffer, (use_spaces) ? ", " : ",");
	LD	IY,(IX+-3)
	LD	A,(IY+10)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	DEC	BC
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	JR	Z,L_403
	LD	A,(_use_spaces)
	OR	A,A
	JR	Z,L_399
	LD	BC,L__279
	LD	(IX+-19),BC
	JR	L_400
L_399:
	LD	BC,L__280
	LD	(IX+-19),BC
L_400:
	LD	BC,(IX+-19)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1078	        }
L_403:
	INC	(IX+-4)
L_404:
	LD	A,(IX+-4)
	LD	IY,(IX+-3)
	CP	A,(IY+10)
	JR	C,L_402
; 1079	        strcat(buffer, ")");
	LD	BC,L__282
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1080	    }
L_408:
; 1081	    
; 1082	    free_expression(temp_source, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
; 1083	    
; 1084	    return;
; 1085	    
; 1086	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _expression_to_infix ***************************
;Name                         Addr/Register   Size   Type
;_free_expression                    IMPORT  -----   function
;_get_expression_string              IMPORT  -----   function
;_use_spaces                         IMPORT      1   variable
;_itoa                               IMPORT  -----   function
;_strcat                             IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;temp_buffer                          IX-49     30   variable
;temp397                              IX-19      3   variable
;G_55                                 IX-16      3   variable
;temp356                              IX-13      3   variable
;G_52                                 IX-10      3   variable
;G_53                                  IX-7      3   variable
;i                                     IX-4      1   variable
;temp_source                           IX-3      3   variable
;source                                IX+9      3   parameter
;buffer                                IX+6      3   parameter


; Stack Frame Size: 61 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__240:
	DB	"(-"
	DB	0
L__242:
	DB	")"
	DB	0
L__243:
	DB	"("
	DB	0
L__245:
	DB	"-"
	DB	0
L__247:
	DB	" / "
	DB	0
L__248:
	DB	"/"
	DB	0
L__249:
	DB	")"
	DB	0
L__258:
	DB	" "
	DB	0
L__262:
	DB	" "
	DB	0
L__264:
	DB	"("
	DB	0
L__267:
	DB	" "
	DB	0
L__271:
	DB	" "
	DB	0
L__273:
	DB	")"
	DB	0
L__276:
	DB	"("
	DB	0
L__279:
	DB	", "
	DB	0
L__280:
	DB	","
	DB	0
L__282:
	DB	")"
	DB	0
	SEGMENT CODE
; 1087	
; 1088	/**
; 1089	 
; 1090	 @code
; 1091	 \tikzset{
; 1092	     treenode/.style = {align = center, inner sep = 1mm},
; 1093	     operator_node/.style = {treenode, circle, draw = black},
; 1094	     function_node/.style = {treenode, rectangle, draw = black},
; 1095	     node_nil/.style = {treenode, circle, black}
; 1096	 }
; 1097	 @endcode
; 1098	 
; 1099	 */
; 1100	void expression_to_tikz(char* buffer, const expression* source) {
_expression_to_tikz:
	LD	HL,-55
	CALL	__frameset
; 1101	    
; 1102	    uint8_t i;
; 1103	    char temp_buffer[30];
; 1104	    expression* temp_source = copy_expression(source);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_copy_expression
	POP	BC
	LD	(IX+-3),HL
; 1105	    
; 1106	    if (temp_source->identifier == EXPI_LITERAL) {
	LD	IY,(IX+-3)
	LD	HL,(IY+3)
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_424
; 1107	        strcat(buffer, "child{node{$");
	LD	BC,L__285
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1108	        if (temp_source->sign == -1) strcat(buffer, "- ");
	LD	IY,(IX+-3)
	LD	A,(IY+6)
	CP	A,-1
	JR	NZ,L_413
	LD	BC,L__287
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
L_413:
; 1109	        if (temp_source->value.numeric.denominator == 1) {
	LD	IY,(IX+-3)
	LD	HL,(IY+18)
	LD	E,(IY+21)
	LD	BC,1
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_412
; 1110	            itoa(temp_buffer, temp_source->value.numeric.numerator);
	LD	IY,(IX+-3)
	LD	BC,(IY+14)
	LD	A,(IY+17)
	LD	H,0
	LD	L,A
	PUSH	HL
	PUSH	BC
	PEA	IX+-55
	CALL	_itoa
	POP	BC
	POP	BC
	POP	BC
; 1111	            strcat(buffer, temp_buffer);
	PEA	IX+-55
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1112	        } else {
	JR	L_414
L_412:
; 1113	            strcat(buffer, "\\frac{");
	LD	BC,L__289
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1114	            itoa(temp_buffer, temp_source->value.numeric.numerator);
	LD	IY,(IX+-3)
	LD	BC,(IY+14)
	LD	A,(IY+17)
	LD	H,0
	LD	L,A
	PUSH	HL
	PUSH	BC
	PEA	IX+-55
	CALL	_itoa
	POP	BC
	POP	BC
	POP	BC
; 1115	            strcat(buffer, temp_buffer);
	PEA	IX+-55
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1116	            strcat(buffer, "}{");
	LD	BC,L__290
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1117	            itoa(temp_buffer, temp_source->value.numeric.denominator);
	LD	IY,(IX+-3)
	LD	BC,(IY+18)
	LD	A,(IY+21)
	LD	H,0
	LD	L,A
	PUSH	HL
	PUSH	BC
	PEA	IX+-55
	CALL	_itoa
	POP	BC
	POP	BC
	POP	BC
; 1118	            strcat(buffer, temp_buffer);
	PEA	IX+-55
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1119	            strcat(buffer, "}");
	LD	BC,L__291
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1120	        }
L_414:
; 1121	        strcat(buffer, "$}}");
	LD	BC,L__292
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1122	    }
L_424:
; 1123	    
; 1124	    if (temp_source->identifier == EXPI_SYMBOL || temp_source->identifier == EXPI_VARIABLE) {
	LD	IY,(IX+-3)
	LD	BC,(IY+3)
	LD	(IX+-16),BC
	LD	HL,BC
	LD	BC,2
	OR	A,A
	SBC	HL,BC
	JR	Z,L_423
	LD	BC,3
	LD	HL,(IX+-16)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_442
L_423:
; 1125	        strcat(buffer, "child{node{$");
	LD	BC,L__295
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1126	        if (temp_source->sign == -1) strcat(buffer, "- ");
	LD	IY,(IX+-3)
	LD	A,(IY+6)
	CP	A,-1
	JR	NZ,L_422
	LD	BC,L__297
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
L_422:
; 1127	        strcat(buffer, (strcmp(temp_source->value.symbolic, "pi") == 0) ? "\\pi" : temp_source->value.symbolic);
	LD	BC,L__298
	PUSH	BC
	LD	IY,(IX+-3)
	PEA	IY+14
	CALL	_strcmp
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_420
	LD	BC,L__300
	LD	(IX+-25),BC
	JR	L_421
L_420:
	LD	IY,(IX+-3)
	LEA	BC,IY+14
	LD	(IX+-25),BC
L_421:
	LD	BC,(IX+-25)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1128	        strcat(buffer, "$}}");
	LD	BC,L__301
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1129	    }
L_442:
; 1130	    
; 1131	    if (temp_source->type == EXPT_OPERATION) {
	LD	IY,(IX+-3)
	LD	HL,(IY+0)
	LD	BC,2
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_457
; 1132	        strcat(buffer, (temp_source->parent) ? "child{node[operator_node]{$" : "\\node[operator_node]{$");
	LD	IY,(IX+-3)
	LD	HL,(IY+7)
	CALL	__icmpzero
	JR	Z,L_427
	LD	BC,L__304
	LD	(IX+-7),BC
	JR	L_428
L_427:
	LD	BC,L__305
	LD	(IX+-7),BC
L_428:
	LD	BC,(IX+-7)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1133	        if (temp_source->sign == -1) strcat(buffer, "- ");
	LD	IY,(IX+-3)
	LD	A,(IY+6)
	CP	A,-1
	JR	NZ,L_434
	LD	BC,L__307
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
L_434:
; 1134	        strcat(buffer, (temp_source->identifier == EXPI_EXPONENTATION) ? "\\wedge" : get_expression_string(temp_source->identifier));
	LD	IY,(IX+-3)
	LD	BC,(IY+3)
	LD	(IX+-19),BC
	LD	HL,BC
	LD	BC,9
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_432
	LD	BC,L__309
	LD	(IX+-10),BC
	JR	L_433
L_432:
	LD	BC,(IX+-19)
	PUSH	BC
	CALL	_get_expression_string
	POP	BC
	LD	(IX+-10),HL
L_433:
	LD	BC,(IX+-10)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1135	        strcat(buffer, "$}");
	LD	BC,L__310
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1136	        for (i = 0; i < temp_source->child_count; i++) expression_to_tikz(buffer, temp_source->children[i]);
	LD	(IX+-4),0
	JR	L_438
L_436:
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	LD	IY,(IX+-3)
	LD	BC,(IY+11)
	ADD	HL,DE
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_expression_to_tikz
	POP	BC
	POP	BC
	INC	(IX+-4)
L_438:
	LD	A,(IX+-4)
	LD	IY,(IX+-3)
	CP	A,(IY+10)
	JR	C,L_436
; 1137	        if (temp_source->parent) strcat(buffer, "}");
	LD	IY,(IX+-3)
	LD	HL,(IY+7)
	CALL	__icmpzero
	JR	Z,L_457
	LD	BC,L__313
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1138	    }
L_457:
; 1139	    
; 1140	    if (temp_source->type == EXPT_FUNCTION || temp_source->type == EXPT_STRUCTURE) {
	LD	IY,(IX+-3)
	LD	BC,(IY+0)
	LD	(IX+-22),BC
	LD	HL,BC
	LD	BC,3
	OR	A,A
	SBC	HL,BC
	JR	Z,L_456
	LD	BC,4
	LD	HL,(IX+-22)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_458
L_456:
; 1141	        strcat(buffer, (temp_source->parent) ? "child{node[function_node]{" : "\\node[function_node]{");
	LD	IY,(IX+-3)
	LD	HL,(IY+7)
	CALL	__icmpzero
	JR	Z,L_446
	LD	BC,L__317
	LD	(IX+-13),BC
	JR	L_447
L_446:
	LD	BC,L__318
	LD	(IX+-13),BC
L_447:
	LD	BC,(IX+-13)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1142	        if (temp_source->sign == -1) strcat(buffer, "- ");
	LD	IY,(IX+-3)
	LD	A,(IY+6)
	CP	A,-1
	JR	NZ,L_449
	LD	BC,L__320
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
L_449:
; 1143	        strcat(buffer, get_expression_string(temp_source->identifier));
	LD	IY,(IX+-3)
	LD	BC,(IY+3)
	PUSH	BC
	CALL	_get_expression_string
	POP	BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1144	        strcat(buffer, "}");
	LD	BC,L__321
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1145	        for (i = 0; i < temp_source->child_count; i++) expression_to_tikz(buffer, temp_source->children[i]);
	LD	(IX+-4),0
	JR	L_453
L_451:
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	LD	IY,(IX+-3)
	LD	BC,(IY+11)
	ADD	HL,DE
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_expression_to_tikz
	POP	BC
	POP	BC
	INC	(IX+-4)
L_453:
	LD	A,(IX+-4)
	LD	IY,(IX+-3)
	CP	A,(IY+10)
	JR	C,L_451
; 1146	        if (temp_source->parent) strcat(buffer, "}");
	LD	IY,(IX+-3)
	LD	HL,(IY+7)
	CALL	__icmpzero
	JR	Z,L_458
	LD	BC,L__324
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strcat
	POP	BC
	POP	BC
; 1147	    }
L_458:
; 1148	    
; 1149	    free_expression(temp_source, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_free_expression
	POP	BC
	POP	BC
; 1150	    
; 1151	    return;
; 1152	    
; 1153	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _expression_to_tikz ***************************
;Name                         Addr/Register   Size   Type
;_free_expression                    IMPORT  -----   function
;_get_expression_string              IMPORT  -----   function
;_strcmp                             IMPORT  -----   function
;_itoa                               IMPORT  -----   function
;_strcat                             IMPORT  -----   function
;_copy_expression                    IMPORT  -----   function
;temp_buffer                          IX-55     30   variable
;temp418                              IX-25      3   variable
;G_62                                 IX-22      3   variable
;G_61                                 IX-19      3   variable
;G_59                                 IX-16      3   variable
;temp444                              IX-13      3   variable
;temp430                              IX-10      3   variable
;temp425                               IX-7      3   variable
;i                                     IX-4      1   variable
;temp_source                           IX-3      3   variable
;source                                IX+9      3   parameter
;buffer                                IX+6      3   parameter


; Stack Frame Size: 67 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__285:
	DB	"child{node{$"
	DB	0
L__287:
	DB	"- "
	DB	0
L__289:
	DB	"\\frac{"
	DB	0
L__290:
	DB	"}{"
	DB	0
L__291:
	DB	"}"
	DB	0
L__292:
	DB	"$}}"
	DB	0
L__295:
	DB	"child{node{$"
	DB	0
L__297:
	DB	"- "
	DB	0
L__298:
	DB	"pi"
	DB	0
L__300:
	DB	"\\pi"
	DB	0
L__301:
	DB	"$}}"
	DB	0
L__304:
	DB	"child{node[operator_node]{$"
	DB	0
L__305:
	DB	"\\node[operator_node]{$"
	DB	0
L__307:
	DB	"- "
	DB	0
L__309:
	DB	"\\wedge"
	DB	0
L__310:
	DB	"$}"
	DB	0
L__313:
	DB	"}"
	DB	0
L__317:
	DB	"child{node[function_node]{"
	DB	0
L__318:
	DB	"\\node[function_node]{"
	DB	0
L__320:
	DB	"- "
	DB	0
L__321:
	DB	"}"
	DB	0
L__324:
	DB	"}"
	DB	0
	XREF _default_priorities:ROM
	XREF _use_spaces:ROM
	XREF _use_abbrevations:ROM
	XREF _simplify:ROM
	XREF _string_to_literal:ROM
	XREF _any_expression_to_expression_recursive:ROM
	XREF _dtoa:ROM
	XREF _itoa:ROM
	XREF _string_to_lower:ROM
	XREF _uintmax_max_value:ROM
	XREF _smart_free_all:ROM
	XREF _smart_free:ROM
	XREF _smart_realloc:ROM
	XREF _smart_alloc:ROM
	XREF _smart_alloc_is_recording:ROM
	XREF _allocated_pointers:ROM
	XREF _strcmp:ROM
	XREF _strlen:ROM
	XREF _strstr:ROM
	XREF _strcat:ROM
	XREF _strcpy:ROM
	XREF __lcmpu:ROM
	XREF __imulu:ROM
	XREF __fadd:ROM
	XREF __fmul:ROM
	XREF __fdiv:ROM
	XREF __fcmp:ROM
	XREF __ltof:ROM
	XREF __ultof:ROM
	XREF __stoiu:ROM
	XREF __itol:ROM
	XREF __frameset0:ROM
	XREF __frameset:ROM
	XREF __icmpzero:ROM
	XREF __case8:ROM
	XDEF _expression_to_tikz
	XDEF _expression_to_infix
	XDEF _expression_to_string
	XDEF _get_expression_identifier
	XDEF _get_expression_string
	XDEF _literal_to_double_symbol
	XDEF _literal_to_double
	XDEF _double_to_literal
	XDEF _guess_symbol
	XDEF _collect_symbols
	XDEF _order_children
	XDEF _get_order_score
	XDEF _get_symbol_order_score
	XDEF _swap_expressions
	XDEF _replace_null_with_zero
	XDEF _replace_occurences
	XDEF _count_occurrences
	XDEF _expression_is_numerical
	XDEF _expression_is_reziprocal
	XDEF _expression_contains_division
	XDEF _symbol_is_constant
	XDEF _expression_is_constant
	XDEF _expression_is_smaller_than
	XDEF _expression_is_greater_than
	XDEF _expressions_are_equivalent
	XDEF _expressions_are_identical
	XDEF _set_parents
	XDEF _merge_nested_lists
	XDEF _embed_in_list_if_necessary
	XDEF _remove_null_children
	XDEF _remove_child_at_index
	XDEF _append_child
	XDEF _free_all_except
	XDEF _free_expression
	XDEF _replace_expression
	XDEF _copy_expression
	XDEF _new_trigonometic_periodicity
	XDEF _new_symbol
	XDEF _new_literal
	XDEF _new_expression
	XDEF _keyword_identifiers
	XDEF _keyword_strings
	END
